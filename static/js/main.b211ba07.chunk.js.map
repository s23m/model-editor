{"version":3,"sources":["Resources/vertex.svg","Resources/edge.svg","Resources/specialisation.svg","Resources/visibility.svg","Resources/select.svg","Resources/artifact.svg","Resources/container.svg","Resources/create_folder.svg","Resources/delete_folder.svg","Resources/changeFolderName.svg","Resources/NewModel.svg","Resources/DeleteModel.svg","Resources/editModel.svg","Resources/createVertex.svg","DataStructures/SemanticIdentity.js","DataStructures/Vertex.js","DataStructures/ArrowProperties.js","DataStructures/Cardinality.js","DataStructures/EdgeEnd.js","UIElements/LeftMenu.js","UIElements/CanvasDraw.js","DataStructures/Arrow.js","DataStructures/Graph.js","UIElements/SemanticDomainEditor.js","UIElements/Canvas.js","UIElements/ContainmentTree.js","Serialisation/NewFileManager.js","UIElements/MainView.js","UIElements/ContextMenu.js","App.js","ServiceWorker.js","index.js"],"names":["module","exports","SemanticIdentity","name","description","abbreviation","shortAbbreviation","UUID","translations","this","typeName","undefined","replace","c","crypto","getRandomValues","Uint8Array","toString","padding","Vertex","title","content","colour","x","y","width","height","semanticIdentity","newConstructor","loadedVertex","console","log","icons","selected","imageElements","imageElement","fontSize","orignalVertex","originalUUID","Origin","realHeight","isAbstract","vertexPath","vertexModelKey","vertexRenderKey","renderedx","renderedy","awayx","awayy","status","isContainer","Math","max","getCurrentModel","getModelRenderKey","floor","random","key","newSem","path","newOrigin","mergedContent","i","length","concat","fileName","fileNames","Icons","Text","index","indexOf","push","splice","text","side","canvasContext","ex","ey","pad","hasContent","iconAreaHeight","contentHeight","draw","possibleWidth","iconListLen","increaseWidthIfNecessary","measureText","is","font","measuredNameText","maxWidth","measuredText","shadowOffsetX","shadowOffsetY","fillStyle","fillRect","strokeRect","drawMarker","dy","txPos","tyPos","slice","fillText","iconHeight","strokeStyle","cursorX","cursorY","getNearestSide","sides","xPercentage","abs","yPercentage","goodSide","forEach","distanceThreshold","rightDist","topDist","leftDist","closestIndex","closestDistance","distArrays","shortest","EdgeEnd","EdgeEndToString","StringToEdgeEnd","LineColour","LineColourToStringName","StringNameToLineColour","LineType","LineTypeToString","StringToLineType","Cardinality","lowerBound","upperBound","attachedToUUID","isVisible","numLowerBound","numUpperBound","getDescription","lower","upper","value","headType","ArrowProps","cardinality","label","edgeEndRenderKey","getCurrentRenderKey","edgeEndModelKey","type","visibility","points","strokeColour","fillColour","beginPath","moveTo","X","Y","lineTo","closePath","fill","stroke","angle","lineColour","angleFromLine","PI","angleInverted","arrowPoints","cos","sin","drawLines","sideLength","deg30","trianglePoints","deg20","diamondPoints","drawArrowEnd","drawTriangleEnd","drawDiamondEnd","newType","LeftMenuType","TreeView","Arrow","Artifact","Container","LeftMenuTypeToString","StringToLeftMenuType","canvasElement","mouseStartX","mouseStartY","previousObject","mouseOriginX","mouseOriginY","canvasWidth","canvasHeight","Tool","Select","Visibility","Edge","Specialisation","LeftMenu","props","testUpdateLabel","setPath","getVertexColour","state","selectedObject","getColour","setVertexColour","setColour","hex","canvasDraw","deleteTitle","setState","getMenu","leftMenuContents","toolbar","id","className","onClick","setMode","src","iconSelect","alt","onKeyDown","onKeyPressed","iconVertex","iconArtifact","iconContainer","iconEdge","iconSpecialisation","iconVisibility","menu","setLeftMenu","onInput","handleChange","getContentAsString","getS23MIconsSelector","getColourPicker","defaultChecked","getAbstract","toggleAbstract","deselectElement","vertexDeleteElement","placeholder","defaultValue","onKeyUp","setTitle","setContent","deleteElement","edgeType","getNavigable","setNavigable","getAggregation","setAggregation","onChange","getSourceCardinalityVisibility","toggleSourceCardinalityVisibility","getSourceCardinalityLowerBound","min","updateCardinality","getSourceCardinalityUpperBound","getDestCardinalityVisibility","toggleDestCardinalityVisibility","getDestCardinalityLowerBound","getDestCardinalityUpperBound","sourceEdgeEnd","setStartLabel","destEdgeEnd","setEndLabel","e","stripElement","ref","setFormRef","bind","formRef","element","event","target","mainState","selectedItem","drawMode","document","addEventListener","keyCode","nextProps","nextContext","prevProps","prevState","snapshot","leftMenu","getElementById","preventDefault","fetch","method","headers","then","res","json","data","icon","newTitle","newContent","split","newLineType","setLineType","newColour","setLineColour","newLabel","sourceLowerBound","sourceUpperBound","currentSourceVisibility","destLowerBound","destUpperBound","currentDestVisibility","updateSourceCardinality","updateDestCardinality","dropdownOptions","disabled","shouldIconBeSelected","setIcon","shouldTextBeSelected","setText","DropdownButton","color","onChangeComplete","presetColors","isTextSet","isIconSet","toggleNavigable","checked","toggleAggregation","SourceAggregation","DestAggregation","trimPath","reset","React","Component","objectsList","pathData","sourceVertexUUID","destVertexUUID","updateAttachedVertices","rebuildPath","lineType","sourceIsNavigable","destIsNavigable","sourceIsAggregation","destIsAggregation","arrowModelKey","arrowRenderKey","connectedObjectUUIDs","getObjectUUIDList","objects","pathItem","getZerothCasePathItem","error","output","item","pathStart","pathEnd","toggleVisibility","val","vertex","nodeIndex","d","topLeft","top","topRight","right","bottomRight","bottom","bottomLeft","left","vertexNodes","lineAngle","atan2","getSY","getNSY","getSX","getNSX","getEY","getNEY","getEX","getNEX","startIndex","endIndex","indexSx","indexEx","indexSy","indexEy","sourceText","destText","sourceCtext","destCtext","sxOffset","syOffset","exOffset","eyOffset","sxOffsetc","syOffsetc","exOffsetc","eyOffsetc","sourceTextWidth","destTextWidth","sourceCtextWidth","destCtextWidth","charWidth","sxFlip","syFlip","exFlip","eyFlip","E1index","E2index","startLRArrow","isPathSegmentLR","endLRArrow","SSX","SSY","SEX","SEY","ESX","ESY","EEX","EEY","sourceCardText","destCardText","Offsets","getTextOffsets","setLineDash","from","to","drawStartHead","drawEndHead","drawLabelsAndCardinalities","pos","cx","cy","intersectsSegment","getDistance","VertexNode","children","Set","cleanObjectPath","getModelName","vertexObjectPath","node","add","traversedVertices","isRemoved","has","delete","child","remove","recursive","getVertexNode","flattenedArray","childNode","flatten","flattenVertexNodes","returnOption","parsedRenderKey","ArrowChildren","VertexChildren","currentObjects","getRenderKey","setVertexTreePath","tempTreeObj","renderkey","modelkey","getModelKey","opened","finalString","ourSourceEnd","ourDestEnd","textSource","textDest","j","someObject","treeAppearanceSwitches","arrowIcon","folderTitle","treePath","ArrowEdge","flattenedVertexNodes","arrow","updateVertices","sourceVertexNodeObject","destVertexNodeObject","isSourceFound","isDestFound","vertexNode","Graph","vertexArrayFlattened","arrowArrayFlattened","rootVertices","arrows","Array","isArray","object","addVertex","addArrow","originalVertex","sID","getArrowEdge","destVertexNode","sourceVertexNode","isAnotherRoot","sourceVertex","returnArray","destVertex","newobject","isEquivalentArrow","isArrowWithSameSource","isEquivalentSource","isEquivalentDest","removeFromChildren","rootNode","arrowEdge","doFlattenVertices","doFlattenArrows","verticesSet","arrowsSet","yRows","zoom","savedArrows","currentRenderKey","totalRenderKeys","currentModel","totalModels","setNewRenderKey","newKey","getTotalRenderKeys","incrementTotalRenderKeys","getCurrentObjects","setNewModel","newModel","getTotalModels","incrementTotalModels","arrowPath","lastX","lastY","resizing","arrowType","firstArrowJoint","cancelDraw","past_location","past_size","blockBeenSelected","nameElement","resetMouseOrigin","canvasRect","getBoundingClientRect","canvasContainer","getElementsByClassName","styleHeight","getComputedStyle","getPropertyValue","styleWidth","setAttribute","getEffectiveZoom","recalculateScale","clearCanvas","drawAll","updateArrows","resetTransform","scale","sourceUUIDs","ArrowUUIDSource","destUUIDs","ArrowUUIDDest","findNearestGridY","slotHeight","checkResizeBounds","currentObjectsFlattened","bounds","getBounds","x1","y1","x2","y2","inYBounds","inXBounds","getConnectionDataForArrow","nearest","nearestDistance","sideData","getNearestSideFrom","coordinate","coord","snapped","lastPathX","lastPathY","relAngle","l","angles","nearestAngle","nearestRad","xv","yv","getSelectedObject","canvas","resizeObjectOnMouseMove","resizeVars","coords","getGraphXYFromMouseEvent","expandSide","conData","StickArrowToObject","updateA","addObject","setCurrentObjects","newObjects","arrowToolSelected","getObjectFromUUID","foundObject","connectionData","onLeftMousePress","tool","saveBlockStates","onmousemove","intersection","findIntersected","cDist","nearestPointIndex","nearestArrow","point","hypot","findNearestArrowPointIndex","func","moveArrowPointOnMouseMove","removeEventListener","onMouseMove","compareSizesToMoveAll","Object","objectID","box","verticalArray","horizontalArray","boxArray","collectMehBox","boxes","bigbox","arrangeboxesandarrows","b","collectsidebox","arrangeboxesandarrowshorizontal","onLeftMouseRelease","secondObject","newObject","createObject","first","second","upBoxes","upArrows","downBoxes","downArrows","leftBoxes","leftArrows","rightBoxes","rightArrows","bigBox","smallBox","shiftBoxes","orderCoordinates","vy1","vy2","createArtifact","newVert","setIsContainer","createContainer","position","globalAlpha","onMiddleClick","savedObjects","shiftDown","friendObject","arrowsVert","arrowsHoriz","ObjectsToCheck","nextObjects","n","newfriendObject","nf","of","p","F","S","saveDisX","saveDisY","moveObject","friends","k","solidifyObject","setZoom","newZoom","xpos","ypos","oldLineWidth","lineWidth","oldStrokeStyle","oldFillStyle","arc","sqrt","pow","intersects","updateLinkedContainers","inputContainer","updateVertex","vertexData","getLinkedVertex","parentRenderKey","verticies","newPath","clientX","clientY","sx","sy","rows","setRows","setColumns","textInput","createRef","translationColumns","onSave","workbook","xlsx","writeBuffer","buffer","saveAs","Blob","getRowId","row","styles","input","container","selector","StartEditActionSelector","withStyles","defaultAction","changeAction","classes","Grid","alignItems","Typography","OutlinedInput","labelWidth","margin","MenuItem","SelectTextChecker","isSelectText","changeSelectText","FormControlLabel","control","Checkbox","EditPropsPanel","FocusableCell","restProps","Cell","tabIndex","onFocus","useState","createColumns","columns","setColumnsRet","columnName","editingEnabled","editingStateColumnExtensions","generatedRows","setRowsRet","wordWrapEnabled","tableColumnExtensions","startEditAction","setStartEditAction","selectTextOnEditStart","setSelectTextOnEditStart","exporterRef","useRef","startExport","useCallback","current","exportGrid","Paper","InputGroup","FormControl","aria-label","aria-describedby","Append","Button","variant","updateColumns","addColumn","removeColumn","onCommitChanges","changedRows","added","changed","deleted","startingAddedId","map","treeVert","getVertexData","updateChangedObject","o","updateChangedObjects","deletedSet","filter","columnExtensions","cellComponent","getRowForObject","translation","columnNames","set","selectMultiple","selectDown","Canvas","ocm","mouseDown","startX","startY","shiftKey","button","ctrlKey","foundEnd","ob","mouseUp","window","setTimeout","CollideCount","canvasRef","zoomLevel","dragEnter","dragOver","dragLeave","drop","droppedSemanticID","dataTransfer","getData","droppedVertex","vert","mouseCoords","newName","visibilityCheck","canvasVert","originText","getContainerData","find","folder","renderKey","setOrigin","onContextMenu","onMouseDown","onMouseUp","onMouseLeave","mouseLeave","getSaveData","vertexObjects","arrowObjects","treeData","folderData","getFolderData","decoyFolderData","decoyVertexData","modelObjects","getModelData","decoyModelObjects","vertices","tree","packages","dPackages","treeVertex","dTreeVertex","graph","dGrraph","renderKeys","modelKeys","load","jsonString","saveData","JSON","parse","newFolderData","newData","newTreeData","newVertices","setVertexData","setDecoyVertexData","setModelData","setDecoyModelData","setTotalRenderKey","setTotalModelKeys","setSelectedFolderKey","folderName","MainProgramClass","updateFolderName","addFolder","a","handleAddFolder","getSelectedFolderKey","setLeftMenuToTree","deleteFolder","handleDeleteFolder","editFolderName","handleRenameFolder","handleAddVertex","addModel","handleAddModel","deleteModel","handleDeleteModel","editModelName","handleRenameModel","cZoom","setModelName","modelName","showFile","refreshTree","File","FileReader","FileList","file","querySelector","files","reader","readAsText","result","onload","alert","toggleSemanticDomainState","semanticTableEnabled","newRows","resetRows","theObject","div","SelectedTool","style","backgroundColor","currentlySelectedObject","showingVertPath","someVertexPath","mode","nearestObject","ctrl","OP","setSelected","None","SemanticDomainEditor","size","Dropdown","Item","confirm","location","reload","DLelement","createElement","href","toDataURL","download","body","appendChild","click","JSONdata","dataTransformed","stringify","dataFile","URL","createObjectURL","removeChild","save","iconNewFolder","iconDeleteFolder","iconEditFolder","iconaddVertex","iconNewModel","iconDeleteModel","iconEditModel","readonly","folderDataRoot","selectedFolderKey","folderAltered","loadFirstModel","modelKey","setPresent","setAway","model","parentKey","tempFolderThing","NaN","folderThing2","selectedRenderKey","deleteFolderChildren","selectedFolder","folderChildren","deleteModelChildren","selectedModel","verticesFolder","v","rKey","vertexName","tempVertexThing","vertexThing2","semanticID","decoyModelThing","tempModelThing","handleDeleteVertex","selectedUUID","selectedModelKey","mKey","determineOwnership","vertexOrArrow","determineSubFolders","getModelNameFromKey","rightClickedObject","initialFolderAdded","ContainmentTree","canvasItems","subFolderItems","combinedItems","toTreeViewElement","core","root","selectedVertex","highestLevel","nextLevel","vertexOrEdge","actualObject","cont","treeDat","dragStart","vertData","setData","original","handleElementSelect","draggable","rightClickedItem","rightClickedItemKey","menuType","ContextMenu","xPos","yPos","showMenu","handleClick","includes","newFolderKey","newRkey","handleModelRebase","parseInt","baseUUID","mirrorUUID","baseSemantic","linkContainer","keys","handleKey","handleContextMenu","source","dest","sourceName","destName","pageX","pageY","renderedOutput","matchingContainers","matchingModels","matchingUUID","renderedContainers","renderedModels","App","elementID","Boolean","hostname","match","ReactDOM","render","StrictMode","getContext","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.b211ba07.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/vertex.4937cefd.svg\";","module.exports = __webpack_public_path__ + \"static/media/edge.09e9d9dc.svg\";","module.exports = __webpack_public_path__ + \"static/media/specialisation.3320bc80.svg\";","module.exports = __webpack_public_path__ + \"static/media/visibility.5452d398.svg\";","module.exports = __webpack_public_path__ + \"static/media/select.8b3cad47.svg\";","module.exports = __webpack_public_path__ + \"static/media/artifact.91473c28.svg\";","module.exports = __webpack_public_path__ + \"static/media/container.ddecd459.svg\";","module.exports = __webpack_public_path__ + \"static/media/create_folder.5ddfbbc9.svg\";","module.exports = __webpack_public_path__ + \"static/media/delete_folder.ccd4d6e6.svg\";","module.exports = __webpack_public_path__ + \"static/media/changeFolderName.d6c49e9c.svg\";","module.exports = __webpack_public_path__ + \"static/media/NewModel.5f359781.svg\";","module.exports = __webpack_public_path__ + \"static/media/DeleteModel.8ff04828.svg\";","module.exports = __webpack_public_path__ + \"static/media/editModel.0c58ce6e.svg\";","module.exports = __webpack_public_path__ + \"static/media/createVertex.97bc72a7.svg\";","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nexport function createUUID() {\r\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\r\n        // eslint-disable-next-line\r\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\r\n    );\r\n}\r\n\r\nexport class SemanticIdentity {\r\n    constructor(name, description, abbreviation, shortAbbreviation, UUID, translations){\r\n        this.typeName = \"SemanticIdentity\";\r\n        \r\n        if (UUID !== undefined){\r\n            this.UUID = UUID;\r\n        } else {\r\n            this.UUID = createUUID();\r\n        }\r\n\r\n        this.name = name;\r\n        this.description = description;\r\n        this.abbreviation = abbreviation;\r\n        this.shortAbbreviation = shortAbbreviation;\r\n\r\n        if (translations !== undefined){\r\n            this.translations = translations;\r\n        } else {\r\n            this.translations = [];\r\n        }\r\n    }\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport { drawMarker, distanceThreshold, getCurrentRenderKey, getCurrentModel } from \"../UIElements/CanvasDraw\";\r\nimport { getModelRenderKey } from \"../UIElements/ContainmentTree\";\r\nimport { SemanticIdentity, createUUID } from \"./SemanticIdentity\";\r\n\r\nexport var padding = 5;\r\nexport var defaultColour = \"#FFD5A9\";\r\nexport var defaultMinimumSize = 30;\r\n\r\nexport class Vertex {\r\n\r\n    //As javascript doesnt have method overloading, newConstructor is used to access the secondary constructor when flagged 1 \r\n\r\n    //at some point change to use destructuring, which will require changing every use of this method to use destructing too\r\n    constructor(title = \"unnamed\", content, colour, x, y, width, height, semanticIdentity,newConstructor=0,loadedVertex=0) {\r\n        console.log(newConstructor)\r\n\r\n        //This constructor is used to turn a vertex loaded from JSON.parse back into a vertex object\r\n        if(newConstructor === 1){\r\n            console.log(loadedVertex)\r\n\r\n            this.typeName = loadedVertex.typeName;\r\n            this.semanticIdentity = loadedVertex.semanticIdentity;\r\n            this.title = loadedVertex.title;\r\n            this.content = loadedVertex.content;\r\n            this.colour = loadedVertex.colour;\r\n            this.x = loadedVertex.x;\r\n            this.y = loadedVertex.y;\r\n            this.icons = loadedVertex.icons;\r\n            this.selected = false;\r\n            this.imageElements = loadedVertex.imageElement;\r\n            this.fontSize = 12;\r\n            this.orignalVertex = loadedVertex.orignalVertex;\r\n            this.originalUUID = loadedVertex.originalUUID; \r\n            this.Origin = loadedVertex.Origin; \r\n            this.width = loadedVertex.width;\r\n            this.height = loadedVertex.height;\r\n            this.realHeight = loadedVertex.realHeight;\r\n            this.isAbstract = loadedVertex.isAbstract;\r\n            this.vertexPath = loadedVertex.vertexPath;\r\n            this.vertexModelKey = loadedVertex.vertexModelKey;\r\n            this.vertexRenderKey = loadedVertex.vertexRenderKey;\r\n            this.renderedx = loadedVertex.renderedx;\r\n            this.renderedy = loadedVertex.renderedy;\r\n            this.awayx = loadedVertex.awayx;\r\n            this.awayy = loadedVertex.awayy;\r\n            this.status = loadedVertex.status;\r\n\r\n        }\r\n\r\n        else{\r\n            this.typeName = \"Vertex\";\r\n\r\n            if (semanticIdentity !== undefined){\r\n                this.semanticIdentity = semanticIdentity;\r\n            } else {\r\n                this.semanticIdentity = new SemanticIdentity(title,\"\",\"\",\"\", undefined ,[]);\r\n            }\r\n\r\n            this.title = title;\r\n\r\n\r\n            if(content === undefined){\r\n                this.content = \"\"\r\n            }\r\n            else{\r\n            this.content = content;\r\n            }\r\n\r\n            this.colour = colour\r\n            this.x = x;\r\n            this.y = y;\r\n            this.icons = [[],[],[]];\r\n            this.selected = false;\r\n            this.imageElements = {};\r\n            this.fontSize = 12;\r\n            this.orignalVertex = true; // bool to see if the selected vertex is the original\r\n            this.originalUUID = this.originalUUID // going to store the UUID of the original vertex here as canvas objects need to be given a unique semanticUUID \r\n            this.isContainer = false; //Ignore this now, Kieth explained how containers work after finishing old implementation, direction other team was going was wrong - Lachlan\r\n            this.Origin = \"\" //package the vertex originates from if needed\r\n    \r\n\r\n            // Note these values often change in runtime\r\n            this.width = width;\r\n            this.height = height;\r\n\r\n            this.realHeight = height;\r\n\r\n            // Make sure width and height meet a reasonable minimum\r\n            this.width = Math.max(width, defaultMinimumSize);\r\n            this.height = Math.max(height, defaultMinimumSize);\r\n\r\n            this.isAbstract = false;\r\n\r\n            //Store the path to your given vertex here\r\n            this.vertexPath = \"\";\r\n\r\n            // USed to decide where to render the object\r\n            this.vertexModelKey = getCurrentModel();\r\n\r\n            // Used to decide where the object goes in the tree\r\n            this.vertexRenderKey = getModelRenderKey(this.vertexModelKey);\r\n\r\n\r\n            // Used for moving vertices out of the way when they're not being rendered to prevent invisible overlap\r\n            this.renderedx = x;\r\n            this.renderedy = y;\r\n\r\n            this.awayx = Math.floor(Math.random() * 2000000)+100000;\r\n            this.awayy = Math.floor(Math.random() * 2000000)+100000;\r\n\r\n            this.status = \"present\"\r\n        }\r\n        \r\n    }\r\n\r\n    // Save a vertice's proper x and y coordinate for later rendering and then send the vertex somewhere else\r\n    setAway(){\r\n        if (this.status === \"present\"){\r\n            this.renderedx = this.x;\r\n            this.renderedy = this.y;\r\n\r\n            this.x = this.awayx;\r\n            this.y = this.awayy;\r\n\r\n            this.status = \"away\"\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    setPresent(){\r\n\r\n        if (this.status === \"away\"){\r\n            this.x = this.renderedx;\r\n            this.y = this.renderedy;\r\n\r\n            this.status = \"present\"\r\n        }\r\n        \r\n    }\r\n\r\n    setModelKey(key){\r\n        this.vertexModelKey = key;\r\n    }\r\n\r\n    getModelKey(){\r\n        return this.vertexModelKey;\r\n    }\r\n\r\n\r\n    getSemantic(){\r\n        return this.SemanticIdentity\r\n    }\r\n\r\n    setSemantic(newSem){\r\n        this.SemanticIdentity = newSem;\r\n    }\r\n\r\n    // Set the render key. Done in ContainmentTree.js\r\n    setRenderKey(key){\r\n        this.vertexRenderKey = key;\r\n    }\r\n\r\n    // Get the render key. Called in CanvasDraw.js\r\n    getRenderKey(){\r\n        return this.vertexRenderKey;\r\n    }\r\n\r\n    setPath(path){\r\n        this.vertexPath = path;\r\n    }\r\n\r\n    getPath(){\r\n        return this.vertexPath;\r\n    }\r\n\r\n    setSelected(selected) {\r\n        this.selected = selected;\r\n    }\r\n\r\n    getColour(){\r\n        return this.colour\r\n    }\r\n\r\n    setColour(colour){\r\n        this.colour = colour;\r\n    }\r\n\r\n    setTitle(title) {\r\n        this.title = title;\r\n        this.semanticIdentity.name = title;\r\n    }\r\n\r\n    setContent(content) {\r\n        this.content = content;\r\n        this.semanticIdentity.description = content;\r\n    }\r\n\r\n    getAbstract(){\r\n        return this.isAbstract\r\n    }\r\n\r\n    toggleAbstract(){\r\n        this.isAbstract = !this.isAbstract\r\n    }\r\n\r\n    setOrigin(newOrigin){\r\n        this.Origin = newOrigin;\r\n    }\r\n    getOrigin(){\r\n        return this.Origin;\r\n    }\r\n\r\n    getContentAsString() {\r\n        if (this.content !== null) {\r\n            let mergedContent = \"\";\r\n            \r\n            for (let i = 0; i < this.content.length; i++) {\r\n                mergedContent = mergedContent.concat(this.content[i]);\r\n                if (i < this.content.length - 1) {\r\n                    mergedContent = mergedContent.concat(\"\\n\");\r\n                }\r\n            }\r\n            \r\n            return mergedContent;\r\n\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    setIcon(fileName) {\r\n        let fileNames = this.icons[0];\r\n        let Icons = this.icons[1];\r\n        let Text = this.icons[2];\r\n\r\n        let index = fileNames.indexOf(fileName);\r\n\r\n        //icon not part of this vertex yet\r\n        if (index === -1) {\r\n            fileNames.push(fileName);\r\n            Icons.push(true);\r\n            Text.push(false);\r\n\r\n        } else {\r\n            Icons[index] = !Icons[index]\r\n        }\r\n\r\n        if (Text[index] === false && Icons[index] === false) {\r\n            Icons.splice(index,1);\r\n            Text.splice(index,1);\r\n            fileNames.splice(index,1);\r\n        }\r\n\r\n    }\r\n\r\n    setText(fileName) {\r\n        let fileNames = this.icons[0];\r\n        let icons = this.icons[1];\r\n        let text = this.icons[2];\r\n\r\n        let index = fileNames.indexOf(fileName);\r\n\r\n        //icon not part of this vertex yet\r\n        if (index === -1) {\r\n            fileNames.push(fileName);\r\n            icons.push(false);\r\n            text.push(true);\r\n\r\n        } else {\r\n            text[index] = !text[index]\r\n        }\r\n\r\n        if (text[index] === false && icons[index] === false) {\r\n            icons.splice(index,1);\r\n            text.splice(index,1);\r\n            fileNames.splice(index,1);\r\n        }\r\n\r\n    }\r\n\r\n    isIconSet(fileName) {\r\n        let index = this.icons[0].indexOf(fileName);\r\n        if (index === -1) {\r\n            return false;\r\n        }\r\n        return this.icons[1][index];\r\n    }\r\n\r\n    isTextSet(fileName) {\r\n            let index = this.icons[0].indexOf(fileName);\r\n            if (index === -1) {\r\n                return false;\r\n            } else {\r\n                return this.icons[2][index];\r\n            }\r\n    }\r\n\r\n    getBounds() {\r\n        return [this.x, this.y, this.x+this.width, this.y+this.realHeight-padding];\r\n    }\r\n\r\n    expandSide(side, x, y,canvasContext) {\r\n        let ex = 0;\r\n        let ey = 0;\r\n\r\n        let pad = (this.hasContent() ? padding*4 : padding*2);\r\n\r\n        switch (side) {\r\n            case \"topLeft\":\r\n                ey += this.y + this.height;\r\n                this.y = y;\r\n                this.height = ey-this.y;\r\n                ex += this.x + this.width;\r\n                this.x = x;\r\n                this.width = ex-this.x;\r\n                break;\r\n\r\n            case \"topRight\":\r\n                ey += this.y + this.height;\r\n                this.y = y;\r\n                this.height = ey-this.y;\r\n                this.width = x-this.x;\r\n                break;\r\n\r\n            case \"bottomLeft\":\r\n\r\n                this.height = y-this.y  - this.iconAreaHeight - this.contentHeight - pad;\r\n                ex += this.x + this.width;\r\n                this.x = x;\r\n                this.width = ex-this.x;\r\n                break;\r\n\r\n            case \"bottomRight\":\r\n\r\n                this.height = y - this.y - this.iconAreaHeight - this.contentHeight - pad;\r\n                this.width = x-this.x;\r\n                break;\r\n\r\n            case \"left\":\r\n                ex += this.x + this.width;\r\n                this.x = x;\r\n                this.width = ex-this.x;\r\n                break;\r\n\r\n            case \"right\":\r\n                this.width = x-this.x;\r\n                break;\r\n\r\n            case \"top\":\r\n                ey += this.y + this.height;\r\n                this.y = y;\r\n                this.height = ey-this.y;\r\n                break;\r\n\r\n            case \"bottom\":\r\n                this.height = y-this.y  - this.iconAreaHeight - this.contentHeight - pad;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        this.height = Math.max(this.height,12+padding);\r\n        this.draw(canvasContext)\r\n    }\r\n\r\n\r\n    increaseWidthIfNecessary(canvasContext, possibleWidth) {\r\n        if (possibleWidth > this.width) {\r\n            this.width = possibleWidth;\r\n        }\r\n\r\n    }\r\n\r\n    hasContent() {\r\n        return !(this.content[0] === \"\" && this.content.length === 1)\r\n    }\r\n\r\n\r\n    draw(canvasContext) {\r\n\r\n        // Icon height in px\r\n        let iconHeight = 20;\r\n        let iconPadding = 2;\r\n        let iconListLen = this.icons[0].length;\r\n\r\n        // check for width increases\r\n        for (let i = 0; i < this.icons[0].length; i++) {\r\n\r\n            if (this.icons[1][i] === true) {\r\n                if (this.icons[2][i] === true) {\r\n                    this.increaseWidthIfNecessary(canvasContext, iconHeight + canvasContext.measureText(\"<< \" + this.icons[0][i] + \" >>\").width);\r\n                }\r\n            }else{\r\n                if (this.icons[2][i] === true) {\r\n                    this.increaseWidthIfNecessary(canvasContext, canvasContext.measureText(\"<< \" + this.icons[0][i] + \" >>\").width);\r\n                }\r\n            }\r\n        }\r\n        this.increaseWidthIfNecessary(canvasContext, canvasContext.measureText(this.title + this.Origin).width);\r\n\r\n        for (let i = 0; i < this.content.length; i++) {\r\n            this.increaseWidthIfNecessary(canvasContext, canvasContext.measureText(this.content[i]).width + padding*2);\r\n        }\r\n\r\n        // Font size\r\n        padding = 5;\r\n        // Set font settings\r\n        if(this.is)\r\n        canvasContext.font = this.fontSize+\"px Segoe UI\";\r\n        canvasContext.fontSize = this.fontSize;\r\n\r\n\r\n        // Find the maximum width of text and size the class accordingly\r\n        let measuredNameText = canvasContext.measureText(this.title + this.Origin).width;\r\n        let maxWidth = Math.max(measuredNameText + padding*2, this.width);\r\n        this.contentHeight = 0;\r\n\r\n        // Iterate over all content text lines\r\n        for (let i = 0; i < this.content.length; i++) {\r\n            let measuredText = canvasContext.measureText(this.content[i]);\r\n            maxWidth = Math.max(maxWidth, measuredText.width, measuredNameText);\r\n            this.contentHeight += this.fontSize+padding;\r\n        }\r\n\r\n        if(!this.hasContent()){\r\n            this.contentHeight = 0\r\n        }\r\n\r\n        if (maxWidth > this.width) {\r\n            this.width = maxWidth\r\n        }\r\n\r\n        // Configure drawing for shadows\r\n        // And generally make it look nice\r\n        canvasContext.shadowOffsetX = 2.0; canvasContext.shadowOffsetY = 2.0;\r\n        this.iconAreaHeight = (iconHeight + (iconPadding * 2)) * iconListLen;\r\n\r\n        // Update rect height\r\n        // Use this to force text to fit\r\n        if (this.content[0] !== \"\") {\r\n            this.realHeight = padding * 4 + this.height + this.iconAreaHeight + this.contentHeight;\r\n        }else{\r\n            this.realHeight = padding * 2 + this.height + this.iconAreaHeight\r\n        }\r\n\r\n        // Draw rect\r\n        \r\n        canvasContext.fillStyle = this.colour;\r\n        canvasContext.fillRect(this.x, this.y, this.width, this.realHeight);\r\n        canvasContext.strokeRect(this.x, this.y, this.width, this.realHeight);\r\n\r\n\r\n        if (this.content[0] !== \"\") {\r\n            canvasContext.strokeRect(this.x, this.y, this.width, this.height+this.iconAreaHeight+padding*2);\r\n        }\r\n\r\n        // Draw selected markers if rect is selected\r\n        if (this.selected) {\r\n            canvasContext.fillStyle = \"#000000\";\r\n            drawMarker(this.x, this.y);\r\n            drawMarker(this.x+this.width, this.y);\r\n            drawMarker(this.x, this.y+this.realHeight);\r\n            drawMarker(this.x+this.width, this.y+this.realHeight);\r\n        }\r\n\r\n        // Draw Icons by filename\r\n        let yPos = this.y + iconPadding;\r\n        let xPos = this.x + this.width + iconPadding;\r\n\r\n        function loadImage(imageElement) {\r\n            let sh = imageElement.height;\r\n            let sw = imageElement.width;\r\n            let scale = iconHeight / sh;\r\n            canvasContext.drawImage(imageElement, xPos-(iconPadding*2)-(sw*scale), yPos, sw * scale, sh * scale);\r\n            yPos += iconHeight + (iconPadding * 2); // What's the point of this line? yPos should be out of scope when this method is run\r\n\r\n        }\r\n\r\n       /* for (let i = 0; i < this.icons[0].length; i++) {\r\n\r\n            if (this.icons[1][i] === true) {\r\n                if (this.icons[2][i] === true) {\r\n                    this.increaseWidthIfNecessary(canvasContext, iconHeight + canvasContext.measureText(\"<< \" + this.icons[0][i] + \" >>\").width);\r\n                }\r\n\r\n                let element = this.imageElements[this.icons[0][i]];\r\n\r\n                \r\n                if (element === undefined) {\r\n\r\n                    let imageElement = new Image();\r\n                    imageElement.src = \"http://localhost:8080/icons/\" + this.icons[0][i];\r\n                    imageElement.crossOrigin = \"anonymous\";\r\n\r\n                    imageElement.onload = () => {\r\n                        loadImage(imageElement);\r\n                        this.imageElements[this.icons[0][i]] = imageElement\r\n                    };\r\n                } else {\r\n                    loadImage(element)\r\n                }\r\n            } else {\r\n                yPos += iconHeight + (iconPadding * 2);\r\n            }\r\n            \r\n        } */\r\n\r\n        // Reset color for text\r\n        canvasContext.fillStyle = \"#000000\";\r\n\r\n        // Draw Height for text that will be increased to draw downward\r\n        let dy = padding+this.fontSize;\r\n\r\n        // Disable shadows for text\r\n        canvasContext.shadowOffsetX = 0.0; canvasContext.shadowOffsetY = 0.0;\r\n\r\n        let txPos = this.x + iconPadding;\r\n        let tyPos = this.y + iconHeight;\r\n\r\n        for (let i = 0; i < this.icons[0].length; i++) {\r\n            if (this.icons[2][i] === true) {\r\n                if (this.icons[1][i] !== true) {\r\n                    this.increaseWidthIfNecessary(canvasContext, canvasContext.measureText(\"<< \" + this.icons[0][i] + \" >>\").width);\r\n                }\r\n\r\n                let name = \"<< \" + this.icons[0][i].slice(0, -4) + \" >>\";\r\n                if (this.icons[0][i].slice(-6, -4) === \"_n\") {\r\n                    name = \"\";\r\n                }\r\n\r\n                canvasContext.fillText(name, txPos, tyPos);\r\n            }\r\n            tyPos += iconHeight + (iconPadding * 2);\r\n        }\r\n\r\n        // Draw name\r\n        this.increaseWidthIfNecessary(canvasContext, canvasContext.measureText(this.Origin + this.title).width);\r\n\r\n        if(this.isAbstract) {\r\n            canvasContext.font = \"italic \" + this.fontSize + \"px Segoe UI\";\r\n        }else{\r\n            canvasContext.font = this.fontSize + \"px Segoe UI\";\r\n        }\r\n\r\n        canvasContext.fillText(this.Origin + this.title , this.x+padding, this.y+dy+this.iconAreaHeight);\r\n        dy = padding*2 +this.height + this.contentHeight;\r\n\r\n        canvasContext.font = this.fontSize+\"px Segoe UI\";\r\n\r\n        // Draw text\r\n        for (let i = 0; i < this.content.length; i++) {\r\n            this.increaseWidthIfNecessary(canvasContext, canvasContext.measureText(this.content[i]).width + padding*2);\r\n            canvasContext.fillText(this.content[i], this.x+padding, this.y+dy+this.iconAreaHeight);\r\n            dy += this.fontSize + padding;\r\n        }\r\n\r\n        canvasContext.strokeStyle = \"black\"\r\n    }\r\n\r\n    // Checks if it intersects with point\r\n    intersects(x, y) {\r\n        if (x < this.x) return false;\r\n        if (y < this.y) return false;\r\n        if (x > this.x+this.width) return false;\r\n        return y <= this.y + this.height;\r\n\r\n    }\r\n\r\n    // Gets the nearest side, in Arrow compatible x,y percentage values\r\n    // Also returns a threshold distance\r\n    // Parameters are the cursor X and Y coordinates\r\n    // Return value:\r\n    //      [threshold, xRel, yRel]\r\n    //\r\n    // If threshold is -1, xRel and yRel are equal to cursorX, cursorY\r\n    // This only happens when cursor shouldn't connect to vertex\r\n    getNearestSideFrom(cursorX, cursorY) {\r\n\r\n        // Else\r\n        return this.getNearestSide(cursorX, cursorY);\r\n    }\r\n\r\n    getNearestSide(cursorX, cursorY) {\r\n        // Create possibilities\r\n        let sides = [];\r\n\r\n        // If can connect to top/bottom\r\n        if (cursorX > this.x && cursorX < this.x+this.width) {\r\n            //console.log(\"success\");\r\n            let xPercentage = (cursorX-this.x)/this.width;\r\n\r\n            sides.push([Math.abs(cursorY-(this.y)), xPercentage, 0]);\r\n            sides.push([Math.abs(cursorY-(this.y+this.realHeight)), xPercentage, 1]);\r\n        }\r\n\r\n        // If can connect to left/right\r\n        else if (cursorY > this.y && cursorY < this.y+(this.realHeight)) {\r\n            //console.log(\"success\");\r\n            let yPercentage = (cursorY-this.y)/(this.realHeight);\r\n\r\n            sides.push([Math.abs(cursorX-(this.x)), 0, yPercentage]);\r\n            sides.push([Math.abs(cursorX-(this.x+this.width)), 1, yPercentage]);\r\n        }\r\n\r\n        // Can't connect\r\n\r\n        let goodSide = false;\r\n\r\n        sides.forEach((side) => {\r\n            if(side[0] < distanceThreshold){\r\n                goodSide = true;\r\n            }\r\n        });\r\n\r\n        if(goodSide === false && cursorX > this.x && cursorX < this.x + this.width && cursorY > this.y && cursorY < this.y+this.realHeight){\r\n                // click was inside the vertex but not in tolerance\r\n                //console.log(\"trying things\")\r\n                let yPercentage = (cursorY-this.y)/(this.realHeight);\r\n                let xPercentage = (cursorX-this.x)/this.width;\r\n\r\n                // find closest side\r\n                let rightDist = Math.abs(xPercentage-1)*this.width;\r\n                let topDist = yPercentage*this.realHeight;\r\n                let leftDist = xPercentage*this.width;\r\n                let bottomDist = yPercentage*this.realHeight;\r\n\r\n                let closestIndex = 0;\r\n                let closestDistance = leftDist;\r\n                let distArrays = [leftDist,rightDist,topDist,bottomDist];\r\n\r\n                // no need to go through leftDist here as its already set as shortest\r\n                for(let i = 1; i< distArrays.length-1; i++){\r\n                    if(distArrays[i] < closestDistance){\r\n                        closestDistance = distArrays[i];\r\n                        closestIndex = i;\r\n                    }\r\n                }\r\n\r\n                if ( closestIndex === 0 ){\r\n                    return [0, 0, yPercentage]\r\n                }\r\n                if ( closestIndex === 1 ){\r\n                    return [0, 1, yPercentage]\r\n                }\r\n                if ( closestIndex === 2 ){\r\n                    return [0, xPercentage, 0]\r\n                }\r\n                if ( closestIndex === 3 ){\r\n                    return [0, xPercentage, 1]\r\n                }\r\n        }\r\n\r\n        if(sides.length === 0){\r\n            return null\r\n        }\r\n\r\n        // Return side with shortest distance\r\n        let shortest = sides[0];\r\n        for (let i = 1; i < sides.length; i++) {\r\n            if (sides[i][0] < shortest[0]) {\r\n                shortest = sides[i];\r\n            }\r\n        }\r\n        return shortest;\r\n    }\r\n\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\n //EDGE ENDS\r\nexport const EdgeEnd = {\r\n    NONE: \"None\",\r\n    ARROW: \"Arrow\",\r\n    TRIANGLE: \"Triangle\",\r\n    FILLED_TRIANGLE: \"Filled Triangle\",\r\n    DIAMOND: \"Diamond\",\r\n    FILLED_DIAMOND: \"Filled Diamond\"\r\n};\r\n\r\nexport const EdgeEndToString = {};\r\nEdgeEndToString[EdgeEnd.NONE] = \"None\";\r\nEdgeEndToString[EdgeEnd.ARROW] = \"Arrow\";\r\nEdgeEndToString[EdgeEnd.TRIANGLE] = \"Triangle\";\r\nEdgeEndToString[EdgeEnd.FILLED_TRIANGLE] = \"FilledTriangle\";\r\nEdgeEndToString[EdgeEnd.DIAMOND] = \"Diamond\";\r\nEdgeEndToString[EdgeEnd.FILLED_DIAMOND] = \"FilledDiamond\";\r\n\r\nexport const StringToEdgeEnd = {};\r\nStringToEdgeEnd[\"None\"] = EdgeEnd.NONE;\r\nStringToEdgeEnd[\"Arrow\"] = EdgeEnd.ARROW;\r\nStringToEdgeEnd[\"Triangle\"] = EdgeEnd.TRIANGLE;\r\nStringToEdgeEnd[\"FilledTriangle\"] = EdgeEnd.FILLED_TRIANGLE;\r\nStringToEdgeEnd[\"Diamond\"] = EdgeEnd.DIAMOND;\r\nStringToEdgeEnd[\"FilledDiamond\"] = EdgeEnd.FILLED_DIAMOND;\r\n\r\n//LINE COLOURS\r\nexport const LineColour = {\r\n    BLACK: \"#000000\",\r\n    RED: \"#FF0000\",\r\n    BLUE: \"#0000FF\",\r\n    GREEN: \"#00FF00\"\r\n};\r\n\r\nexport const LineColourToStringName = {};\r\nLineColourToStringName[LineColour.BLACK] = \"Black\";\r\nLineColourToStringName[LineColour.RED] = \"Red\";\r\nLineColourToStringName[LineColour.BLUE] = \"Blue\";\r\nLineColourToStringName[LineColour.GREEN] = \"Green\";\r\n\r\nexport const StringNameToLineColour = {};\r\nStringNameToLineColour[\"Black\"] = LineColour.BLACK;\r\nStringNameToLineColour[\"Red\"] = LineColour.RED;\r\nStringNameToLineColour[\"Blue\"] = LineColour.BLUE;\r\nStringNameToLineColour[\"Green\"] = LineColour.GREEN;\r\n\r\n//LINE TYPES\r\nexport const LineType = {\r\n    SOLID: 1,\r\n    DASHED: 2\r\n};\r\n\r\nexport const LineTypeToString = {};\r\nLineTypeToString[LineType.SOLID] = \"Solid\";\r\nLineTypeToString[LineType.DASHED] = \"Dashed\";\r\n\r\nexport const StringToLineType = {};\r\nStringToLineType[\"Solid\"] = LineType.SOLID;\r\nStringToLineType[\"Dashed\"] = LineType.DASHED;","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport { SemanticIdentity } from \"./SemanticIdentity\";\r\n\r\nexport class Cardinality {\r\n    constructor(lowerBound, upperBound, attachedToUUID, isVisible = false, semanticIdentity) {\r\n        this.typeName = \"Cardinality\";\r\n        \r\n        this.numLowerBound = lowerBound;\r\n        this.numUpperBound = upperBound;\r\n        this.attachedToUUID = attachedToUUID;\r\n        this.isVisible = isVisible;\r\n\r\n        if (semanticIdentity !== undefined){\r\n            this.semanticIdentity = semanticIdentity;\r\n        } else {\r\n            this.semanticIdentity = new SemanticIdentity(this.toString(), this.getDescription())\r\n        }\r\n    }\r\n\r\n    set lowerBound(value){\r\n        this.numLowerBound = value;\r\n        this.semanticIdentity.name = this.toString();\r\n    }\r\n\r\n    get lowerBound(){\r\n        return this.numLowerBound;\r\n    }\r\n\r\n    set upperBound(value){\r\n        this.numUpperBound = value;\r\n        this.semanticIdentity.name = this.toString();\r\n    }\r\n\r\n    get upperBound(){\r\n        return this.numUpperBound;\r\n    }\r\n\r\n    toggleVisibility() {\r\n        this.isVisible = !this.isVisible;\r\n    }\r\n\r\n    toString() {\r\n        var lower;\r\n        var upper;\r\n\r\n        if (this.lowerBound === '-1') {\r\n            lower = 'n'\r\n        } else {\r\n            lower = this.lowerBound;\r\n        }\r\n\r\n        if (this.upperBound === '-1') {\r\n            upper = 'n'\r\n        } else {\r\n            upper = this.upperBound;\r\n        }\r\n\r\n        if (lower === upper) {\r\n            return lower;\r\n        } else {\r\n            return lower + \" .. \" + upper\r\n        }\r\n    }\r\n\r\n    getDescription(){\r\n        return `Cardinality of Edge End ${this.attachedToUUID}`;\r\n    }\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport { SemanticIdentity } from \"./SemanticIdentity\";\r\nimport { Cardinality } from \"./Cardinality\";\r\nimport * as ArrowProps from \"./ArrowProperties\";\r\nimport { getCurrentModel, getCurrentRenderKey } from \"../UIElements/CanvasDraw\";\r\n\r\n\r\n// Object that contains all the parts of an arrow ending including:\r\n// Head type\r\n// Cardinality\r\n// Label\r\n//\r\n// Used in the Arrow class\r\nexport class EdgeEnd {\r\n    constructor(attachedToUUID, headType = ArrowProps.EdgeEnd.NONE, cardinality, label = \"\", semanticIdentity) {\r\n        this.attachedToUUID = attachedToUUID;\r\n        this.typeName = \"EdgeEnd\";\r\n\r\n        if (semanticIdentity !== undefined){\r\n            this.semanticIdentity = semanticIdentity;\r\n        } else {\r\n            this.semanticIdentity = new SemanticIdentity(this.toString(), this.getDescription())\r\n        }\r\n        \r\n        this.headType = headType;\r\n        \r\n        if (cardinality !== undefined){\r\n            this.cardinality = cardinality;\r\n        } else {\r\n            this.cardinality = new Cardinality(1, 1, this.semanticIdentity.UUID);\r\n        }\r\n\r\n        this.label = label;\r\n\r\n        // For deciding where it goes in the graph\r\n        this.edgeEndRenderKey = getCurrentRenderKey();\r\n\r\n        // For rendering the object\r\n        this.edgeEndModelKey = getCurrentModel();\r\n    }\r\n\r\n    // Set the model key\r\n    setModelKey(key){\r\n        this.edgeEndModelKey = key;\r\n    }\r\n\r\n    // Return the model key\r\n    getModelKey(){\r\n        return this.edgeEndModelKey;\r\n    }\r\n\r\n    // Set the render key. Done in ContainmentTree.js\r\n    setRenderKey(key){\r\n        this.edgeEndRenderKey = key;\r\n    }\r\n\r\n    // Return the render key. Done in CanvasDraw.js\r\n    getRenderKey(key){\r\n        return this.edgeEndRenderKey;\r\n    }\r\n\r\n    set type(newType){\r\n        this.headType = newType;\r\n        this.semanticIdentity.name = this.toString();\r\n    }\r\n\r\n    get type(){\r\n        return this.headType;\r\n    }\r\n\r\n    toString(){\r\n        return `${this.type} type Edge End`;\r\n    }\r\n\r\n    getDescription(){\r\n        return `Edge end of ${this.attachedToUUID}`;\r\n    }\r\n\r\n    updateCardinality(lowerBound, upperBound, visibility){\r\n        this.cardinality.lowerBound = lowerBound;\r\n        this.cardinality.upperBound = upperBound;\r\n        this.cardinality.visibility = visibility;\r\n    }\r\n\r\n    drawLines(canvasContext, points, strokeColour, fillColour) {\r\n        canvasContext.strokeStyle = strokeColour;\r\n        if (fillColour !== undefined) {\r\n            canvasContext.fillStyle = fillColour;\r\n        }\r\n\r\n        canvasContext.beginPath();\r\n        canvasContext.moveTo(points[0].X, points[0].Y);\r\n        for (let i = 1; i < points.length; i++) {\r\n            canvasContext.lineTo(points[i].X, points[i].Y)\r\n        }\r\n        \r\n        if (fillColour !== undefined) {\r\n            canvasContext.closePath();\r\n            canvasContext.fill();\r\n        }\r\n        canvasContext.stroke();\r\n\r\n        canvasContext.fillStyle = \"#000\"\r\n        canvasContext.strokeStyle = \"#000\";\r\n    }\r\n\r\n    drawArrowEnd(canvasContext, x, y, angle, lineColour) {\r\n        //Constants\r\n        const strokeLength = 7;\r\n        const angleFromLine = Math.PI/6;\r\n        const angleInverted = angle + Math.PI;\r\n\r\n        //Generate points for the arrowhead\r\n        var arrowPoints = [];\r\n        arrowPoints.push({\r\n            X: x + strokeLength * Math.cos(angleInverted - angleFromLine),\r\n            Y: y + strokeLength * Math.sin(angleInverted - angleFromLine)\r\n        });\r\n        arrowPoints.push({\r\n            X: x,\r\n            Y: y\r\n        });\r\n        arrowPoints.push({\r\n            X: x + strokeLength * Math.cos(angleInverted + angleFromLine),\r\n            Y: y + strokeLength * Math.sin(angleInverted + angleFromLine)\r\n        });\r\n\r\n        //Arrowhead drawing\r\n        this.drawLines(canvasContext, arrowPoints, lineColour)\r\n    }\r\n\r\n    drawTriangleEnd(canvasContext, x, y, angle, lineColour, fillColour = \"#FFF\") {\r\n        //Constants\r\n        const sideLength = 7;\r\n        const deg30 = Math.PI / 6;\r\n        const angleInverted = angle + Math.PI;\r\n\r\n        //Generate points for the triangle\r\n        var trianglePoints = [];\r\n        trianglePoints.push({\r\n            X: x,\r\n            Y: y\r\n        });\r\n        trianglePoints.push({\r\n            X: x + sideLength * Math.cos(angleInverted - deg30),\r\n            Y: y + sideLength * Math.sin(angleInverted - deg30)\r\n        });\r\n        trianglePoints.push({\r\n            X: x + sideLength * Math.cos(angleInverted + deg30),\r\n            Y: y + sideLength * Math.sin(angleInverted + deg30)\r\n        });\r\n        trianglePoints.push({\r\n            X: x,\r\n            Y: y\r\n        });\r\n\r\n        //Triangle drawing\r\n        this.drawLines(canvasContext, trianglePoints, lineColour, fillColour);\r\n    }\r\n\r\n    drawDiamondEnd(canvasContext, x, y, angle, lineColour, fillColour = \"#FFF\") {\r\n        //Constants\r\n        const sideLength = 7;\r\n        const deg20 = Math.PI / 9;\r\n        const angleInverted = angle + Math.PI;\r\n\r\n        //Generate points for the diamond\r\n        var diamondPoints = [];\r\n        diamondPoints.push({\r\n            X: x,\r\n            Y: y\r\n        });\r\n        diamondPoints.push({\r\n            X: x + sideLength * Math.cos(angleInverted - deg20),\r\n            Y: y + sideLength * Math.sin(angleInverted - deg20)\r\n        });\r\n        diamondPoints.push({\r\n            X: x + sideLength * 2 * Math.cos(angleInverted),\r\n            Y: y + sideLength * 2 * Math.sin(angleInverted)\r\n        });\r\n        diamondPoints.push({\r\n            X: x + sideLength * Math.cos(angleInverted + deg20),\r\n            Y: y + sideLength * Math.sin(angleInverted + deg20)\r\n        });\r\n        diamondPoints.push({\r\n            X: x,\r\n            Y: y\r\n        });\r\n\r\n        //Diamond drawing\r\n        this.drawLines(canvasContext, diamondPoints, lineColour, fillColour);\r\n    }\r\n\r\n    draw(canvasContext, x, y, angle, lineColour){\r\n        switch (this.type) {\r\n            case ArrowProps.EdgeEnd.NONE:\r\n                break;\r\n            case ArrowProps.EdgeEnd.ARROW:\r\n                this.drawArrowEnd(canvasContext, x, y, angle, lineColour);\r\n                break;\r\n            case ArrowProps.EdgeEnd.TRIANGLE:\r\n                this.drawTriangleEnd(canvasContext, x, y, angle, lineColour);\r\n                break;\r\n            case ArrowProps.EdgeEnd.FILLED_TRIANGLE:\r\n                this.drawTriangleEnd(canvasContext, x, y, angle, lineColour, lineColour);\r\n                break;\r\n            case ArrowProps.EdgeEnd.DIAMOND:\r\n                this.drawDiamondEnd(canvasContext, x, y, angle, lineColour);\r\n                break;\r\n            case ArrowProps.EdgeEnd.FILLED_DIAMOND:\r\n                this.drawDiamondEnd(canvasContext, x, y, angle, lineColour, lineColour);\r\n                break;\r\n            default:\r\n                console.log(\"EdgeEnd had unexpected type: %s\", this.type);\r\n        }\r\n    }\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport React from 'react';\r\nimport * as canvasDraw from \"./CanvasDraw\";\r\nimport {LineColourToStringName, LineTypeToString} from \"../DataStructures/ArrowProperties\"\r\nimport { ContainmentTree, handleAddVertex, handleDeleteVertex } from \"./ContainmentTree\";\r\n\r\nimport { SketchPicker } from 'react-color';\r\n\r\n// Icons\r\nimport iconVertex from \"../Resources/vertex.svg\";\r\nimport iconEdge from \"../Resources/edge.svg\";\r\nimport iconSpecialisation from \"../Resources/specialisation.svg\";\r\nimport iconVisibility from \"../Resources/visibility.svg\"\r\nimport iconSelect from \"../Resources/select.svg\"\r\nimport iconArtifact from \"../Resources/artifact.svg\"\r\nimport iconContainer from \"../Resources/container.svg\"\r\n\r\n\r\nimport {deleteElement, currentObjects} from \"./CanvasDraw\";\r\nimport { vertexDeleteElement } from './CanvasDraw';\r\nimport DropdownButton from \"react-bootstrap/DropdownButton\";\r\nimport {vertexData} from \"./ContainmentTree.js\"\r\n\r\n// Show the vertex path\r\nimport {showVertexPath} from \"./ContainmentTree.js\";\r\n\r\n// The variable that contains the found path of a given vertex\r\nimport { someVertexPath } from './ContainmentTree';\r\nimport e from 'cors';\r\n\r\n//Property Enums\r\nexport const LeftMenuType = {\r\n    TreeView: \"TreeView\",\r\n    Vertex: \"Vertex\",\r\n    Arrow: \"Arrow\",\r\n\r\n    //FTreeView: \"FocussedTreeView\"\r\n\r\n    Artifact: \"Artifact\",\r\n    Container:\"Container\"\r\n\r\n};\r\n\r\nexport const LeftMenuTypeToString = {};\r\nLeftMenuTypeToString[LeftMenuType.TreeView] = \"TreeView\";\r\nLeftMenuTypeToString[LeftMenuType.Vertex] = \"Vertex\";\r\nLeftMenuTypeToString[LeftMenuType.Arrow] = \"Arrow\";\r\nLeftMenuTypeToString[LeftMenuType.Arrow] = \"Artifact\";\r\nLeftMenuTypeToString[LeftMenuType.Arrow] = \"Container\";\r\n\r\nexport const StringToLeftMenuType = {};\r\nLeftMenuTypeToString[\"TreeView\"] = LeftMenuType.TreeView;\r\nLeftMenuTypeToString[\"Vertex\"] = LeftMenuType.Vertex;\r\nLeftMenuTypeToString[\"Arrow\"] = LeftMenuType.Arrow;\r\nLeftMenuTypeToString[\"Artifact\"] = LeftMenuType.Artifact;\r\nLeftMenuTypeToString[\"Container\"] = LeftMenuType.Container;\r\n\r\nexport const Tool = {\r\n    Select: \"Select\",\r\n    Vertex: \"Vertex\",\r\n    Visibility: \"Visibility\",\r\n    Edge: \"Edge\",\r\n    Specialisation: \"Specialisation\",\r\n    Artifact: \"Artifact\",\r\n    Container: \"Container\",\r\n};\r\n\r\n// class to display the left hand menu, where we will be showing\r\n// object editing tools for now\r\nexport class LeftMenu extends React.Component{\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            menu: LeftMenuType.TreeView,\r\n            selectedObject: null,\r\n            fileNames: [],\r\n            title: \"\",\r\n            content: [],\r\n\r\n        };\r\n        this.setTitle = this.setTitle.bind(this);\r\n        this.setContent = this.setContent.bind(this);\r\n        this.handleChange = this.handleChange.bind(this);\r\n\r\n        this.formRef = null;\r\n\r\n        this.setFormRef = element =>{\r\n            this.formRef = element;\r\n        };\r\n\r\n        //this.setIcons();\r\n\r\n    }\r\n    handleChange(event){\r\n        this.setState({title: event.target.value})\r\n        this.setState({title:\"\"})\r\n        this.setTitle();\r\n        this.setContent();\r\n    }\r\n    /*\r\n    leftMenuContents = <form id = \"VertexMenu\">\r\n                <div className=\"LeftHeader\">Vertex Properties</div>\r\n                <label className=\"LeftLabel\">Title</label>\r\n                <input id=\"LeftTitle\" className=\"LeftTitle\" defaultValue={this.state.selectedObject.title} onKeyUp={() => this.setTitle()}/>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n    \r\n                */\r\n               \r\n    /// This is a test function, remove it if I forget to\r\n    testUpdateLabel = () =>{\r\n        this.setPath(\"fffffffff\")\r\n        //document.getElementById(\"VertPath\").value = \"It doth been updated\";\r\n        \r\n        //console.log(\"RIGHT HERE \" + document.getElementById(\"VertPath\").value)\r\n    }\r\n\r\n\r\n\r\n    /// \r\n\r\n    componentDidMount() {\r\n        this.menu = this.props.mainState.menu;\r\n        this.selectedItem = this.props.mainState.drawMode;\r\n        this.props.setMode(this.selectedItem)\r\n\r\n        document.addEventListener(\"keydown\", this.onKeyPressed.bind(this));\r\n        \r\n    }\r\n\r\n\r\n    //For quickKeys\r\n\r\n\r\n    onKeyPressed(e) {\r\n        if (e.keyCode === 86 && this.state.selectedObject === null){\r\n            this.props.setMode(Tool.Vertex);\r\n        }\r\n\r\n\r\n        if (e.keyCode === 69 && this.state.selectedObject === null){\r\n            this.props.setMode(Tool.Edge);\r\n        }\r\n\r\n        if (e.keyCode === 46){\r\n            console.log(this.state.selectedObject);\r\n            if(this.state.selectedObject.typeName === \"Vertex\"){\r\n                vertexDeleteElement(this.state.selectedObject);\r\n            }\r\n            else{\r\n                deleteElement(this.state.selectedObject);\r\n            }\r\n            this.setState({menu:\"TreeView\"});\r\n            canvasDraw.drawAll();\r\n        }\r\n\r\n        \r\n    }\r\n    \r\n    componentWillReceiveProps(nextProps,nextContext) {\r\n        this.setState({menu:nextProps.mainState.menu,selectedObject:nextProps.mainState.selectedObject});\r\n        \r\n        //document.removeEventListener(\"keydown\", this.onKeyPressed.bind(this));\r\n\r\n    }\r\n    \r\n\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n\r\n        let leftMenu = document.getElementById(\"VertexMenu\");\r\n        if(leftMenu === null){\r\n            leftMenu = document.getElementById(\"ArrowMenu\");\r\n        }\r\n        if(leftMenu !== null){\r\n            leftMenu.addEventListener(\"keypress\", (e) => {\r\n                if(e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                }\r\n            })\r\n        }\r\n\r\n    }\r\n\r\n    setIcons() {\r\n        fetch('http://localhost:8080/icons/list',{\r\n            method:'GET',\r\n            headers: {\r\n                'Accept': '*/*',\r\n            },\r\n        })\r\n            .then((res) => {return res.json()})\r\n            .then((data) => {\r\n                let fileNames = [];\r\n                data.icons.forEach((icon) => {\r\n                    fileNames.push(icon)\r\n                });\r\n                this.setState({fileNames:fileNames})\r\n            })\r\n    }\r\n\r\n    //VERTEX SETTERS\r\n\r\n    \r\n    setTitle() {\r\n        let newTitle = document.getElementById(\"LeftTitle\").value;\r\n        this.state.selectedObject.setTitle(newTitle);\r\n        canvasDraw.updateVertex(this.state.selectedObject);\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n\r\n    setContent() {\r\n        let newContent = document.getElementById(\"LeftContent\").value;\r\n        newContent = newContent.split(\"\\n\");\r\n        this.state.selectedObject.setContent(newContent);\r\n        canvasDraw.updateVertex(this.state.selectedObject);\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n    //ARROW SETTERS\r\n    setLineType() {\r\n        let newLineType = document.getElementById(\"LineType\").value;\r\n        this.state.selectedObject.setLineType(newLineType);\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n    setColour() {\r\n        let newColour = document.getElementById(\"LineColour\").value;\r\n        this.state.selectedObject.setLineColour(newColour);\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n    setStartLabel() {\r\n        let newLabel = document.getElementById(\"SourceLabel\").value;\r\n        this.state.selectedObject.setStartLabel(newLabel);\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    setEndLabel() {\r\n        let newLabel = document.getElementById(\"DestLabel\").value;\r\n        this.state.selectedObject.setEndLabel(newLabel);\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    updateCardinality() {\r\n        let sourceLowerBound = document.getElementById(\"sourceFromCardindality\").value;\r\n        let sourceUpperBound = document.getElementById(\"sourceToCardindality\").value;\r\n        let currentSourceVisibility = this.state.selectedObject.getSourceCardinalityVisibility();\r\n        let destLowerBound = document.getElementById(\"destFromCardindality\").value;\r\n        let destUpperBound = document.getElementById(\"destToCardindality\").value;\r\n        let currentDestVisibility = this.state.selectedObject.getDestCardinalityVisibility();\r\n\r\n        this.state.selectedObject.updateSourceCardinality(sourceLowerBound, sourceUpperBound, currentSourceVisibility);\r\n        this.state.selectedObject.updateDestCardinality(destLowerBound, destUpperBound, currentDestVisibility);\r\n\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    toggleSourceCardinalityVisibility() {\r\n        this.state.selectedObject.toggleSourceCardinalityVisibility();\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    toggleDestCardinalityVisibility() {\r\n        this.state.selectedObject.toggleDestCardinalityVisibility();\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    toggleAbstract(){\r\n        this.state.selectedObject.toggleAbstract()\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n    getS23MIconsSelector() {\r\n        let dropdownOptions = [<div className=\"DropdownItem\"><div className=\"dropdownLabel\">Name</div><div className=\"checkBoxContainer\">Text</div><div className=\"checkBoxContainer\">Icon</div></div>];\r\n\r\n        let name = \"\";\r\n        this.state.fileNames.forEach(fileName => {\r\n            if (fileName.slice(-6, -4) === \"_n\") {\r\n                name = fileName.slice(0, -6);\r\n                dropdownOptions.push(<div className=\"DropdownItem\" ref={fileName}> <div className=\"dropdownLabel\">{name}</div> <div className=\"checkBoxContainer\"><input type='checkbox' disabled=\"disabled\" /> </div>  <div className=\"checkBoxContainer\"><input type='checkbox' defaultChecked={this.shouldIconBeSelected(fileName)} onClick={() => {this.setIcon(fileName)}}/></div> </div>)\r\n            } else {\r\n                name = fileName.slice(0, -4);\r\n                dropdownOptions.push(<div className=\"DropdownItem\" ref={fileName}> <div className=\"dropdownLabel\">{name}</div> <div className=\"checkBoxContainer\"><input type='checkbox' defaultChecked={this.shouldTextBeSelected(fileName)} onClick={() => {this.setText(fileName)}} /> </div>  <div className=\"checkBoxContainer\"><input type='checkbox' defaultChecked={this.shouldIconBeSelected(fileName)} onClick={() => {this.setIcon(fileName)}}/></div> </div>)\r\n            }\r\n        });\r\n\r\n        return <DropdownButton title=\"Category Selector\" name=\"Icons\" id=\"IconSelector\" className=\"IconSelector\">\r\n            {dropdownOptions}\r\n        </DropdownButton>;\r\n    }\r\n\r\n    getVertexColour = () => {\r\n        return this.state.selectedObject.getColour()\r\n    };\r\n\r\n    setVertexColour = (colour) =>{\r\n        this.state.selectedObject.setColour(colour.hex);\r\n        canvasDraw.updateVertex(this.state.selectedObject);\r\n        canvasDraw.drawAll()\r\n    };\r\n\r\n    getColourPicker() {\r\n        return <DropdownButton title = \"Colour Selector\" id = \"ColourSelector\">\r\n        <SketchPicker\r\n            color={this.getVertexColour}\r\n            onChangeComplete={this.setVertexColour}\r\n            presetColors = {[\"#FFD5A9\",\"#F5B942\",\"#FFFFFF\"]}\r\n        /></DropdownButton>\r\n    }\r\n\r\n    shouldTextBeSelected(fileName) {\r\n        return this.state.selectedObject.isTextSet(fileName)\r\n    }\r\n\r\n    shouldIconBeSelected(fileName) {\r\n        return this.state.selectedObject.isIconSet(fileName)\r\n    }\r\n\r\n    setText(fileName) {\r\n        this.state.selectedObject.setText(fileName);\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    setIcon(fileName) {\r\n        this.state.selectedObject.setIcon(fileName);\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    setNavigable(side){\r\n\r\n        this.state.selectedObject.toggleNavigable(side);\r\n\r\n        document.getElementById(\"SourceIsNavigable\").checked = this.state.selectedObject.getNavigable(0);\r\n        document.getElementById(\"DestIsNavigable\").checked = this.state.selectedObject.getNavigable(1);\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n    setAggregation(side){\r\n        if(!this.state.selectedObject.getNavigable(side)){\r\n            this.state.selectedObject.toggleNavigable(side);\r\n        }\r\n        this.state.selectedObject.toggleAggregation(side);\r\n        let SourceAggregation = this.state.selectedObject.getAggregation(0);\r\n        let DestAggregation = this.state.selectedObject.getAggregation(1);\r\n        if(SourceAggregation) {\r\n            document.getElementById(\"SourceIsNavigable\").checked = true;\r\n        }\r\n        if(DestAggregation){\r\n            document.getElementById(\"DestIsNavigable\").checked = true;\r\n        }\r\n        document.getElementById(\"SourceIsAggregation\").checked = SourceAggregation;\r\n        document.getElementById(\"DestIsAggregation\").checked = DestAggregation;\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n    deselectElement(){\r\n        this.props.setLeftMenu(null);\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    showTreeView(){\r\n        //this.state.menu = LeftMenuType.TreeView;\r\n        //console.log(\"HENLO: \" + this.state);\r\n        //leftMenuContents = <ContainmentTree setLeftMenu = {this.props.setLeftMenu} />;\r\n        this.state.selectedObject(null)\r\n        canvasDraw.drawAll();\r\n    }\r\n\r\n    stripElement(e){\r\n        e.preventDefault()\r\n        this.state.selectedObject.trimPath();\r\n        canvasDraw.drawAll()\r\n    }\r\n\r\n   \r\n    deleteTitle = () => {\r\n        this.setState({title: \"\"})\r\n    };\r\n   \r\n\r\n// return the correct menu based on the selected item\r\n    getMenu = () =>{\r\n\r\n        \r\n\r\n        let leftMenuContents;\r\n\r\n        let toolbar = <div id = \"Toolbar\" className = \"Toolbar\">\r\n            <div id = \"Select\" className=\"ToolbarItem\" onClick={() => this.props.setMode(Tool.Select)}><img src={iconSelect} alt =\"Select\"/></div>\r\n\r\n            <div id = \"Vertex\" className=\"ToolbarItem\" onClick={() => {this.props.setMode(Tool.Vertex); }} onKeyDown={() => this.onKeyPressed()}    ><img src={iconVertex} alt =\"Vertex\"/></div>\r\n\r\n            <div id=\"Artifact\" className=\"ToolbarItem\" onClick={() => this.props.setMode(Tool.Artifact)} onKeyDown={() => this.onKeyPressed()}    ><img src={iconArtifact} alt=\"Artifact\" /></div>\r\n            <div id=\"Container\" className=\"ToolbarItem\" onClick={() => this.props.setMode(Tool.Container)} onKeyDown={() => this.onKeyPressed()}    ><img src={iconContainer} alt=\"Container\" /></div>\r\n\r\n            <div id = \"Edge\" className=\"ToolbarItem\" onClick={() => this.props.setMode(Tool.Edge)}><img src={iconEdge} alt =\"Edge\"/></div>\r\n            <div id = \"Specialisation\" className=\"ToolbarItem\" onClick={() => this.props.setMode(Tool.Specialisation)}><img src={iconSpecialisation} alt =\"Specialisation\"/></div>\r\n            <div id = \"Visibility\" className=\"ToolbarItem\" onClick={() => this.props.setMode(Tool.Visibility)}><img src={iconVisibility} alt =\"Visibility\"/></div>\r\n        </div>;\r\n\r\n        if (this.state.menu === LeftMenuType.TreeView) {\r\n            leftMenuContents = <ContainmentTree setLeftMenu = {this.props.setLeftMenu} />\r\n            //console.log(\"A new tree has been created\");\r\n\r\n        } else if (this.state.menu === LeftMenuType.Vertex) {\r\n            canvasDraw.drawAll();\r\n            \r\n            leftMenuContents = <form id = \"VertexMenu\">\r\n                <div className=\"LeftHeader\">Vertex Properties</div>\r\n                <label className=\"LeftLabel\">Title</label>\r\n                <input id=\"LeftTitle\" className=\"LeftTitle\" value={this.state.selectedObject.title} onInput={this.handleChange}/>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Content</label>\r\n                <textarea id=\"LeftContent\" className =\"LeftContent\" value={this.state.selectedObject.getContentAsString()} onInput={this.handleChange}/>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                {this.getS23MIconsSelector()}\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                {this.getColourPicker()}\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Is Abstract?</label>\r\n                <input type=\"checkbox\" id=\"IsAbstract\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getAbstract()} onClick={() => this.toggleAbstract()}/>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <button className=\"LeftMenuButton\" onClick={() => this.deselectElement()}>Deselect</button>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={() => {/*deleteElement(this.state.selectedObject)*/vertexDeleteElement(this.state.selectedObject);this.setState({menu:\"TreeView\"})}} placeholder=\"NoTabIndex\">Remove</button>\r\n\r\n\r\n\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                \r\n    \r\n                <input id=\"VertPath\" className=\"vertexPath\" defaultValue={this.state.selectedObject.vertexPath}/>\r\n                \r\n\r\n\r\n            </form>;\r\n            \r\n        } else if (this.state.menu === LeftMenuType.Artifact) {\r\n            canvasDraw.drawAll();\r\n\r\n            leftMenuContents = <form id=\"VertexMenu\">\r\n                <div className=\"LeftHeader\">Vertex Properties</div>\r\n                <label className=\"LeftLabel\">Title</label>\r\n                <input id=\"LeftTitle\" className=\"LeftTitle\" defaultValue={this.state.selectedObject.title} onKeyUp={() => this.setTitle()} />\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Content</label>\r\n                <textarea id=\"LeftContent\" className=\"LeftContent\" defaultValue={this.state.selectedObject.getContentAsString()} onKeyUp={() => this.setContent()} />\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                {this.getS23MIconsSelector()}\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                {this.getColourPicker()}\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Is Abstract?</label>\r\n                <input type=\"checkbox\" id=\"IsAbstract\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getAbstract()} onClick={() => this.toggleAbstract()} />\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <button className=\"LeftMenuButton\" onClick={() => this.deselectElement()}>Deselect</button>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={() => { deleteElement(this.state.selectedObject); this.setState({ menu: \"TreeView\" }) }} placeholder=\"NoTabIndex\">Remove</button>\r\n            </form>;\r\n\r\n        } else if (this.state.menu === LeftMenuType.Container) {\r\n            canvasDraw.drawAll();\r\n            leftMenuContents = <form id=\"VertexMenu\">\r\n                <div className=\"LeftHeader\">Vertex Properties</div>\r\n                <label className=\"LeftLabel\">Title</label>\r\n                <input id=\"LeftTitle\" className=\"LeftTitle\" defaultValue={this.state.selectedObject.title} onKeyUp={() => this.setTitle()} />\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Content</label>\r\n                <textarea id=\"LeftContent\" className=\"LeftContent\" defaultValue={this.state.selectedObject.getContentAsString()} onKeyUp={() => this.setContent()} />\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                {this.getS23MIconsSelector()}\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Is Abstract?</label>\r\n                <input type=\"checkbox\" id=\"IsAbstract\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getAbstract()} onClick={() => this.toggleAbstract()} />\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <button className=\"LeftMenuButton\" onClick={() => this.deselectElement()}>Deselect</button>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={() => { deleteElement(this.state.selectedObject); this.setState({ menu: \"TreeView\" }) }} placeholder=\"NoTabIndex\">Remove</button>\r\n            </form>;\r\n\r\n        }else if (this.state.menu === LeftMenuType.Arrow) {\r\n            console.log(\"Arrow Selected\");\r\n            console.log(this.state.selectedObject)\r\n\r\n            if(this.state.selectedObject.edgeType === Tool.Edge){\r\n\r\n            leftMenuContents = <form id = \"ArrowMenu\">\r\n                <div className=\"LeftHeader\">Edge Properties</div>\r\n\r\n                <label className=\"LeftLabel\">Source Is Navigable?</label>\r\n                <input type=\"checkbox\" id=\"SourceIsNavigable\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getNavigable(0)} onClick={() => this.setNavigable(0)}/>\r\n\r\n                <label className=\"LeftLabel\">Destination Is Navigable?</label>\r\n                <input type=\"checkbox\" id=\"DestIsNavigable\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getNavigable(1)} onClick={() => this.setNavigable(1)}/>\r\n\r\n                <label className=\"LeftLabel\">Source Is Aggregation?</label>\r\n                <input type=\"checkbox\" id=\"SourceIsAggregation\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getAggregation(0)} onClick={() => this.setAggregation(0)}/>\r\n\r\n                <label className=\"LeftLabel\">Destination Is Aggregation?</label>\r\n                <input type=\"checkbox\" id=\"DestIsAggregation\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getAggregation(1)} onClick={() => this.setAggregation(1)}/>\r\n\r\n                <label className=\"LeftLabel\">Line Colour</label>\r\n                <select name=\"LineColour\" id=\"LineColour\" className=\"LeftSelector\" defaultValue={LineColourToStringName[this.state.selectedObject.lineColour]} onChange={() => this.setColour()}>\r\n                    <option value = \"Black\">Black</option>\r\n                    <option value = \"Red\">Red</option>\r\n                    <option value = \"Blue\">Blue</option>\r\n                    <option value = \"Green\">Green</option>\r\n                </select>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                {/* -1 represents n or *  */}\r\n                <label className=\"LeftLabel\">Source Cardinality</label>\r\n                <div className=\"CardinalityArea\"> <div className=\"LeftCheckboxLabel\"> Visible: </div> <input type=\"checkbox\" id = \"sourceCardinalityShown\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getSourceCardinalityVisibility()} onChange={() => {this.toggleSourceCardinalityVisibility();canvasDraw.drawAll()}}/>\r\n                    <input type=\"number\" id = \"sourceFromCardindality\" className=\"CardinalityBox\" defaultValue={this.state.selectedObject.getSourceCardinalityLowerBound()} min=\"0\" max=\"25\" onChange={() => this.updateCardinality()}/>\r\n                    <label>..</label>\r\n                    <input type=\"number\" id = \"sourceToCardindality\" className=\"CardinalityBox\" defaultValue={this.state.selectedObject.getSourceCardinalityUpperBound()} min=\"-1\" max=\"25\" onChange={() => this.updateCardinality()}/>\r\n                </div>\r\n\r\n\r\n                <label className=\"LeftLabel\">Destination Cardinality</label>\r\n                <div className=\"CardinalityArea\"> <div className=\"LeftCheckboxLabel\">Visible:</div> <input type=\"checkbox\" id = \"destCardinalityShown\" className=\"LeftCheckbox\" defaultChecked={this.state.selectedObject.getDestCardinalityVisibility()} onChange={() => {this.toggleDestCardinalityVisibility();canvasDraw.drawAll()}}/>\r\n                    <input type=\"number\" id = \"destFromCardindality\" className=\"CardinalityBox\" defaultValue={this.state.selectedObject.getDestCardinalityLowerBound()} min=\"0\" max=\"25\" onChange={() => this.updateCardinality()}/>\r\n                    <label>..</label>\r\n                    <input type=\"number\" id = \"destToCardindality\" className=\"CardinalityBox\" defaultValue={this.state.selectedObject.getDestCardinalityUpperBound()} min=\"-1\" max=\"25\" onChange={() => this.updateCardinality()}/>\r\n                </div>\r\n\r\n                <label className=\"LeftLabel\">Source Label</label>\r\n                    <input id=\"SourceLabel\" className=\"LeftTitle\" defaultValue={this.state.selectedObject.sourceEdgeEnd.label} onKeyUp={() => this.setStartLabel()}/>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n\r\n                <label className=\"LeftLabel\">Destination Label</label>\r\n                    <input id=\"DestLabel\" className=\"LeftTitle\" defaultValue={this.state.selectedObject.destEdgeEnd.label} onKeyUp={() => this.setEndLabel()}/>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={() => { deleteElement(this.state.selectedObject); this.setState({ menu: LeftMenuType.TreeView, selectedObject: null }) }}>Remove</button>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={(e) => this.stripElement(e)}>Make Straight</button>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={() => this.deselectElement()}>Deselect</button>\r\n                <label className=\"LeftSpacer\">&nbsp;</label>\r\n                <button className=\"LeftMenuButton\" onClick={() => {deleteElement(this.state.selectedObject);this.setState({menu:LeftMenuType.TreeView,selectedObject:null})}}>Remove</button>\r\n\r\n            </form>\r\n            }else{\r\n                leftMenuContents = <form id = \"ArrowMenu\">\r\n                    <div className=\"LeftHeader\">Selected Edge</div>\r\n                    <button className=\"LeftMenuButton\" onClick={() => this.deselectElement()}>Deselect</button>\r\n                    <label className=\"LeftSpacer\">&nbsp;</label>\r\n                    <button className=\"LeftMenuButton\" onClick={() => {deleteElement(this.state.selectedObject);this.setState({menu:LeftMenuType.TreeView,selectedObject:null})}}>Remove</button>\r\n\r\n                    \r\n\r\n                    </form>\r\n            }\r\n        }\r\n\r\n        return <div>{toolbar}<form ref={this.setFormRef} className={this.props.className}>\r\n            {leftMenuContents}\r\n            </form></div>;\r\n        \r\n    };\r\n\r\n    render() {\r\n        let menu = this.getMenu();\r\n        if (this.formRef !== null) {\r\n            this.formRef.reset();\r\n        }\r\n        return menu;\r\n    }\r\n\r\n\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport { Vertex } from \"../DataStructures/Vertex\";\r\nimport { Arrow } from \"../DataStructures/Arrow\";\r\nimport { Tool } from \"./LeftMenu\";\r\nimport { Graph } from \"../DataStructures/Graph\";\r\nimport {getFolderNameFromKey, getModelData,handleAddModel, vertexData} from \"./ContainmentTree\";\r\nimport { rgbToHex } from \"@material-ui/core\";\r\n\r\n\r\n// Core variables\r\nlet canvasElement;\r\nlet canvasContext;\r\n\r\n// Mouse / Cursor\r\nlet mouseStartX;\r\nlet mouseStartY;\r\n\r\nlet previousObject;\r\nlet startX, startY, endX, endY;\r\n\r\nlet yRows = 70;\r\n\r\nexport var mouseOriginX;\r\nexport var mouseOriginY;\r\n\r\n// Non zoomed in Width/Height (in pixels)\r\nlet canvasWidth;\r\nlet canvasHeight;\r\n\r\n// Zoom and Pan\r\nlet zoom = 200.0;\r\n\r\n// Renderable objects\r\nexport var currentObjects = new Graph();\r\n\r\nexport var savedArrows = [];\r\n\r\n// The naming conventions here are terrible, but basically the render keys determine where\r\n// a tree view element is placed in the graph while the model functions determine what's \r\n// actually being rendered\r\n\r\nexport let currentRenderKey = 0;\r\nexport let totalRenderKeys = 0\r\n\r\nexport let currentModel = 0;\r\nexport let totalModels = 0;\r\n\r\nexport function setTotalRenderKey(newData){\r\n    totalRenderKeys = newData;\r\n}\r\nexport function setTotalModelKeys(newData){\r\n    totalModels = newData;\r\n}\r\n\r\nexport function getCurrentRenderKey() {\r\n    return currentRenderKey;\r\n}\r\n\r\nexport function setNewRenderKey(newKey) {\r\n    currentRenderKey = newKey;\r\n}\r\n\r\nexport function getTotalRenderKeys() {\r\n    return totalRenderKeys;\r\n}\r\n\r\nexport function incrementTotalRenderKeys() {\r\n    totalRenderKeys = totalRenderKeys += 1;\r\n}\r\n\r\nexport function getCurrentObjects() {\r\n    return currentObjects;\r\n}\r\n\r\n// --- Model Key Stuff --- //\r\n\r\nexport function getCurrentModel() {\r\n    return currentModel;\r\n}\r\n\r\nexport function setNewModel(newModel) {\r\n    currentModel = newModel;\r\n}\r\n\r\nexport function getTotalModels() {\r\n    return totalModels;\r\n}\r\n\r\nexport function incrementTotalModels() {\r\n    totalModels = totalModels += 1;\r\n}\r\n\r\n\r\n\r\n\r\n// Arrow Path\r\nexport var arrowPath = [];\r\nlet lastX = 0;\r\nlet lastY = 0;\r\n\r\n// Arrow moving\r\nlet startMoveX = 0;\r\nlet startMoveY = 0;\r\n\r\n// Resize status\r\nlet resizing = false;\r\n\r\nlet arrowType = 0;\r\nlet firstArrowJoint = true;\r\n\r\nlet cancelDraw = false;\r\n\r\n//Block Past location var\r\nlet past_location = [];\r\nlet past_size = [];\r\nlet selectedObject;\r\nexport var blockBeenSelected = false;\r\n\r\n// Init\r\nexport function assignElement(elementID) {\r\n    canvasElement = document.getElementById(elementID);\r\n    canvasContext = canvasElement.getContext(\"2d\");\r\n\r\n    resetMouseOrigin();\r\n\r\n}\r\n\r\nexport function getModelName() {\r\n    let nameElement = document.getElementById(\"ModelName\")\r\n\r\n    if (nameElement === null) {\r\n        return \"Root\"\r\n    }\r\n    if (nameElement.value === \"\" || nameElement.value === null || nameElement.value === undefined) {\r\n        return \"Root\"\r\n    }\r\n    return nameElement.value;\r\n}\r\n\r\nexport function resetMouseOrigin() {\r\n    try {\r\n        let canvasRect = canvasElement.getBoundingClientRect();\r\n        mouseOriginX = canvasRect.left;\r\n        mouseOriginY = canvasRect.top;\r\n        recalculateScale();\r\n        clearCanvas();\r\n    } catch {\r\n        console.error(\"Failed to acquire canvas element\");\r\n    }\r\n    drawAll()\r\n}\r\n\r\n\r\n// Core functions\r\nexport function drawAll() {\r\n    updateArrows();\r\n    clearCanvas();\r\n\r\n    canvasContext.resetTransform();\r\n    canvasContext.scale(getEffectiveZoom(), getEffectiveZoom());\r\n\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item !== null) {\r\n            //console.log(\"HERE \" + item.typeName)\r\n            //Only render the objects which are in the currently selected containment\r\n\r\n            if (item.getModelKey() === currentModel) {\r\n                /*\r\n                if (item.typeName === \"Vertex\"){\r\n                    console.log(\"Item is set as present\")\r\n                    item.setPresent();\r\n                }\r\n                */\r\n                item.draw(canvasContext);\r\n\r\n            }\r\n\r\n            /*\r\n            else if (item.getModelKey() !== currentModel && item.typeName === \"Vertex\"){\r\n                console.log(\"Item is sent away\")\r\n                item.setAway();\r\n                //console.log(\"The item to not be rendered is\" + item.typeName);\r\n            }\r\n            */\r\n\r\n        }\r\n    });\r\n\r\n}\r\n\r\nexport function deleteElement(element) {\r\n    if (element !== null) {\r\n        if (!currentObjects.remove(element)) {\r\n            console.error(\"Failed to delete object with UUID %s\", element.semanticIdentity.UUID);\r\n        }\r\n    } else {\r\n        console.error(\"Attempted to delete a null element\");\r\n    }\r\n\r\n    drawAll()\r\n}\r\n\r\n//this is the same as the above, except when you're deleting a vertex with an arrow connected the edge connection code freaks out.\r\n//this here deletes any arrows connected to the vertex before deleting the vertex to get around this\r\nexport function vertexDeleteElement(element) {\r\n    console.log(\"vDeleteE occurs\")\r\n    //find the UUID of the vertex for arrow dest and source matching\r\n    //let selectedVertUUID = element.semanticIdentity.UUID;\r\n\r\n    //Get the arrow UUID's\r\n    let sourceUUIDs = currentObjects.ArrowUUIDSource(element);\r\n    let destUUIDs = currentObjects.ArrowUUIDDest(element);\r\n    //find an arrow with matching source/dest if they exist\r\n\r\n    sourceUUIDs.forEach(element => currentObjects.remove(element.arrow));\r\n    destUUIDs.forEach(element => currentObjects.remove(element.arrow))\r\n\r\n    //Now that the arrows are out of the way, we're safe to delete the vertex (same code as above)\r\n    if (element !== null) {\r\n        console.log(\"vdl if staement pass\")\r\n        if (!currentObjects.remove(element)) {\r\n            \r\n            console.error(\"Failed to delete object with UUID %s\", element.semanticIdentity.UUID);\r\n        }\r\n    } else {\r\n        console.error(\"Attempted to delete a null element\");\r\n    }\r\n\r\n    drawAll()\r\n\r\n}\r\n\r\nexport function updateRows() {\r\n    yRows = document.getElementById(\"canvasRows\").value;\r\n    drawAll()\r\n}\r\n\r\n// Format co-ordinate so that the value aligns with a row\r\nfunction findNearestGridY(y, top) {\r\n\r\n    // distance to topmost top rowLine\r\n    let slotHeight = canvasHeight / yRows * zoom / 100 * 200 / zoom;\r\n\r\n    // which row to put it in\r\n    let slot = Math.floor(y / slotHeight);\r\n\r\n    // y co-ordinate of that row (if bottom then go up by row gap)\r\n    return slotHeight * slot + (slotHeight / 2 * + top)\r\n}\r\n\r\n// Checks to see which side it should resize on\r\nfunction checkResizeBounds(x, y) {\r\n    // Iterate through all objects and only check vertices\r\n    let currentObjectsFlattened = currentObjects.flatten();\r\n    for (let i = 0; i < currentObjectsFlattened.length; i++) {\r\n        let item = currentObjectsFlattened[i];\r\n\r\n        if (item.typeName === \"Vertex\") {\r\n            // Get vertex bounds\r\n            // x1 y1 are the lower coordinates\r\n            // x2 y2 are the upper coordinates\r\n            // Note: x2 y2 are not width/height values\r\n\r\n            //tolerance in px\r\n            let tolerance = 10;\r\n\r\n            let bounds = item.getBounds();\r\n            let x1 = bounds[0];\r\n            let y1 = bounds[1];\r\n            let x2 = bounds[2];\r\n            let y2 = bounds[3];\r\n\r\n            let top = Math.abs(y1 - y) < tolerance;\r\n            let bottom = Math.abs(y2 - y) < tolerance;\r\n            let left = Math.abs(x1 - x) < tolerance;\r\n            let right = Math.abs(x2 - x) < tolerance;\r\n            let inYBounds = y > y1 && y < y2;\r\n            let inXBounds = x > x1 && x < x2;\r\n\r\n            if (right && inYBounds) {\r\n                return [item, \"right\"];\r\n            }\r\n\r\n            if (top && left) {\r\n                return [item, \"topLeft\"];\r\n            } else if (top && right) {\r\n                return [item, \"topRight\"];\r\n            } else if (bottom && left) {\r\n                return [item, \"bottomLeft\"];\r\n            } else if (bottom && right) {\r\n                return [item, \"bottomRight\"];\r\n            } else if (left && inYBounds) {\r\n                return [item, \"left\"];\r\n            } if (right && inYBounds) {\r\n                return [item, \"right\"];\r\n            } else if (top && inXBounds) {\r\n                return [item, \"top\"];\r\n            } else if (bottom && inXBounds) {\r\n                return [item, \"bottom\"];\r\n            }\r\n        }\r\n    }\r\n\r\n    // All else fails\r\n    return [null, null];\r\n}\r\n\r\nexport const distanceThreshold = 15;\r\n\r\n// Find connectable for arrow within a threshold distance\r\nfunction getConnectionDataForArrow(cursorX, cursorY) {\r\n    const angleThreshold = 8;\r\n\r\n    let nearest = null;\r\n    let nearestDistance = 0;\r\n\r\n    // Find nearest connectable\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item !== null) {\r\n            if (item.typeName === \"Vertex\") {\r\n                let sideData = item.getNearestSideFrom(cursorX, cursorY, lastX, lastY);\r\n                // Only check if valid\r\n                if (sideData !== null && sideData[0] < distanceThreshold) {\r\n                    // Compare dist\r\n                    if (nearest === null || sideData[0] < nearestDistance) {\r\n                        nearest = [0, item.semanticIdentity.UUID, sideData[1], sideData[2]];\r\n                        nearestDistance = sideData[0];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    // Set coordinates\r\n    let coordinate = nearest;\r\n    if (nearest === null) {\r\n        coordinate = [1, cursorX, cursorY];\r\n    }\r\n\r\n    // If can't snap to right angles\r\n    if (arrowPath.length < 1 || coordinate[0] === 0) return { coord: coordinate, snapped: nearest !== null, nearest: nearest };\r\n\r\n    // Get angle\r\n    let lastPathX = arrowPath[arrowPath.length - 1][1];\r\n    let lastPathY = arrowPath[arrowPath.length - 1][2];\r\n    let x = coordinate[1] - lastPathX;\r\n    let y = coordinate[2] - lastPathY;\r\n\r\n    // must be y,x check documentation if you dont believe me\r\n    let angle = Math.atan2(y, x) * (180 / Math.PI);\r\n    // Make positive\r\n    angle = (angle + 360) % 360;\r\n    // Get relative\r\n    let relAngle = angle % 90;\r\n\r\n    // Check if it should snap to right angles\r\n    if (relAngle > 90 - angleThreshold || relAngle < angleThreshold) {\r\n        // Get length\r\n        let l = getDistance(0, 0, x, y);\r\n\r\n        // Choose angle\r\n        let angles = [0, 90, 180, 270, 360];\r\n        let nearestAngle = angles[0];\r\n        for (let i = 1; i < angles.length; i++) {\r\n            if (Math.abs(angles[i] - angle) < Math.abs(nearestAngle - angle)) {\r\n                nearestAngle = angles[i];\r\n            }\r\n        }\r\n        let nearestRad = nearestAngle * (Math.PI / 180);\r\n\r\n        // Create vector\r\n        let xv = l * Math.cos(nearestRad);\r\n        let yv = l * Math.sin(nearestRad);\r\n\r\n        // Create point (not vector sitting on 0,0)\r\n        coordinate = [coordinate[0], lastPathX + xv, lastPathY + yv];\r\n\r\n\r\n    }\r\n\r\n    return { coord: coordinate, snapped: nearest !== null, nearest: nearest }\r\n}\r\n\r\nexport function getSelectedObject(canvas) {\r\n    return canvas.props.mainState.selectedObject\r\n}\r\n\r\nfunction resizeObjectOnMouseMove(e, resizeVars) {\r\n    let coords = getGraphXYFromMouseEvent(e);\r\n\r\n    resizeVars[0].expandSide(resizeVars[1], coords[0], coords[1], canvasContext);\r\n\r\n    //grab object and arrows connected to it\r\n    // update arrows\r\n    updateA();\r\n    \r\n    \r\n}\r\n\r\n// Sets the objects uuid and adds it to the root of currentObjects\r\nexport function addObject(object) {\r\n    if (object === null || object === undefined) return;\r\n    currentObjects.add(object);\r\n}\r\n\r\n// Sets the currentObjects value to a new one. WARNING it will override the current value without any checks\r\nexport function setCurrentObjects(newObjects) {\r\n    currentObjects = newObjects;\r\n    drawAll();\r\n}\r\n\r\nexport function newFile() {\r\n    // Confirm\r\n    let r = window.confirm(\"Are you sure, this will clear the current canvas!\");\r\n    if (r === true) {\r\n        console.log(\"Clearing canvas\");\r\n        window.location.reload();\r\n    } else {\r\n        console.log(\"User opted to not clear the canvas\");\r\n    }\r\n\r\n    // Redraw\r\n    drawAll(currentObjects);\r\n}\r\n\r\nfunction arrowToolSelected() {\r\n    return arrowType === Tool.Visibility || arrowType === Tool.Edge || arrowType === Tool.Specialisation\r\n}\r\n\r\nexport function getObjectFromUUID(UUID) {\r\n    let foundObject;\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.semanticIdentity.UUID === UUID) {\r\n            foundObject = item;\r\n        }\r\n    });\r\n    return foundObject;\r\n}\r\n\r\n\r\nfunction findNearestArrowPointIndex(x, y) {\r\n    let nearestPointIndex = -1;\r\n    // Nearest distance here is used as a tolerance variable\r\n    let nearestDistance = 30;\r\n    let cDist;\r\n    let nearestArrow = null;\r\n\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.typeName === \"Arrow\") {\r\n            item.path.forEach((point) => {\r\n                cDist = Math.hypot(x - point[0], y - point[1]);\r\n                console.log(cDist);\r\n                if (cDist < nearestDistance) {\r\n                    nearestDistance = cDist;\r\n                    nearestPointIndex = item.path.indexOf(point);\r\n                    nearestArrow = item\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return [nearestPointIndex, nearestArrow]\r\n}\r\n\r\nfunction StickArrowToObject(connectionData, arrow, index) {\r\n    // so the line sticks to object\r\n    if (connectionData['snapped'] === false) {\r\n        let coord = connectionData['coord'];\r\n        // update the arrow\r\n        arrow.path[index] = [coord[1], coord[2]]\r\n    } else {\r\n        let vertexUUID = connectionData['nearest'][1];\r\n        let vertex = getObjectFromUUID(vertexUUID);\r\n\r\n        if (vertex !== undefined) {\r\n            arrow.path[index] = arrow.rebuildPath()\r\n        }\r\n    }\r\n}\r\n\r\nfunction moveArrowPointOnMouseMove(e, index, arrow) {\r\n    let x, y;\r\n    [x, y] = getGraphXYFromMouseEvent(e);\r\n    let conData = getConnectionDataForArrow(x, y);\r\n    arrow.pathData[index] = conData['nearest'];\r\n    StickArrowToObject(conData, arrow, index);\r\n\r\n\r\n}\r\n\r\n\r\n// Event based functions\r\nexport function onLeftMousePress(canvas, x, y) {\r\n\r\n    // Checks if your mouse is in range of the borders of a box to resize them\r\n    let resizeVars = checkResizeBounds(x, y);\r\n    if (canvas.tool === Tool.Vertex || canvas.tool === Tool.Select) {\r\n        if (resizeVars[0] !== null) {\r\n            if (resizeVars[0] === getSelectedObject(canvas)) {\r\n                saveBlockStates(canvas, x, y);\r\n                resizing = true;\r\n                canvasElement.onmousemove = function (e) {\r\n                    resizeObjectOnMouseMove(e, resizeVars);\r\n\r\n                };\r\n                \r\n                return;\r\n            }\r\n        } else {\r\n        }\r\n\r\n\r\n\r\n        let intersection = findIntersected(x, y);\r\n        if (canvas.tool === Tool.Vertex && intersection !== null) {\r\n            //console.log(\"Selecting intersected Vertex\");\r\n            canvas.props.setLeftMenu(intersection);\r\n            canvas.props.setMode(Tool.Select);\r\n            cancelDraw = true;\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    if (canvas.tool === Tool.Select) {\r\n        let index, arrow;\r\n        [index, arrow] = findNearestArrowPointIndex(x, y);\r\n        //console.log(index, arrow);\r\n        if (arrow === getSelectedObject(canvas)) {\r\n            if (index !== -1) {\r\n                resizing = true;\r\n                let func = function (e) {\r\n                    moveArrowPointOnMouseMove(e, index, arrow)\r\n                };\r\n\r\n\r\n                canvasElement.addEventListener(\"mousemove\", func);\r\n                canvasElement.addEventListener(\"mouseup\", () => {\r\n                    canvasElement.removeEventListener(\"mousemove\", func);\r\n                    console.log(\"removed\")\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    mouseStartX = x;\r\n    mouseStartY = y;\r\n\r\n\r\n\r\n    // Enable example draw while user is deciding shape\r\n    canvasElement.onmousemove = function (e) { onMouseMove(e, canvas) }\r\n\r\n\r\n}\r\n\r\n//aligning lines when large box moved\r\nexport function checkArrowsConnectedToBox(Object) {\r\n    // check arrows which one matches the box that was moved by its ID \r\n\r\n    // check how much the box has changed\r\n    let objectID;\r\n\r\n    let arrowArray = [];\r\n\r\n    resizing = true;\r\n    objectID = Object.semanticIdentity.UUID;\r\n    console.log(objectID);\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.typeName === \"Arrow\") {\r\n            let conData = 0;\r\n            //If the object is connected to destination\r\n            if (objectID === item.destVertexUUID) {\r\n                arrowArray.push(item);\r\n\r\n                // get connection data calcs min dist to travel and hopefully it's straight up\r\n                // first object destination y is less than object y\r\n                if (item.path[0][1] < Object.y) {\r\n                    conData = getConnectionDataForArrow(item.path[0][0], Object.y);\r\n                }\r\n                else {\r\n                    conData = getConnectionDataForArrow(item.path[0][0], Object.y + Object.height);\r\n                }\r\n                item.pathData[1] = conData['nearest'];\r\n                console.log(\"dest one\")\r\n                StickArrowToObject(conData, item, 1);\r\n\r\n                //If the object is connected to Source\r\n            } else if (objectID === item.sourceVertexUUID) {\r\n                arrowArray.push(item);\r\n                if (item.path[1][1] < Object.y) {\r\n                    conData = getConnectionDataForArrow(item.path[1][0], Object.y);\r\n                }\r\n                else {\r\n                    conData = getConnectionDataForArrow(item.path[1][0], Object.y + Object.height);\r\n                }\r\n                item.pathData[0] = conData['nearest'];\r\n                console.log(\"source one\");\r\n                StickArrowToObject(conData, item, 0);\r\n\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    resizing = false;\r\n\r\n\r\n}\r\n\r\nexport function checkHorizArrowsConnectedToBox(Object) {\r\n    let objectID;\r\n\r\n    let arrowArray = [];\r\n\r\n    resizing = true;\r\n    objectID = Object.semanticIdentity.UUID;\r\n    console.log(objectID);\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.typeName === \"Arrow\") {\r\n            let conData = 0;\r\n            //If the object is connected to destination\r\n            if (objectID === item.destVertexUUID) {\r\n                arrowArray.push(item);\r\n\r\n                if (item.path[0][0] < Object.x) {\r\n                    conData = getConnectionDataForArrow(Object.x + 1, item.path[0][1]);\r\n                }\r\n                else {\r\n                    conData = getConnectionDataForArrow(Object.x + Object.width - 1, item.path[0][1]);\r\n                }\r\n                item.pathData[1] = conData['nearest'];\r\n                console.log(\"dest one\")\r\n                StickArrowToObject(conData, item, 1);\r\n\r\n                //If the object is connected to Source\r\n            } else if (objectID === item.sourceVertexUUID) {\r\n                arrowArray.push(item);\r\n                if (item.path[1][0] < Object.x) {\r\n                    conData = getConnectionDataForArrow(Object.x + 1, item.path[0][1]);\r\n                }\r\n                else {\r\n                    conData = getConnectionDataForArrow(Object.x + Object.width - 1, item.path[0][1]);\r\n                }\r\n                item.pathData[0] = conData['nearest'];\r\n                console.log(\"source one\");\r\n                StickArrowToObject(conData, item, 0);\r\n\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    resizing = false;\r\n\r\n\r\n}\r\n\r\n\r\n//save the position of the clicked variable as global\r\nexport function saveBlockStates(canvas, x, y) {\r\n    selectedObject = getSelectedObject(canvas);\r\n    if (getSelectedObject(canvas) === null) {\r\n        selectedObject = findIntersected(x, y);\r\n    }\r\n    if (selectedObject !== null) {\r\n        blockBeenSelected = true;\r\n\r\n        //console.log(\"Block States Have been Saved\");\r\n        past_location = [selectedObject.x, selectedObject.y];\r\n        past_size = [selectedObject.width, selectedObject.height];\r\n    }\r\n}\r\n\r\nexport function setArrowType(type) {\r\n    arrowType = type\r\n}\r\n\r\n//make sure boxes don't collide\r\nexport function checkCollision(canvas, x, y) {\r\n    //console.log(\"Collision Tests:\");\r\n    let object = selectedObject;\r\n    let CollideCount = 0;\r\n    //console.log(past_size);\r\n    // for loop to check all boxes in the list\r\n    if (currentObjects.flatten() !== null && object !== null) {\r\n        currentObjects.flatten().forEach((item) => {\r\n            if (item.typeName === \"Vertex\") {\r\n                //make sure coords are > coords of box u just placed + its width\r\n                if (object.x === item.x && object.y === item.y) {\r\n                    //console.log(\"collides with itself\");\r\n                }\r\n                // error of 10 pixels for item's height\r\n                else if ((object.y > (item.y + item.height + 10)) || (object.x > (item.x + item.width))\r\n                    || (item.x > (object.x + object.width)) || (item.y > (object.y + object.height + 10))) {\r\n                    //console.log(\"NoCollide\");\r\n                }\r\n                else {\r\n                    // revert to past stored location\r\n                    object.x = past_location[0];\r\n                    object.y = past_location[1];\r\n                    object.width = past_size[0];\r\n                    object.height = past_size[1];\r\n                    CollideCount++;\r\n                    //console.log(\"Collided\");\r\n                }\r\n            }\r\n        });\r\n        // as long as never collided, change to new location\r\n        if (CollideCount === 0) {\r\n            past_location = [object.x, object.y];\r\n            past_size = [object.width, object.height]\r\n            //console.log(CollideCount);\r\n        }\r\n        blockBeenSelected = false;\r\n        drawAll(currentObjects);\r\n    }\r\n}\r\n\r\n\r\nexport function onRightMouseRelease(canvas, x, y) {\r\n    let ET = findIntersected(x, y);\r\n    if (arrowToolSelected() && ET !== null) {\r\n        // Create\r\n\r\n        let newObject = createObject(canvas, mouseStartX, mouseStartY, x, y);\r\n\r\n        // Reset path\r\n        arrowPath = [];\r\n        firstArrowJoint = true;\r\n\r\n        addObject(newObject);\r\n\r\n        // Disable example draw\r\n        canvasElement.onmousemove = null;\r\n        drawAll(currentObjects);\r\n\r\n        canvas.props.setLeftMenu(newObject)\r\n        canvas.props.setMode(Tool.Select);\r\n    }\r\n}\r\n\r\nexport function updateA() {\r\n    let conData = 0;\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.typeName === \"Arrow\") {\r\n\r\n            conData = getConnectionDataForArrow(item.path[1][0], item.path[1][1]);\r\n            item.pathData[1] = conData['nearest'];\r\n            StickArrowToObject(conData, item, 0);\r\n\r\n\r\n        }\r\n    });\r\n}\r\nexport function compareSizesToMoveAll(Object) {\r\n\r\n    //for loop to get all the arrows\r\n    //for loop to check destination and source\r\n    //if object ID is equal \r\n    //find whichever one is not the currently selected block\r\n    // if it's smaller move it else do nothing\r\n\r\n    let objectID;\r\n    let verticalArray = [];\r\n    let horizontalArray = [];\r\n    let box;\r\n    let boxArray = [];\r\n\r\n    objectID = Object.semanticIdentity.UUID;\r\n    console.log(Object);\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.typeName === \"Arrow\") {\r\n\r\n            //If the object is connected to destination\r\n            if (objectID === item.destVertexUUID) {\r\n                box = getObjectFromUUID(item.sourceVertexUUID);\r\n                if ((box.height + 10) * box.width < (Object.height + 10) * Object.width) {\r\n                    boxArray.push(box);\r\n\r\n                }\r\n                //check if arrow is on top/ below\r\n                if (item.path[0][1] < Object.y || item.path[0][1] > Object.y + Object.height + 10) {\r\n                    //push to vertical array\r\n                    verticalArray.push(item);\r\n                }\r\n                //check if arrow is left/ right\r\n                else if (item.path[0][0] < Object.x || item.path[0][0] > Object.x + Object.width) {\r\n                    //push to horizontal array\r\n                    horizontalArray.push(item);\r\n                }\r\n\r\n\r\n\r\n            }\r\n            //If the object is connected to Source\r\n            else if (objectID === item.sourceVertexUUID) {\r\n                box = getObjectFromUUID(item.destVertexUUID);\r\n                if ((box.height + 10) * box.width < (Object.height + 10) * Object.width) {\r\n                    boxArray.push(box);\r\n                }\r\n                //check if arrow is on top/ below\r\n                if (item.path[1][1] < Object.y || item.path[1][1] > Object.y + Object.height + 10) {\r\n                    //push to vertical array\r\n                    verticalArray.push(item);\r\n\r\n                }\r\n                //check if arrow is left/ right\r\n                else if (item.path[1][0] < Object.x || item.path[1][0] > Object.x + Object.width) {\r\n                    //push to horizontal array\r\n                    horizontalArray.push(item);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    });\r\n    return [boxArray, verticalArray, horizontalArray];\r\n}\r\n\r\nexport function checkBoxSizesAndReturnBigBox(first, second) {\r\n    if ((first.width) * (first.height + 10) <= (second.width) * (second.height + 10)) {\r\n        return [second, first];\r\n    } else {\r\n        return [first, second];\r\n    }\r\n}\r\n\r\n//line intersect\r\nexport function lineIntersect(canvas, x, y, secondObject) {\r\n    endX = 0;\r\n    endY = 0;\r\n\r\n    startX = 0;\r\n    startY = 0;\r\n\r\n    console.log(\"\\n \\n arrow path: \" + arrowPath + \"\\n\\n\");\r\n    arrowPath = [];\r\n\r\n    //previous object is below\r\n    if (previousObject.y > y && previousObject.x + previousObject.width > x) {\r\n        console.log(\"\\n\\n\\n prev object was below \\n\\n\\n\");\r\n        startY = previousObject.y;\r\n        startX = previousObject.x + (0.5 * previousObject.width);\r\n\r\n        endY = secondObject.y + secondObject.height + 10;\r\n        endX = secondObject.x + (0.5 * secondObject.width);\r\n\r\n    }\r\n    // previous object is above\r\n    else if (previousObject.y < y && previousObject.x + previousObject.width > x && previousObject.x < x) {\r\n        console.log(\"\\n\\n\\n prev object was above \\n\\n\\n\");\r\n        startY = previousObject.y + previousObject.height + 10; //+ means go to bottom\r\n        startX = previousObject.x + (0.5 * previousObject.width);\r\n\r\n        endY = secondObject.y;\r\n        endX = secondObject.x + (0.5 * secondObject.width);\r\n    }\r\n    //previous object is left of //if you click higher it counts as above\r\n\r\n    //sizes based on Total Area\r\n    let blockPre = previousObject.height + previousObject.width;\r\n    let blockSec = secondObject.height + secondObject.width;\r\n\r\n    //previous object is below\r\n    if (previousObject.y > (secondObject.y + secondObject.height + 10)) {\r\n        //console.log(\"\\n\\n\\n prev object was below \\n\\n\\n\");\r\n        //if previous is inside second range\r\n        if ((previousObject.x > secondObject.x) && ((previousObject.x + previousObject.width) < (secondObject.x + secondObject.width))) {\r\n            startY = previousObject.y;\r\n            startX = previousObject.x + (0.5 * previousObject.width);\r\n\r\n            endY = startY - (startY - (secondObject.y + secondObject.height + 10));\r\n            endX = startX;\r\n        }\r\n        //if second is inside previous range\r\n        else if ((previousObject.x < secondObject.x) && ((previousObject.x + previousObject.width) > (secondObject.x + secondObject.width))) {\r\n            startY = secondObject.y + secondObject.height + 10;\r\n            startX = secondObject.x + (0.5 * secondObject.width);\r\n\r\n            endY = startY + (previousObject.y - startY);\r\n            endX = startX;\r\n        }\r\n        //If pre is downLeft of sec extend whichever box is bigger horizontally and fit\r\n        else if ((previousObject.x < secondObject.x) && ((previousObject.x + previousObject.width) < (secondObject.x + secondObject.width))) {\r\n            if (blockPre <= blockSec) {\r\n                secondObject.width = secondObject.width + (secondObject.x - previousObject.x);\r\n                secondObject.x = previousObject.x;\r\n\r\n                startY = previousObject.y;\r\n                startX = secondObject.x + previousObject.width / 2;\r\n                endY = secondObject.y + secondObject.height;\r\n                endX = startX;\r\n                //second obj is changing size\r\n                checkArrowsConnectedToBox(secondObject);\r\n\r\n            }\r\n            if (blockPre >= blockSec) {\r\n                previousObject.width = previousObject.width + ((secondObject.x + secondObject.width) - (previousObject.x + previousObject.width));\r\n                previousObject.x = previousObject.x;\r\n\r\n                startY = secondObject.y + secondObject.height;\r\n                startX = secondObject.x + secondObject.width / 2;\r\n                endY = previousObject.y;\r\n                endX = startX;\r\n                //prev obj is changing size\r\n\r\n                //this one works\r\n                checkArrowsConnectedToBox(previousObject);\r\n            }\r\n        }\r\n        //If pre is downright of sec extend whichever box is better horizontally and fit\r\n        else if (previousObject.x > secondObject.x) {\r\n            if (blockPre <= blockSec) {\r\n                secondObject.width = secondObject.width + ((previousObject.x + previousObject.width) - (secondObject.x + secondObject.width));\r\n\r\n                startY = previousObject.y;\r\n                startX = previousObject.x + previousObject.width / 2;\r\n                endY = secondObject.y + secondObject.height;\r\n                endX = startX;\r\n                //second obj is changing size\r\n\r\n                checkArrowsConnectedToBox(secondObject, endX - startX, endY - startY);\r\n            }\r\n            if (blockPre >= blockSec) {\r\n                previousObject.width = previousObject.width + (previousObject.x - secondObject.x);\r\n                previousObject.x = secondObject.x;\r\n\r\n                startY = secondObject.y + secondObject.height;\r\n                startX = secondObject.x + secondObject.width / 2;\r\n                endY = previousObject.y;\r\n                endX = startX;\r\n                //prev obj is changing size\r\n\r\n                checkArrowsConnectedToBox(previousObject);\r\n            }\r\n        }\r\n    }\r\n    // previous object is above\r\n    else if (previousObject.y + previousObject.height + 10 < secondObject.y) {\r\n        //console.log(\"\\n\\n\\n prev object was above \\n\\n\\n\");\r\n        //if previous is inside second range\r\n        if ((previousObject.x > secondObject.x) && ((previousObject.x + previousObject.width) < (secondObject.x + secondObject.width))) {\r\n            startY = previousObject.y + previousObject.height;\r\n            startX = previousObject.x + (0.5 * previousObject.width);\r\n\r\n            endY = startY - (startY - (secondObject.y));\r\n            endX = startX;\r\n        }\r\n        //if second is inside previous range\r\n        else if ((previousObject.x < secondObject.x) && ((previousObject.x + previousObject.width) > (secondObject.x + secondObject.width))) {\r\n            startY = secondObject.y;\r\n            startX = secondObject.x + (0.5 * secondObject.width);\r\n\r\n            endY = startY + previousObject.height + (previousObject.y - startY);\r\n            endX = startX;\r\n        }\r\n        //If pre is upLeft of sec extend whichever box is better horizontally and fit\r\n        else if ((previousObject.x < secondObject.x) && ((previousObject.x + previousObject.width) < (secondObject.x + secondObject.width))) {\r\n            if (blockPre <= blockSec) {\r\n                secondObject.width = secondObject.width + (secondObject.x - previousObject.x);\r\n                secondObject.x = previousObject.x;\r\n\r\n                startY = previousObject.y + previousObject.height;\r\n                startX = secondObject.x + previousObject.width / 2;\r\n                endY = secondObject.y;\r\n                endX = startX;\r\n                //second obj is changing size\r\n\r\n                //fixed\r\n                checkArrowsConnectedToBox(secondObject);\r\n            }\r\n            if (blockPre >= blockSec) {\r\n                previousObject.width = previousObject.width + ((secondObject.x + secondObject.width) - (previousObject.x + previousObject.width));\r\n                previousObject.x = previousObject.x;\r\n\r\n                startY = secondObject.y;\r\n                startX = secondObject.x + secondObject.width / 2;\r\n                endY = previousObject.y + previousObject.height;\r\n                endX = startX;\r\n                //previous obj is changing size\r\n\r\n                checkArrowsConnectedToBox(previousObject);\r\n            }\r\n        }\r\n        //If pre is upright of sec extend whichever box is bigger horizontally and fit\r\n        else if (previousObject.x > secondObject.x) {\r\n            if (blockPre <= blockSec) {\r\n                secondObject.width = secondObject.width + ((previousObject.x + previousObject.width) - (secondObject.x + secondObject.width));\r\n\r\n                startY = previousObject.y + previousObject.height;\r\n                startX = previousObject.x + previousObject.width / 2;\r\n                endY = secondObject.y;\r\n                endX = startX;\r\n                //previous obj is changing size\r\n\r\n                //this one is fixed\r\n                checkArrowsConnectedToBox(secondObject);\r\n            }\r\n            if (blockPre >= blockSec) {\r\n                previousObject.width = previousObject.width + (previousObject.x - secondObject.x);\r\n                previousObject.x = secondObject.x;\r\n\r\n                startY = secondObject.y;\r\n                startX = secondObject.x + secondObject.width / 2;\r\n                endY = previousObject.y + previousObject.height;\r\n                endX = startX;\r\n\r\n                //second obj is changing size\r\n\r\n                checkArrowsConnectedToBox(previousObject);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    //previous object is left \r\n    else if (previousObject.x + previousObject.width < secondObject.x) {\r\n\r\n        //Previous is smaller\r\n        if (previousObject.y > secondObject.y && previousObject.y + previousObject.height + 10 < secondObject.y + secondObject.height + 10) {\r\n            startY = previousObject.y + (previousObject.height + 10) / 2;\r\n            startX = previousObject.x + previousObject.width;\r\n\r\n            endX = secondObject.x;\r\n            endY = startY;\r\n\r\n        }\r\n        //Second is smaller\r\n        else if (secondObject.y > previousObject.y && secondObject.y + secondObject.height + 10 < previousObject.y + previousObject.height + 10) {\r\n            startY = secondObject.y + (secondObject.height + 10) / 2;\r\n            startX = secondObject.x;\r\n\r\n            endX = previousObject.x + previousObject.width;\r\n            endY = startY;\r\n\r\n        }\r\n        //Top Left and peeking\r\n        else if (previousObject.y + previousObject.height + 10 > secondObject.y && secondObject.y > previousObject.y) {\r\n            if (blockPre <= blockSec) {\r\n                secondObject.height = secondObject.height + (secondObject.y - previousObject.y);\r\n                secondObject.y = previousObject.y;\r\n\r\n                startY = previousObject.y + (previousObject.height + 10) / 2;\r\n                startX = previousObject.x + previousObject.width;\r\n                endX = secondObject.x;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(secondObject);\r\n\r\n                console.log(\"m\");\r\n            }\r\n\r\n            if (blockPre >= blockSec) {\r\n                let increase = previousObject.height + 10 + ((secondObject.y + secondObject.height) - (previousObject.y + previousObject.height));\r\n                //looks at x coord and y coord and @ that coord checks if there's a box\r\n                //resizeVars[0] returns the box if there is a\r\n                //resizeVars[1] is which side/corner of the box that its coords are expected to be at (else null)\r\n                let resizeVars = checkResizeBounds(previousObject.x + previousObject.width, previousObject.y + previousObject.height + 10);\r\n                console.log(resizeVars);\r\n                resizeVars[0].expandSide(resizeVars[1], previousObject.x + previousObject.width, previousObject.y + increase, canvasContext);\r\n\r\n\r\n                startY = secondObject.y + (secondObject.height + 10) / 2;\r\n                startX = secondObject.x;\r\n\r\n                endX = previousObject.x + previousObject.width;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(previousObject);\r\n\r\n                console.log(\"n\");\r\n            }\r\n        }\r\n        //Bottom Left and peeking\r\n        else if (secondObject.y + secondObject.height + 10 > previousObject.y && previousObject.y + previousObject.height + 10 > secondObject.y + secondObject.height + 10) {\r\n            if (blockPre <= blockSec) {\r\n\r\n                let increase = secondObject.y + secondObject.height + 10 + ((previousObject.y + previousObject.height + 10) - (secondObject.y + secondObject.height + 10));\r\n\r\n                let resizeVars = checkResizeBounds(secondObject.x + secondObject.width, secondObject.y + secondObject.height + 10);\r\n                console.log(resizeVars);\r\n                resizeVars[0].expandSide(resizeVars[1], secondObject.x + secondObject.width, increase, canvasContext);\r\n\r\n\r\n                startY = previousObject.y + (previousObject.height + 10) / 2;\r\n                startX = secondObject.x;\r\n\r\n                endX = previousObject.x + previousObject.width;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(secondObject);\r\n\r\n                console.log(\"o\");\r\n            }\r\n\r\n            if (blockPre >= blockSec) {\r\n                previousObject.height = previousObject.height + 10 + (previousObject.y - secondObject.y);\r\n                previousObject.y = secondObject.y;\r\n\r\n                startY = secondObject.y + (secondObject.height + 10) / 2;\r\n                startX = secondObject.x;\r\n\r\n                endX = previousObject.x + previousObject.width;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(previousObject);\r\n\r\n                console.log(\"p\");\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    //Previous object is right side\r\n    else if (previousObject.x > (secondObject.x + secondObject.width)) {\r\n\r\n        //Previous is smaller and on inside\r\n        if (previousObject.y > secondObject.y && previousObject.y + previousObject.height < secondObject.y + secondObject.height) {\r\n            startY = previousObject.y + (previousObject.height + 10) / 2;\r\n            startX = previousObject.x;\r\n\r\n            endX = secondObject.x + secondObject.width;\r\n            endY = startY;\r\n\r\n        }\r\n        //Second is smaller and on inside\r\n        else if (secondObject.y > previousObject.y && secondObject.y + secondObject.height < previousObject.y + previousObject.height) {\r\n            startY = secondObject.y + (secondObject.height + 10) / 2;\r\n            startX = secondObject.x + secondObject.width;\r\n\r\n            endX = previousObject.x;\r\n            endY = startY;\r\n\r\n            console.log(\"r\");\r\n        }\r\n        //Top Right and peeking\r\n        else if (previousObject.y + previousObject.height + 10 > secondObject.y && secondObject.y > previousObject.y) {\r\n            if (blockPre <= blockSec) {\r\n                secondObject.height = secondObject.height + 10 + (secondObject.y - previousObject.y);\r\n                secondObject.y = previousObject.y;\r\n\r\n                startY = previousObject.y + (previousObject.height + 10) / 2;\r\n                startX = previousObject.x;\r\n\r\n                endX = secondObject.x + secondObject.width;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(secondObject);\r\n\r\n                console.log(\"s\");\r\n            }\r\n\r\n            if (blockPre >= blockSec) {\r\n                previousObject.height = previousObject.height + 10 + ((secondObject.y + secondObject.height + 10) - (previousObject.y + previousObject.height + 10));\r\n\r\n                startX = secondObject.x + secondObject.width;\r\n                startY = secondObject.y + (secondObject.height + 10) / 2;\r\n\r\n                endX = previousObject.x;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(previousObject);\r\n\r\n                console.log(\"t\");\r\n            }\r\n\r\n        }\r\n        //Bottom Left and peeking\r\n        else if (secondObject.y + secondObject.height + 10 < previousObject.y + previousObject.height + 10 && previousObject.y < secondObject.y + secondObject.height + 10) {\r\n            if (blockPre <= blockSec) {\r\n                let increase = secondObject.height + 10 + ((previousObject.y + previousObject.height + 10) - (secondObject.y + secondObject.height + 10));\r\n                let resizeVars = checkResizeBounds(secondObject.x + secondObject.width, secondObject.y + secondObject.height + 10);\r\n                console.log(resizeVars);\r\n                resizeVars[0].expandSide(resizeVars[1], secondObject.x + secondObject.width, secondObject.y + increase, canvasContext);\r\n\r\n\r\n                startY = previousObject.y + (previousObject.height + 10) / 2;\r\n                startX = previousObject.x;\r\n\r\n                endX = secondObject.x + secondObject.width;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(secondObject);\r\n\r\n                console.log(\"u\");\r\n            }\r\n\r\n            if (blockPre >= blockSec) {\r\n                let increase = previousObject.height + 10 + (previousObject.y - secondObject.y);\r\n                let resizeVars = checkResizeBounds(previousObject.x + previousObject.width, previousObject.y + previousObject.height + 10);\r\n                console.log(resizeVars);\r\n                resizeVars[0].expandSide(resizeVars[1], previousObject.x + previousObject.width, previousObject.y + increase, canvasContext);\r\n\r\n                previousObject.y = secondObject.y;\r\n\r\n\r\n                startX = previousObject.x;\r\n                startY = secondObject.y + (secondObject.height + 10) / 2;\r\n\r\n                endX = secondObject.x + secondObject.width;\r\n                endY = startY;\r\n\r\n                checkHorizArrowsConnectedToBox(previousObject);\r\n\r\n                console.log(\"v\");\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    arrowPath.push(getConnectionDataForArrow(startX, startY).coord);\r\n\r\n\r\n    let newObject = createObject(canvas, startX, startY, endX, endY);\r\n\r\n\r\n\r\n    return newObject;\r\n\r\n\r\n\r\n}\r\n//\r\nexport function collectMehBox(boxes, arrows, bigbox, item, index) {\r\n\r\n    //console.log(\"runningcollect\");\r\n    if (bigbox.semanticIdentity.UUID === item.destVertexUUID) {\r\n        let box = getObjectFromUUID(item.sourceVertexUUID);\r\n        if ((bigbox.y) * index + (box.y) * (1 - index) > (box.y + box.height + 10) * index + (bigbox.y + bigbox.height + 10) * (1 - index)) {\r\n            boxes.push(box);\r\n            arrows.push(item);\r\n        }\r\n\r\n\r\n    } else if (bigbox.semanticIdentity.UUID === item.sourceVertexUUID) {\r\n        let box = getObjectFromUUID(item.destVertexUUID);\r\n        if ((bigbox.y) * index + (box.y) * (1 - index) > (box.y + box.height + 10) * index + (bigbox.y + bigbox.height + 10) * (1 - index)) {\r\n            boxes.push(box);\r\n            arrows.push(item);\r\n        }\r\n    }\r\n    return [boxes, arrows];\r\n}\r\n//Will arrange boxes and arrows in linked order above or below the big box.\r\n//Bigbox - The larger important box\r\n//boxes - list of all the boxes being moved\r\n//arrows - arrows connect to the above boxes\r\n//index - denotes the side that boxes are connected to \r\nexport function arrangeboxesandarrows(bigbox, boxes, arrows, index) {\r\n    //index = 1 = up\r\n    if (boxes.length >= 2) {\r\n        let b = 0;\r\n        let x = bigbox.x;\r\n        let y = bigbox.y + (bigbox.height + 30) * (1 - index);\r\n        for (b; b < boxes.length; b++) {\r\n            boxes[b].x = x;\r\n            boxes[b].y = y - ((boxes[b].height + 30) * index);\r\n            x = x + boxes[b].width + 20;\r\n\r\n            if (boxes[b].x + boxes[b].width > bigbox.x + bigbox.width) {\r\n                bigbox.width = bigbox.width + boxes[b].width\r\n            }\r\n        }\r\n        b = 0;\r\n        for (b; b < boxes.length; b++) {\r\n            console.log(arrows[b]);\r\n            let conData = getConnectionDataForArrow(boxes[b].x + boxes[b].width / 2, bigbox.y + (bigbox.height + 10) * (1 - index));\r\n            arrows[b].pathData[1] = conData['nearest'];\r\n            StickArrowToObject(conData, arrows[b], 1);\r\n        }\r\n    }\r\n}\r\n//\r\nexport function collectsidebox(boxes, arrows, bigbox, item, index) {\r\n\r\n    if (bigbox.semanticIdentity.UUID === item.destVertexUUID) {\r\n        let box = getObjectFromUUID(item.sourceVertexUUID);\r\n        if ((bigbox.x) * index + (box.x) * (1 - index) > (box.x + box.width) * index + (bigbox.x + bigbox.width) * (1 - index)) {\r\n            boxes.push(box);\r\n            arrows.push(item);\r\n        }\r\n\r\n\r\n    } else if (bigbox.semanticIdentity.UUID === item.sourceVertexUUID) {\r\n        let box = getObjectFromUUID(item.destVertexUUID);\r\n        if ((bigbox.x) * index + (box.x) * (1 - index) > (box.x + box.width) * index + (bigbox.x + bigbox.width) * (1 - index)) {\r\n            boxes.push(box);\r\n            arrows.push(item);\r\n        }\r\n    }\r\n    return [boxes, arrows];\r\n}\r\nexport function arrangeboxesandarrowshorizontal(bigbox, boxes, arrows, index) {\r\n    //index = 0 = right\r\n    if (boxes.length >= 2) {\r\n        let b = 0;\r\n        let x = bigbox.x + (bigbox.width + 30) * (1 - index);\r\n        let y = bigbox.y;\r\n        for (b; b < boxes.length; b++) {\r\n            boxes[b].x = x - ((boxes[b].width + 30) * index);\r\n            boxes[b].y = y;\r\n            y = y + boxes[b].height + 20;\r\n            //extending box\r\n            if (boxes[b].y + boxes[b].height + 10 > bigbox.y + bigbox.height + 10) {\r\n                bigbox.height = bigbox.height + boxes[b].height;\r\n            }\r\n        }\r\n        b = 0;\r\n        for (b; b < boxes.length; b++) {\r\n            console.log(arrows[b]);\r\n            let conData = getConnectionDataForArrow(bigbox.x + (bigbox.width) * (1 - index), boxes[b].y + (boxes[b].height + 10) / 2);\r\n            arrows[b].pathData[1] = conData['nearest'];\r\n            StickArrowToObject(conData, arrows[b], 1);\r\n        }\r\n    }\r\n}\r\n\r\nexport function shiftBoxes(secondObject) {\r\n    //if box is within horizontal bounds\r\n\r\n    let upBoxes = [];\r\n    let upArrows = [];\r\n    let downBoxes = [];\r\n    let downArrows = [];\r\n    let leftBoxes = [];\r\n    let leftArrows = [];\r\n    let rightBoxes = [];\r\n    let rightArrows = [];\r\n    let [bigBox, smallBox] = checkBoxSizesAndReturnBigBox(previousObject, secondObject);\r\n\r\n    //grab all arrows connected to either object\r\n    //Index 0 means down index 1 means up\r\n\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item.typeName === \"Arrow\") {\r\n            //get the big box because it has all the arrows connected\r\n            if (bigBox.y + bigBox.height + 10 < smallBox.y && smallBox.x > bigBox.x && smallBox.x + smallBox.width < bigBox.x + bigBox.width) {\r\n                [downBoxes, downArrows] = collectMehBox(downBoxes, downArrows, bigBox, item, 0);\r\n\r\n\r\n            } else if (bigBox.y > (smallBox.y + smallBox.height + 10) && smallBox.x > bigBox.x && smallBox.x + smallBox.width < bigBox.x + bigBox.width) {\r\n                [upBoxes, upArrows] = collectMehBox(upBoxes, upArrows, bigBox, item, 1);\r\n\r\n            } else if (bigBox.x > smallBox.x + smallBox.width && smallBox.y > bigBox.y && smallBox.y + smallBox.height + 10 < bigBox.y + bigBox.height + 10) {\r\n                console.log(\"left ran\");\r\n                [leftBoxes, leftArrows] = collectsidebox(leftBoxes, leftArrows, bigBox, item, 1);\r\n\r\n            } else if (bigBox.x + bigBox.width < smallBox.x && smallBox.y > bigBox.y && smallBox.y + smallBox.height + 10 < bigBox.y + bigBox.height + 10) {\r\n                console.log(\"right ran\");\r\n                [rightBoxes, rightArrows] = collectsidebox(rightBoxes, rightArrows, bigBox, item, 0);\r\n            }\r\n        }\r\n    });\r\n    //Do stuff to boxes\r\n    //1 = up\r\n    //0 = down\r\n    arrangeboxesandarrows(bigBox, downBoxes, downArrows, 0);\r\n    arrangeboxesandarrows(bigBox, upBoxes, upArrows, 1);\r\n\r\n    arrangeboxesandarrowshorizontal(bigBox, leftBoxes, leftArrows, 1);\r\n    arrangeboxesandarrowshorizontal(bigBox, rightBoxes, rightArrows, 0);\r\n\r\n    //console.log(downboxes.length);\r\n\r\n\r\n\r\n}\r\n\r\nexport function onLeftMouseRelease(canvas, x, y) {\r\n\r\n\r\n    if (cancelDraw) {\r\n        cancelDraw = false;\r\n        return;\r\n    }\r\n\r\n    if (resizing === true) {\r\n        resizing = false;\r\n        canvasElement.onmousemove = null;\r\n        return\r\n    }\r\n\r\n    // Disable example draw\r\n    canvasElement.onmousemove = null;\r\n\r\n    if (arrowToolSelected()) {\r\n        \r\n\r\n        if (getConnectionDataForArrow(x, y).snapped && !firstArrowJoint) {\r\n            // Create\r\n            let secondObject = findIntersected(x, y);\r\n            let newObject = null;\r\n            let firstObject = arrowPath[0] // the first position in the arrowpath array will either be null or the first vertex that is clicked with an arrow. \r\n                                            // therefor the arrow will not be created unless the first object that is clicked with the arrow tool is a vertex. - cooper\r\n            \r\n            if (firstObject !== null && secondObject !== null && savedArrows !== null) {\r\n                // create the arrow using the createObject function rather than the other function they were using as this seems much more stable - cooper\r\n                // also deleted a weird forloop that they had that i assume was for stopping the arrow overlap issue, but they themselves commented that it doesnt work\r\n                newObject = createObject(canvas, mouseStartX, mouseStartY, x, y); \r\n               \r\n            } \r\n\r\n            // Reset path\r\n            arrowPath = [];\r\n            firstArrowJoint = true;\r\n\r\n\r\n            if (newObject !== null) {\r\n                addObject(newObject);\r\n            }\r\n\r\n\r\n            drawAll(currentObjects);\r\n\r\n\r\n\r\n            //converting all arrows to savedArrows array\r\n            let i = 0;\r\n            currentObjects.flatten().forEach((item) => {\r\n                if (item.typeName === \"Arrow\") {\r\n                    savedArrows[i] = item.path;\r\n                    i++;\r\n                }\r\n\r\n            });\r\n\r\n            if (newObject !== null) {\r\n                canvas.props.setLeftMenu(newObject);\r\n            }\r\n\r\n            canvas.props.setMode(Tool.Select);\r\n            if (previousObject !== null && secondObject !== null) {\r\n                shiftBoxes(secondObject);\r\n            }\r\n            previousObject = null;\r\n\r\n\r\n        } else {\r\n            //maybe here where we can disable compound lines\r\n\r\n            //save object here\r\n            previousObject = findIntersected(x, y);\r\n            \r\n        \r\n\r\n            arrowPath.push(getConnectionDataForArrow(x, y).coord);\r\n            lastX = x;\r\n            lastY = y;\r\n            canvasElement.onmousemove = function (e) {\r\n                onMouseMove(e, canvas)\r\n            };\r\n            firstArrowJoint = false;\r\n        }\r\n\r\n    }\r\n\r\n    if (canvas.tool === Tool.Vertex) {\r\n        let newObject = createObject(canvas, mouseStartX, mouseStartY, x, y);\r\n        addObject(newObject);\r\n\r\n        canvas.props.setLeftMenu(newObject);\r\n        canvas.props.setMode(Tool.Select);\r\n    }\r\n    if (canvas.tool === Tool.Artifact) {\r\n        let newObject = createArtifact(canvas, mouseStartX, mouseStartY);\r\n        addObject(newObject);\r\n\r\n        canvas.props.setLeftMenu(newObject);\r\n        canvas.props.setMode(Tool.Select);\r\n    }\r\n    if (canvas.tool === Tool.Container) {\r\n        let newObject = createContainer(canvas, mouseStartX, mouseStartY);\r\n        newObject.setColour(\"#FFFFFF\");\r\n        addObject(newObject);\r\n        canvas.props.setLeftMenu(newObject);\r\n        canvas.props.setMode(Tool.Select);\r\n    }\r\n\r\n\r\n\r\n\r\n    drawAll(currentObjects);\r\n\r\n}\r\n\r\nfunction onMouseMove(e, canvas) {\r\n    let position = getGraphXYFromMouseEvent(e);\r\n\r\n    // Redraw Existing Objects\r\n    drawAll(currentObjects);\r\n\r\n    // Draw the new object\r\n    let newObject = createObject(canvas, mouseStartX, mouseStartY, position[0], position[1]);\r\n\r\n    canvasContext.globalAlpha = 0.75;\r\n    if (newObject !== null) {\r\n        newObject.draw(canvasContext);\r\n    }\r\n    canvasContext.globalAlpha = 1.0;\r\n}\r\n\r\nexport function onMiddleClick(canvas, x, y, savedObjects = null, shiftDown = false) {\r\n    // for arrows\r\n    startMoveX = x;\r\n    startMoveY = y;\r\n    // selecting the object based on coordinate\r\n    // if it doesnt find an object dont run it\r\n\r\n    let selectedObject = findIntersected(x, y);\r\n\r\n    //compareSizesToMoveAll returns any connected vertices to the selected along with the arrows themselves to be updated\r\n    let [friendObject, arrowsVert, arrowsHoriz] = compareSizesToMoveAll(selectedObject);\r\n\r\n        //If the selected block has a friend (connected by arrow) it will begin to try and identify friends of friends\r\n    if (friendObject !== null || friendObject.length >= 1) {\r\n        let ObjectsToCheck = friendObject;\r\n        let nextObjects = [];\r\n\r\n        //For loop to check all the closest friends (connected directly to selected )\r\n        for (let n = 0; n < ObjectsToCheck.length; n++) {\r\n            let [newfriendObject, newarrowsVert, newarrowsHoriz] = compareSizesToMoveAll(ObjectsToCheck[n]);\r\n            if (newfriendObject !== null) {\r\n\r\n                //for loop to check for duplicates and remove if any\r\n                for (let nf = 0; nf < newfriendObject.length; nf++) {\r\n                    console.log(ObjectsToCheck.length)\r\n                    for (let of = 0; of < ObjectsToCheck.length; of++) {\r\n                        //doesn't get run?:\r\n                        if (newfriendObject[nf].semanticIdentity.UUID === ObjectsToCheck[of].semanticIdentity.UUID) {\r\n                            newfriendObject.splice(nf, 1);\r\n                        }\r\n                    }\r\n                }\r\n                //Adds the objects that are connected to the friends to the friend list.\r\n                if (newfriendObject.length >= 1) {\r\n                    for (let p = 0; p < newfriendObject.length; p++) {\r\n                        nextObjects.push(newfriendObject[p]);\r\n                        friendObject.push(newfriendObject[p]);\r\n                    }\r\n\r\n                } \r\n            }\r\n           \r\n        }\r\n        //Updates the friendlist to begin a new search. \r\n        ObjectsToCheck = nextObjects; \r\n\r\n\r\n\r\n    }\r\n    let F = [];\r\n    if (friendObject !== null) {\r\n        let i = 0;\r\n        for (i; i < friendObject.length; i++) {\r\n            F.push([x - friendObject[i].x, y - friendObject[i].y]); //distance from mouse to actual object's x, y\r\n            //console.log(F);\r\n        }\r\n    }\r\n\r\n    let S = []; //previous coords\r\n    if (savedObjects !== null) {\r\n        let i = 0;\r\n        for (i; i < savedObjects.length; i++) {\r\n            S.push([x - savedObjects[i].x, y - savedObjects[i].y]);\r\n            //console.log(F);\r\n        }\r\n    }\r\n\r\n    if (selectedObject !== null) {\r\n        saveBlockStates(canvas, x, y);\r\n        // check the distance between the mouse and the object\r\n        let saveDisX = x - selectedObject.x;\r\n        let saveDisY = y - selectedObject.y;\r\n\r\n\r\n        canvasElement.onmousemove = function (e) { moveObject(e, selectedObject, friendObject, F, savedObjects, S, saveDisX, saveDisY, arrowsVert, arrowsHoriz, shiftDown) }\r\n    }\r\n\r\n}\r\n\r\nexport function onMouseLeave() {\r\n    canvasElement.onmousemove = {};\r\n    firstArrowJoint = true;\r\n    drawAll()\r\n}\r\n\r\n// moving objects in respect to cursor values saveDisX, saveDisY\r\n// friends = the smaller boxes that are connected to the bigger box\r\nfunction moveObject(e, object, friends, F, savedObjects = null, S, saveDisX, saveDisY, arrowsVert, arrowsHoriz, shiftDown) {\r\n    if (object != null) {\r\n        if (object.typeName === \"Vertex\") {\r\n            let position = getGraphXYFromMouseEvent(e);\r\n            let x = position[0] - saveDisX;\r\n            let y = position[1] - saveDisY;\r\n\r\n            //for loop iterate through all boxes assume they not empty\r\n            if (shiftDown) {\r\n                if (friends !== null) {\r\n                    let i = 0;\r\n                    //check friends' previous location and cursors location\r\n                    for (i; i < friends.length; i++) {\r\n                        friends[i].x = position[0] - F[i][0];\r\n                        friends[i].y = position[1] - F[i][1];\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (savedObjects !== null) {\r\n                let i = 0;\r\n                //check friends' previous location and cursors location\r\n                for (i; i < savedObjects.length; i++) {\r\n                    savedObjects[i].x = position[0] - S[i][0];\r\n                    savedObjects[i].y = position[1] - S[i][1];\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if (arrowsVert !== null) {\r\n                let conData = 0;\r\n                let j = 0;\r\n\r\n                for (j; j < arrowsVert.length; j++) {\r\n                    // source = one that's been clicked\r\n                    arrowsVert[j].path[1][0] = arrowsVert[j].path[0][0];\r\n                    conData = getConnectionDataForArrow(arrowsVert[j].path[1][0], arrowsVert[j].path[1][1]);\r\n\r\n\r\n\r\n                    if (conData['nearest'] !== null) {\r\n\r\n                        arrowsVert[j].pathData[1] = conData['nearest'];\r\n                        StickArrowToObject(conData, arrowsVert[j], 0);\r\n                        //console.log(arrowsVert[j].path);\r\n                    } else {\r\n                        //delete arrow                        \r\n                        deleteElement(arrowsVert[j]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (arrowsHoriz !== null) {\r\n                let conData = 0;\r\n                let k = 0;\r\n                for (k; k < arrowsHoriz.length; k++) {\r\n                    // source = one that's been clicked\r\n                    arrowsHoriz[k].path[1][1] = arrowsHoriz[k].path[0][1];\r\n                    conData = getConnectionDataForArrow(arrowsHoriz[k].path[1][0], arrowsHoriz[k].path[1][1]);\r\n\r\n                    if (conData['nearest'] !== null) {\r\n\r\n                        arrowsHoriz[k].pathData[1] = conData['nearest'];\r\n                        StickArrowToObject(conData, arrowsHoriz[k], 0);\r\n                        //console.log(arrowsHoriz[k].path);\r\n                    } else {\r\n                        //delete arrow\r\n                        deleteElement(arrowsHoriz[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            object.x = x;\r\n            object.y = y;\r\n\r\n            updateArrows();\r\n\r\n\r\n        } else if (object.typeName === \"Arrow\") {\r\n            return;\r\n\r\n        }\r\n    }\r\n}\r\nexport function updateArrows() {\r\n    let flattenedObjects = currentObjects.flatten();\r\n    flattenedObjects.forEach((item) => {\r\n        if (item !== null) {\r\n            if (item.typeName === \"Arrow\") {\r\n                item.rebuildPath();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function solidifyObject() {\r\n    canvasElement.onmousemove = null;\r\n}\r\n\r\n// Zoom and pan\r\nexport function setZoom(newZoom) {\r\n    zoom = newZoom;\r\n\r\n    resetMouseOrigin();\r\n\r\n    drawAll();\r\n}\r\n\r\n// Useful for debugging\r\nexport function drawMarker(xpos, ypos) {\r\n    const radius = 2;\r\n    const lineWidth = 0.5;\r\n    const strokeColour = \"#007ACC\";\r\n    const fillColour = \"#007ACC55\";\r\n\r\n    let oldLineWidth = canvasContext.lineWidth;\r\n    canvasContext.lineWidth = lineWidth;\r\n    let oldStrokeStyle = canvasContext.strokeStyle;\r\n    canvasContext.strokeStyle = strokeColour;\r\n    let oldFillStyle = canvasContext.fillStyle;\r\n    canvasContext.fillStyle = fillColour;\r\n\r\n    canvasContext.globalAlpha = 1.0;\r\n    canvasContext.beginPath();\r\n    canvasContext.arc(xpos, ypos, radius, 0, Math.PI * 2, false);\r\n    canvasContext.fill();\r\n    canvasContext.stroke();\r\n    canvasContext.closePath();\r\n\r\n    canvasContext.lineWidth = oldLineWidth;\r\n    canvasContext.strokeStyle = oldStrokeStyle;\r\n    canvasContext.fillStyle = oldFillStyle;\r\n}\r\n\r\n// Gets the distance between x1, y1 and x2, y2\r\nexport function getDistance(x1, y1, x2, y2) {\r\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n}\r\n\r\n// Finds the object that is intersected with the cursor, returns null if no objects are intersected\r\nexport function findIntersected(x, y) {\r\n    let selectedItem = null;\r\n    currentObjects.flatten().forEach((item) => {\r\n        if (item !== null) {\r\n            if (item.intersects(x, y)) {\r\n                //console.log(\"Intersection detected with \", item.typeName);\r\n                selectedItem = item;\r\n            }\r\n        }\r\n    });\r\n    return selectedItem;\r\n}\r\n\r\nfunction createArtifact(canvas, x1, y1) {\r\n    let newPath;\r\n    let currentObjectsFlattened = currentObjects.flatten();\r\n\r\n    if (canvas.tool === Tool.Artifact) {\r\n        // Get positions\r\n        let pos = orderCoordinates(x1, y1, x1 + 450, y1 + 50);\r\n        let vy1 = findNearestGridY(pos[1], 0);\r\n        let vy2 = findNearestGridY(pos[3], 0);\r\n\r\n        // Add vertex\r\n        return new Vertex(\"\", [\"\"], pos[0], findNearestGridY(y1, 1), pos[2] - pos[0], vy2 - vy1);\r\n\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction createContainer(canvas, x1, y1) {\r\n    let newPath;\r\n    let currentObjectsFlattened = currentObjects.flatten();\r\n\r\n    if (canvas.tool === Tool.Container) {\r\n        // Get positions\r\n        let pos = orderCoordinates(x1, y1, x1 + 100, y1 + 60);\r\n        let vy1 = findNearestGridY(pos[1], 0);\r\n        let vy2 = findNearestGridY(pos[3], 0);\r\n\r\n        // Add Container\r\n        let newVert =  new Vertex(\"new Container\", [\"\"], pos[0], findNearestGridY(y1, 1), pos[2] - pos[0], vy2 - vy1);\r\n        newVert.setIsContainer(true);\r\n        return newVert;\r\n\r\n    }\r\n    return null;\r\n}\r\n\r\n//Links the container with the mirrorSemantic to the container with the Base (Mirror becomes base)\r\n\r\nexport function linkContainer(baseUUID,mirrorUUID){\r\n    let baseSemantic = null;\r\n    console.log(currentObjects.rootVertices) \r\n    //Since rootvertices was made as a set, cant just find indexes to reference, have to keep for looping to what we want\r\n    for(let i of currentObjects.rootVertices){\r\n        if(i.vertex.semanticIdentity.UUID === baseUUID){\r\n            baseSemantic = i;\r\n            break\r\n        }\r\n    }\r\n    for(let i of currentObjects.rootVertices){\r\n        if(i.vertex.semanticIdentity.UUID === mirrorUUID){\r\n            i.vertex.semanticIdentity = baseSemantic.vertex.semanticIdentity;\r\n            break\r\n        }\r\n    }\r\n    for(let i of currentObjects.rootVertices){\r\n        if(i.vertex.semanticIdentity.UUID === baseUUID){\r\n            updateLinkedContainers(baseSemantic.vertex);\r\n        }\r\n    }\r\n\r\n    console.log(currentObjects.rootVertices)\r\n\r\n}\r\n//Updates the appearances of linked containers to match the input container\r\n//Without a source container or doing a general scan, containers would be matched to copy the first vertex in the set, not the one that most recently changed\r\nexport function updateLinkedContainers(inputContainer){\r\n    for(let i of currentObjects.rootVertices){\r\n        if(inputContainer.semanticIdentity.UUID === i.vertex.semanticIdentity.UUID){\r\n            i.vertex.title = inputContainer.title\r\n            i.vertex.content = inputContainer.content\r\n            i.vertex.icons = inputContainer.icons\r\n            i.vertex.colour = inputContainer.colour\r\n            i.vertex.imageElements = inputContainer.imageElements\r\n            i.vertex.fontSize = inputContainer.fontSize\r\n        }\r\n    }\r\n    drawAll()\r\n}\r\n\r\n//Function for creating a vertex object without the left menu tools - Lachlan\r\nexport function createVertex(x1, y1, width, height,name,content,colour,icons,imageElements,fontSize,semanticIdentity){\r\n\r\n    return new Vertex(name, content, colour, x1, findNearestGridY(y1, 1), width, height,semanticIdentity);\r\n\r\n}\r\n\r\nexport function updateVertex(selectedObject){ // function to update the data of the contaimnment tree object and all other objects sharing the semantic- cooper\r\n    let vertex = getLinkedVertex(selectedObject); // 'vertex' refers to the treeview object.\r\n\r\n    vertex.text = selectedObject.title + \" \";\r\n    vertex.content = selectedObject.content;\r\n    vertex.width = selectedObject.width;\r\n    vertex.height = selectedObject.height;\r\n\r\n    if(vertex.parentRenderKey === selectedObject.vertexRenderKey){\r\n        console.log(vertex)\r\n        console.log(selectedObject)\r\n    }\r\n    else{\r\n        \r\n    }\r\n\r\n\r\n    for(let verticies of currentObjects.flatten()){\r\n        if(vertex.semanticIdentity.UUID === verticies.originalUUID && verticies !== selectedObject){ // updates all of the canvas objects that come from the treeview object.\r\n\r\n            //check if This graph vertex is in a different folder to the base vertex, if so make it white and add location\r\n            //console.log(vertex.parentRenderKey)\r\n            //console.log(verticies.vertexRenderKey)\r\n\r\n            if(vertex.parentRenderKey === verticies.vertexRenderKey){\r\n                \r\n            //If the vertex's model is in same folder\r\n            verticies.title = vertex.text.replace(\" \", \"\")\r\n            verticies.colour = vertex.colour;\r\n            verticies.content = vertex.content;\r\n            }\r\n            else{\r\n            verticies.title = vertex.text.replace(\" \", \"\")\r\n            verticies.colour = \"#FFFFFF\";\r\n            verticies.content = vertex.content;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function getLinkedVertex(selectedObject){ // grabs the contaiment tree object - cooper\r\n    for(let vertex of vertexData){\r\n        if(vertex.semanticIdentity.UUID === selectedObject.originalUUID)\r\n        return vertex;\r\n    }\r\n}\r\n\r\nfunction createObject(canvas, x1, y1, x2, y2) {\r\n    let newPath;\r\n    let currentObjectsFlattened = currentObjects.flatten();\r\n\r\n    if (canvas.tool === \"Vertex\") {\r\n        // Get positions\r\n        let pos = orderCoordinates(x1, y1, x2 + 10, y2);\r\n        let vy1 = findNearestGridY(pos[1], 0);\r\n        let vy2 = findNearestGridY(pos[3], 0);\r\n\r\n        // Add vertex\r\n        return new Vertex(\"\", [\"\"], pos[0], findNearestGridY(y1, 1), pos[2] - pos[0], vy2 - vy1);\r\n\r\n    } else if (arrowToolSelected()) {\r\n        // Generate path\r\n\r\n        newPath = arrowPath.concat([getConnectionDataForArrow(x2, y2).coord]);\r\n\r\n        // Check if first path connects to a vertex, and ignore if it doesn't\r\n        // Should be 0 if the connectable connects to a vertex\r\n        //\r\n        //\r\n        //because createObject is always running when moving mouse\r\n        //\r\n        // if current mouse pos is not over a box, don't create arrow\r\n        // if removed here, it is still removed in another function \r\n        //let intersection = findIntersected(x2, y2);\r\n        if (newPath[0][0] !== 0) {\r\n            return null;\r\n        }\r\n\r\n        // Create arrow\r\n        \r\n        let arrow = new Arrow(currentObjectsFlattened, newPath, arrowType);\r\n        arrow.rebuildPath(currentObjectsFlattened);\r\n        return arrow;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function getGraphXYFromMouseEvent(e) {\r\n    resetMouseOrigin();\r\n\r\n    let x = (e.clientX - mouseOriginX) / getEffectiveZoom();\r\n    let y = (e.clientY - mouseOriginY) / getEffectiveZoom();\r\n\r\n    return [x, y];\r\n}\r\n\r\nexport function getDownload() {\r\n\r\n    let DLelement = document.createElement(\"a\");\r\n    DLelement.href = canvasElement.toDataURL(\"image/png\").replace(/^data:image\\/[^;]/, 'data:application/octet-stream');\r\n    DLelement.download = \"Graph.png\";\r\n    document.body.appendChild(DLelement);\r\n    DLelement.click();\r\n\r\n}\r\n\r\nfunction orderCoordinates(sx, sy, ex, ey) {\r\n    // This code also ensures x1 < x2 and y1 < y2\r\n    let x1 = Math.min(sx, ex);\r\n    let y1 = Math.min(sy, ey);\r\n    let x2 = Math.max(sx, ex);\r\n    let y2 = Math.max(sy, ey);\r\n\r\n    return [x1, y1, x2, y2];\r\n}\r\n\r\n// Gets the effective (percentage) zoom from the current zoom\r\nfunction getEffectiveZoom() {\r\n    return zoom / 100;\r\n}\r\n\r\n// This should be used whenever the window itself resizes\r\nfunction recalculateScale() {\r\n    // Adjusts the aspect ratio so it is 1:1 instead of matching the windows.\r\n    // Also removes blurry rendering\r\n    //let dpi = window.devicePixelRatio;\r\n    let canvasContainer = document.getElementsByClassName(\"Canvas\")[0];\r\n    let styleHeight = +getComputedStyle(canvasContainer).getPropertyValue(\"height\").slice(0, -2);\r\n    let styleWidth = +getComputedStyle(canvasContainer).getPropertyValue(\"width\").slice(0, -2);\r\n\r\n    canvasElement.setAttribute('height', styleHeight * getEffectiveZoom());\r\n    canvasElement.setAttribute('width', styleWidth * getEffectiveZoom());\r\n\r\n    // Configurable\r\n    canvasWidth = canvasElement.width;\r\n    canvasHeight = canvasElement.height;\r\n}\r\n\r\nfunction clearCanvas() {\r\n    // Fill base canvas\r\n    canvasContext.fillStyle = \"#ffffff\";\r\n    canvasContext.fillRect(0, 0, canvasWidth, canvasHeight);\r\n}\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport { SemanticIdentity } from \"./SemanticIdentity\";\r\nimport {drawMarker, getDistance, getCurrentRenderKey} from \"../UIElements/CanvasDraw\";\r\nimport {getModelRenderKey} from \"../UIElements/ContainmentTree\";\r\nimport * as ArrowProps from \"./ArrowProperties\";\r\nimport { EdgeEnd } from \"./EdgeEnd\";\r\nimport {Tool} from \"../UIElements/LeftMenu\";\r\nimport * as canvasDraw from \"../UIElements/CanvasDraw\"\r\n\r\nexport class Arrow {\r\n    // Connects an arrow fromVertex to toVertex\r\n    // pathData is an array of objects that can either be a:\r\n    //      0) Vertex Data\r\n    //         [0, UUID, xPercentage, yPercentage]\r\n    //         The Percentage data is the relative percentage\r\n    //              e.g. 0,0 represents top left, 1,1 bottom right etc\r\n    //      1) Array containing an x and y element\r\n    //         [1, x, y]\r\n    constructor(objectsList, pathData, type, semanticIdentity) {\r\n        this.typeName = \"Arrow\";\r\n\r\n        if (semanticIdentity !== undefined || objectsList === null){\r\n            this.semanticIdentity = semanticIdentity;\r\n        } else {\r\n            if (objectsList.length > 1) {\r\n                this.semanticIdentity = new SemanticIdentity(\"Arrow from \" + objectsList[0].semanticIdentity.UUID + \" to \" + objectsList[1].semanticIdentity.UUID, \"\", \"\", \"\", undefined, []);\r\n            } else if (objectsList.length === 1) {\r\n                this.semanticIdentity = new SemanticIdentity(\"Arrow connecting \" + objectsList[0].semanticIdentity.UUID, \"\", \"\", \"\", undefined, []);\r\n            } else {\r\n                this.semanticIdentity = new SemanticIdentity(\"Arrow connecting 1 or less vertices\", \"\", \"\", \"\", undefined, []);\r\n            }\r\n        }\r\n\r\n        this.sourceEdgeEnd = new EdgeEnd(this.semanticIdentity.UUID);\r\n        this.destEdgeEnd = new EdgeEnd(this.semanticIdentity.UUID);\r\n\r\n        // Ensure there are at least 2 points\r\n        if (pathData.length === 1) pathData.push(pathData[0]);\r\n        // Save pathData for later\r\n        this.pathData = pathData;\r\n\r\n        this.sourceVertexUUID = null;\r\n        this.destVertexUUID = null;\r\n        this.updateAttachedVertices();\r\n\r\n        // Construct Path\r\n        this.rebuildPath();\r\n        \r\n        // Type\r\n\r\n        this.lineColour = ArrowProps.LineColour.BLACK;\r\n        this.lineType = ArrowProps.LineType.SOLID;\r\n\r\n        if (type === Tool.Edge || type === Tool.Specialisation || type === Tool.Visibility) {\r\n            this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.NONE\r\n        }else{\r\n            console.log(\"Failed to find correct tool\");\r\n            this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.NONE\r\n        }\r\n\r\n        if (type === Tool.Edge) {\r\n            this.destEdgeEnd.type = ArrowProps.EdgeEnd.NONE\r\n            this.typeName = \"Arrow\";\r\n        }else if (type === Tool.Specialisation){\r\n            this.destEdgeEnd.type = ArrowProps.EdgeEnd.TRIANGLE\r\n            this.typeName = \"Specialisation\";\r\n        }else if (type === Tool.Visibility){\r\n            this.destEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n            this.lineType = ArrowProps.LineType.DASHED\r\n            this.typeName = \"Visibility\";\r\n        }else{\r\n            console.log(\"Failed to find correct tool\");\r\n            this.destEdgeEnd.type = ArrowProps.EdgeEnd.NONE\r\n        }\r\n\r\n        this.edgeType = type;\r\n\r\n        this.selected = false;\r\n\r\n        this.sourceIsNavigable = false;\r\n        this.destIsNavigable = false;\r\n        this.sourceIsAggregation = false;\r\n        this.destIsAggregation = false;\r\n\r\n        // Model key for rendering\r\n        this.arrowModelKey = canvasDraw.getCurrentModel();\r\n\r\n        // Render key for the arrow for placing in tree\r\n        this.arrowRenderKey = getModelRenderKey(this.arrowModelKey);\r\n    }\r\n\r\n    // Set the model key\r\n    setModelKey(key){\r\n        this.arrowModelKey = key;\r\n    }\r\n\r\n    getModelKey(){\r\n        return this.arrowModelKey;\r\n    }\r\n\r\n    // Set the render key. This is done in ContainmentTree.js\r\n    setRenderKey(key){\r\n        this.arrowRenderKey = key;\r\n    }\r\n\r\n    // Return the render key. This is called in CanvasDraw\r\n    getRenderKey(){\r\n        return this.arrowRenderKey;\r\n    }\r\n\r\n    toggleNavigable(side){\r\n        if(side === 0) {\r\n            this.sourceIsNavigable = !this.sourceIsNavigable;\r\n        }else if(side === 1){\r\n            this.destIsNavigable = !this.destIsNavigable;\r\n        }\r\n        if(this.sourceIsAggregation){\r\n            this.sourceIsNavigable = true;\r\n        }\r\n        if(this.destIsAggregation){\r\n            this.destIsNavigable = true;\r\n        }\r\n\r\n        if(this.sourceIsNavigable && this.destIsNavigable){\r\n            if(this.sourceIsAggregation){\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.FILLED_DIAMOND;\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n            }\r\n            else if(this.destIsAggregation){\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.FILLED_DIAMOND;\r\n            }else{\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n            }\r\n        }else if(this.sourceIsNavigable){\r\n            if(this.sourceIsAggregation){\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.FILLED_DIAMOND;\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.NONE;\r\n            }else {\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.NONE;\r\n            }\r\n        }else if(this.destIsNavigable){\r\n            if(this.destIsAggregation){\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.FILLED_DIAMOND;\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.NONE;\r\n            }else {\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.NONE;\r\n            }\r\n        }else{\r\n            this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.NONE;\r\n            this.destEdgeEnd.type = ArrowProps.EdgeEnd.NONE;\r\n        }\r\n\r\n    }\r\n\r\n    toggleAggregation(side){\r\n        if(side === 0){\r\n            this.sourceIsAggregation = !this.sourceIsAggregation;\r\n            if(this.destIsAggregation && this.sourceIsAggregation){\r\n                this.destIsAggregation = false;\r\n            }\r\n        }else{\r\n            this.destIsAggregation = !this.destIsAggregation;\r\n            if(this.destIsAggregation && this.sourceIsAggregation){\r\n                this.sourceIsAggregation = false;\r\n            }\r\n        }\r\n\r\n\r\n        if(this.sourceIsAggregation) {\r\n            this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.FILLED_DIAMOND;\r\n            if(this.destIsNavigable){\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n            }else{\r\n                this.destEdgeEnd.type = ArrowProps.EdgeEnd.NONE\r\n            }\r\n        }else if(this.destIsAggregation){\r\n            this.destEdgeEnd.type = ArrowProps.EdgeEnd.FILLED_DIAMOND;\r\n            if(this.sourceIsNavigable){\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.ARROW;\r\n            }else{\r\n                this.sourceEdgeEnd.type = ArrowProps.EdgeEnd.NONE\r\n            }\r\n        }else{\r\n            // this updates the arrow heads so they are correct\r\n            this.toggleNavigable(100)\r\n        }\r\n    }\r\n\r\n    getNavigable(side){\r\n        if(side === 0){\r\n            return this.sourceIsNavigable;\r\n        }else{\r\n            return this.destIsNavigable;\r\n        }\r\n\r\n    }\r\n\r\n    getAggregation(side){\r\n        if(side === 0){\r\n            return this.sourceIsAggregation\r\n        }else{\r\n            return this.destIsAggregation\r\n        }\r\n\r\n    }\r\n\r\n    trimPath(){\r\n        this.pathData = [this.pathData[0], this.pathData[this.pathData.length-1]];\r\n        this.path = [this.path[0], this.path[this.path.length-1]];\r\n    }\r\n\r\n    // Rebuilds path from cached pathData\r\n    rebuildPath() {\r\n\r\n        let connectedObjectUUIDs = this.getObjectUUIDList();\r\n        let objects = [];\r\n\r\n        connectedObjectUUIDs.forEach((UUID) => {\r\n            objects.push(canvasDraw.getObjectFromUUID(UUID))\r\n        });\r\n\r\n        // X, Y data for path\r\n        this.path = [];\r\n\r\n        for (let i = 0; i < this.pathData.length; i++) {\r\n            // Check if its case 0 or 1\r\n            let pathItem = this.pathData[i];\r\n\r\n            //If the first element of a PathItem is 0, the second element contains the UUID of an object\r\n            if (pathItem[0] === 0) {\r\n                this.path.push(this.getZerothCasePathItem(objects, pathItem));\r\n            }\r\n            //If the first element is 1, the next two elements are the X and Y points, respectively\r\n            else if (pathItem[0] === 1) {\r\n                this.path.push([pathItem[1], pathItem[2]]);\r\n            } else {\r\n                console.error(\"Invalid PathData case, wrong case\", pathItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Gets pathItem from object (hopefully a vertex) based on UUID\r\n    // will come back to this to sort out arrows overlapping on creation\r\n    // for extra clarity pathItem[2] is where the arrow from/end is on the x axis of the vertex(0..1)\r\n    // and pathItem[3] is where the arrow is from/end is on the y axis of the vertex(0..1) - cooper\r\n    getZerothCasePathItem(objects, pathItem) {\r\n        for (let i = 0; i < objects.length; i++) {\r\n           // if(objects[0].semanticIdentity.UUID === objects[1].semanticIdentity.UUID){\r\n\r\n           // }\r\n            if (objects[i] !== null && objects[i] !== undefined) {\r\n                if (objects[i].semanticIdentity.UUID === pathItem[1]) {\r\n                    let x = pathItem[2]*objects[i].width + objects[i].x;\r\n                    let y = pathItem[3]*objects[i].realHeight + objects[i].y;\r\n                    return [x, y]\r\n                }\r\n            }\r\n        }\r\n\r\n        console.error(\"Could not find vertex to connect for pathItem\", pathItem);\r\n        return null;\r\n    }\r\n\r\n    getObjectUUIDList(){\r\n        let output = [];\r\n            this.pathData.forEach((item) => {\r\n                let index = this.pathData.indexOf(item);\r\n                if(item == null){\r\n                    this.pathData[index] = [1,this.path[index][0],this.path[index][1]]\r\n                }\r\n                if (this.pathData[index][0] === 0) {\r\n                    output.push(item[1])\r\n                }\r\n            });\r\n        return output\r\n    }\r\n\r\n    updateAttachedVertices() {\r\n        var pathStart = this.pathData[0];\r\n        var pathEnd = this.pathData[this.pathData.length - 1];\r\n\r\n        if (pathStart[0] === 0) {\r\n            this.sourceVertexUUID = pathStart[1];\r\n        } else {\r\n            this.sourceVertexUUID = null;\r\n        }\r\n\r\n        if (pathEnd[0] === 0) {\r\n            this.destVertexUUID = pathEnd[1];\r\n        } else {\r\n            this.destVertexUUID = null;\r\n        }\r\n    }\r\n\r\n    setSelected(selected) {\r\n        this.selected = selected;\r\n    }\r\n\r\n    updateSourceCardinality(lowerBound, upperBound, visibility) {\r\n        this.sourceEdgeEnd.updateCardinality(lowerBound, upperBound, visibility);\r\n    }\r\n\r\n    getSourceCardinalityVisibility() {\r\n        return this.sourceEdgeEnd.cardinality.isVisible;\r\n    }\r\n\r\n    toggleSourceCardinalityVisibility() {\r\n        this.sourceEdgeEnd.cardinality.toggleVisibility();\r\n    }\r\n\r\n    getSourceCardinalityLowerBound() {\r\n        return this.sourceEdgeEnd.cardinality.lowerBound;\r\n    }\r\n\r\n    getSourceCardinalityUpperBound() {\r\n        return this.sourceEdgeEnd.cardinality.upperBound;\r\n    }\r\n\r\n    updateDestCardinality(lowerBound, upperBound, visibility) {\r\n        this.destEdgeEnd.updateCardinality(lowerBound, upperBound, visibility);\r\n    }\r\n\r\n    getDestCardinalityVisibility() {\r\n        return this.destEdgeEnd.cardinality.isVisible;\r\n    }\r\n\r\n    toggleDestCardinalityVisibility() {\r\n        this.destEdgeEnd.cardinality.toggleVisibility();\r\n    }\r\n\r\n    getDestCardinalityLowerBound() {\r\n        return this.destEdgeEnd.cardinality.lowerBound;\r\n    }\r\n\r\n    getDestCardinalityUpperBound() {\r\n        return this.destEdgeEnd.cardinality.upperBound;\r\n    }\r\n\r\n    setStartLabel(label) {\r\n        this.sourceEdgeEnd.label = label;\r\n    }\r\n\r\n    setEndLabel(label) {\r\n        this.destEdgeEnd.label = label;\r\n    }\r\n\r\n    setLineColour(lineColour) {\r\n        let val = ArrowProps.StringNameToLineColour[lineColour];\r\n        if (val !== undefined) {\r\n            this.lineColour = val;\r\n        } else {\r\n            console.log(\"Attempted to assign invalid lineColour: %s\", lineColour);\r\n        }\r\n    }\r\n\r\n    setLineType(lineType) {\r\n        let val = ArrowProps.StringToLineType[lineType];\r\n        if (val !== undefined) {\r\n            this.lineType = val;\r\n        } else {\r\n            console.log(\"Attempted to assign invalid lineType: %s\", lineType);\r\n        }\r\n    }\r\n\r\n    // Creates nodes for an algorithmn to path find around a vertex\r\n    createPathNodesForVertex(vertex, nodeIndex, d) {\r\n        // Set ids\r\n        let topLeft     = nodeIndex++;\r\n        let top         = nodeIndex++;\r\n        let topRight    = nodeIndex++;\r\n        let right       = nodeIndex++;\r\n        let bottomRight = nodeIndex++;\r\n        let bottom      = nodeIndex++;\r\n        let bottomLeft  = nodeIndex++;\r\n        let left        = nodeIndex++;\r\n\r\n        // Create nodes for: fromVertex\r\n        let vertexNodes = [];\r\n        vertexNodes.push([topLeft,     vertex.x-d,              vertex.y+vertex.height+d, [left, top]]);               // Top    Left\r\n        vertexNodes.push([top,         vertex.x+vertex.width/2, vertex.y+vertex.height+d, [topLeft, topRight]]);       // Top\r\n        vertexNodes.push([topRight,    vertex.x+vertex.width+d, vertex.y+vertex.height+d, [top, right]]);              // Top    Right\r\n        vertexNodes.push([right,       vertex.x+vertex.width+d, vertex.y+vertex.height/2, [topRight, bottomRight]]);   //        Right\r\n        vertexNodes.push([bottomRight, vertex.x+vertex.width+d, vertex.y-d,               [right, bottom]]);           // Bottom Right\r\n        vertexNodes.push([bottom,      vertex.x+vertex.width/2, vertex.y-d,               [bottomRight, bottomLeft]]); // Bottom\r\n        vertexNodes.push([bottomLeft,  vertex.x-d,              vertex.y-d,               [bottomRight, left]]);       // Bottom Left\r\n        vertexNodes.push([left,        vertex.x-d,              vertex.y+vertex.height/2, [bottomLeft, topLeft]]);     //        Left\r\n        return [nodeIndex, vertexNodes];\r\n    }\r\n\r\n    drawStartHead(canvasContext) {\r\n        let lineAngle = Math.atan2(this.getSY() - this.getNSY(), this.getSX() - this.getNSX());\r\n        this.sourceEdgeEnd.draw(canvasContext, this.getSX(), this.getSY(), lineAngle, this.lineColour);\r\n    }\r\n\r\n    drawEndHead(canvasContext) {\r\n        let lineAngle = Math.atan2(this.getEY() - this.getNEY(), this.getEX() - this.getNEX());\r\n        this.destEdgeEnd.draw(canvasContext, this.getEX(), this.getEY(), lineAngle, this.lineColour);\r\n    }\r\n\r\n    isPathSegmentLR(startIndex,endIndex){\r\n        let indexSx = this.path[startIndex][0];\r\n        let indexEx = this.path[endIndex][0];\r\n        let indexSy = this.path[startIndex][1];\r\n        let indexEy = this.path[endIndex][1];\r\n\r\n        return Math.abs(indexSx-indexEx) > Math.abs(indexSy-indexEy)\r\n    }\r\n\r\n    getTextOffsets(canvasContext, sourceText, destText, sourceCtext, destCtext) {\r\n        let sourceTextWidth = canvasContext.measureText(sourceText).width;\r\n        let destTextWidth = canvasContext.measureText(destText).width;\r\n        let sourceCtextWidth = canvasContext.measureText(sourceCtext).width;\r\n        let destCtextWidth = canvasContext.measureText(destCtext).width;\r\n        let textHeight = 15;\r\n        // 'M' is the widest possible character\r\n        let charWidth = canvasContext.measureText(\"M\").width;\r\n\r\n        let sxOffset;\r\n        let syOffset;\r\n        let exOffset;\r\n        let eyOffset;\r\n\r\n        let sxOffsetc;\r\n        let syOffsetc;\r\n        let exOffsetc;\r\n        let eyOffsetc;\r\n\r\n        let sxFlip = true;\r\n        let syFlip = true;\r\n        let exFlip = true;\r\n        let eyFlip = true;\r\n\r\n        // true if arrow is landscape, false if arrow is portrait;\r\n        let E1index = this.path.length-2;\r\n        let E2index = this.path.length-1;\r\n\r\n        let startLRArrow = this.isPathSegmentLR(0,1);\r\n        let endLRArrow = this.isPathSegmentLR(E1index,E2index);\r\n\r\n        let SSX = this.path[0][0];\r\n        let SSY = this.path[0][1];\r\n        let SEX = this.path[1][0];\r\n        let SEY = this.path[1][1];\r\n\r\n        let ESX = this.path[E1index][0];\r\n        let ESY = this.path[E1index][1];\r\n        let EEX = this.path[E2index][0];\r\n        let EEY = this.path[E2index][1];\r\n\r\n        if (startLRArrow) {\r\n            if (SSX > SEX) {\r\n                sxFlip = !sxFlip;\r\n            }\r\n        } else {\r\n            if (SSY > SEY) {\r\n                syFlip = !syFlip;\r\n            }\r\n        }\r\n\r\n        if (endLRArrow) {\r\n            if (ESX > EEX) {\r\n                exFlip = !exFlip;\r\n            }\r\n        } else {\r\n            if (ESY > EEY) {\r\n                eyFlip = !eyFlip;\r\n            }\r\n        }\r\n\r\n\r\n        if (sxFlip) {\r\n            sxOffset = charWidth/2;\r\n            if (startLRArrow) {\r\n                sxOffsetc = charWidth/2;\r\n            } else {\r\n                sxOffsetc = -1*(sourceCtextWidth+charWidth/2)\r\n            }\r\n        } else {\r\n            sxOffset = -1*(sourceTextWidth+charWidth/2);\r\n            if (startLRArrow) {\r\n                sxOffsetc = -1*(sourceCtextWidth+charWidth/2)\r\n            } else {\r\n                sxOffsetc = charWidth/2;\r\n            }\r\n        }\r\n        \r\n\r\n        if (syFlip) {\r\n            syOffset = textHeight;\r\n            if (startLRArrow) {\r\n                syOffsetc = -1*(textHeight/2)\r\n            } else {\r\n                syOffsetc = syOffset;\r\n            }\r\n        } else {\r\n            syOffset = -1*(textHeight/2);\r\n            if (startLRArrow) {\r\n                syOffsetc = syOffset;\r\n            } else {\r\n                syOffsetc = -1*(textHeight/2)\r\n            }\r\n        }\r\n\r\n\r\n        //if true arrow moves more in x than in y\r\n        exFlip = !exFlip;\r\n        eyFlip = !eyFlip;\r\n\r\n        if (exFlip) {\r\n            exOffset = charWidth/2;\r\n            if (endLRArrow) {\r\n                exOffsetc = charWidth/2;\r\n            } else {\r\n                exOffsetc = -1*(destCtextWidth+charWidth/2)\r\n            }\r\n        } else {\r\n            exOffset = -1*(destTextWidth+charWidth/2);\r\n            if (endLRArrow) {\r\n                exOffsetc = -1*(destCtextWidth+charWidth/2)\r\n            } else {\r\n                exOffsetc = charWidth/2;\r\n            }\r\n        }\r\n\r\n\r\n        if (eyFlip) {\r\n            eyOffset = textHeight;\r\n            if (endLRArrow) {\r\n                eyOffsetc = -1*(textHeight/2);\r\n            } else {\r\n                eyOffsetc = eyOffset;\r\n            }\r\n        } else {\r\n            eyOffset = -1*(textHeight/2);\r\n            if (endLRArrow) {\r\n                eyOffsetc = textHeight;\r\n            } else {\r\n                eyOffsetc = eyOffset;\r\n            }\r\n        }\r\n\r\n\r\n        return [sxOffset,syOffset,exOffset,eyOffset,sxOffsetc,syOffsetc,exOffsetc,eyOffsetc]\r\n    }\r\n\r\n\r\n\r\n    drawLabelsAndCardinalities(canvasContext) {\r\n        let sourceCardText = this.sourceEdgeEnd.cardinality.toString();\r\n        let destCardText = this.destEdgeEnd.cardinality.toString();\r\n        let Offsets = this.getTextOffsets(canvasContext,this.sourceEdgeEnd.label,this.destEdgeEnd.label,sourceCardText,destCardText);\r\n\r\n        canvasContext.fillStyle = \"#000\";\r\n\r\n        //draw source text\r\n        canvasContext.fillText(this.sourceEdgeEnd.label, this.getSX() + Offsets[0], this.getSY() + Offsets[1]);\r\n\r\n        //draw destination text\r\n        canvasContext.fillText(this.destEdgeEnd.label, this.getEX() + Offsets[2], this.getEY() + Offsets[3]);\r\n\r\n        //draw source cardinality\r\n        if (this.getSourceCardinalityVisibility()) {\r\n            canvasContext.fillText(sourceCardText, this.getSX() + Offsets[4], this.getSY() + Offsets[5]);\r\n        }\r\n\r\n        //draw destination cardinality\r\n        if (this.getDestCardinalityVisibility()) {\r\n            canvasContext.fillText(destCardText, this.getEX() + Offsets[6], this.getEY() + Offsets[7]);\r\n        }\r\n    }\r\n\r\n    draw(canvasContext) {\r\n        let dashLength = 5;\r\n\r\n        switch (this.lineType) {\r\n            case ArrowProps.LineType.SOLID:\r\n                canvasContext.setLineDash([]);\r\n                break;\r\n            case ArrowProps.LineType.DASHED:\r\n                canvasContext.setLineDash([dashLength, dashLength]);\r\n                break;\r\n            default:\r\n                console.log(\"Arrow had invalid lineType: %s\", this.lineType);\r\n        }\r\n\r\n        // Draw\r\n        canvasContext.strokeStyle = this.lineColour;\r\n\r\n        // Draw Lines\r\n        for (let i = 0; i < this.path.length-1; i++) {\r\n            let from = this.path[i];\r\n            let to = this.path[i+1];\r\n\r\n            canvasContext.beginPath();\r\n            canvasContext.moveTo(from[0], from[1]);\r\n            canvasContext.lineTo(to[0], to[1]);\r\n            canvasContext.stroke();\r\n        }\r\n\r\n        canvasContext.strokeStyle = \"#000\";\r\n        canvasContext.setLineDash([]);\r\n\r\n        this.drawStartHead(canvasContext);\r\n        this.drawEndHead(canvasContext);\r\n        //store which labels were flipped and in which direction (x/y)\r\n        this.drawLabelsAndCardinalities(canvasContext);\r\n\r\n        if (this.selected) {\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                let pos = this.path[i];\r\n                drawMarker(pos[0], pos[1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    intersects(cx, cy) {\r\n        for (let i = 0; i < this.path.length-1; i++) {\r\n            let from = this.path[i];\r\n            let to = this.path[i+1];\r\n\r\n            if (this.intersectsSegment(cx, cy, from, to)) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Checks if it intersects with one of the line segments\r\n    intersectsSegment(cx, cy, from, to) {\r\n        let m = getDistance(cx, cy, from[0], from[1]);\r\n        let n = getDistance(cx, cy, to[0], to[1]);\r\n        let l = getDistance(from[0], from[1], to[0], to[1]);\r\n\r\n        let threshold = 1;\r\n\r\n        return (m+n-threshold < l);\r\n    }\r\n\r\n    // Get first x/y\r\n    getSX() {\r\n        return this.path[0][0];\r\n    }\r\n    getSY() {\r\n        return this.path[0][1];\r\n    }\r\n\r\n    // Get second x/y\r\n    getNSX() {\r\n        return this.path[1][0];\r\n    }\r\n    getNSY() {\r\n        return this.path[1][1];\r\n    }\r\n\r\n    // Get second last x/y\r\n    getNEX() {\r\n        let index = this.path.length-2;\r\n        if (index < 0) index = 0;\r\n        return this.path[index][0];\r\n    }\r\n    getNEY() {\r\n        let index = this.path.length-2;\r\n        if (index < 0) index = 0;\r\n        return this.path[index][1];\r\n    }\r\n\r\n    // Get last x/y\r\n    getEX() {\r\n        return this.path[this.path.length-1][0];\r\n    }\r\n    getEY() {\r\n        return this.path[this.path.length-1][1];\r\n    }\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport { CollectionsBookmarkOutlined, ContactSupportOutlined } from \"@material-ui/icons\";\r\nimport { currentObjects, getModelName, createVertex } from \"../UIElements/CanvasDraw\";\r\nimport {SemanticIdentity} from \"./SemanticIdentity\";\r\n\r\n\r\n\r\nexport class VertexNode {\r\n    constructor(vertex) {\r\n        this.vertex = vertex;\r\n        this.children = new Set();\r\n        this.typeName = \"VertexNode\";\r\n\r\n        //The path of this particular vertex node for displaying on the tree view element\r\n        this.cleanObjectPath = (getModelName(),\"/\",\"Vertices\")\r\n        this.vertexObjectPath = (getModelName(),\"/\",\"Vertices\")\r\n    }\r\n\r\n    add(node) {\r\n        this.children.add(node);\r\n    }\r\n\r\n    remove(traversedVertices, node) {\r\n        //onsole.log(\"remove is called\")\r\n        let isRemoved = false;\r\n        traversedVertices.add(this);\r\n\r\n        //Remove from the current vertex\r\n        isRemoved = this.children.has(node);\r\n        this.children.delete(node);\r\n\r\n        //Continue to remove from anywhere deeper in the tree\r\n        for (let child of this.children) {\r\n            if (!traversedVertices.has(child)) {\r\n                traversedVertices.add(child);\r\n                isRemoved = child.remove(traversedVertices, node);\r\n            }\r\n        }\r\n\r\n        return isRemoved;\r\n    }\r\n\r\n    getVertexNode(traversedVertices, vertex, recursive = true) {\r\n        for (let child of this.children) {\r\n            if (!traversedVertices.has(child)) {\r\n                traversedVertices.add(child);\r\n\r\n                if (child.vertex.semanticIdentity.UUID === vertex.semanticIdentity.UUID) {\r\n                    return child;\r\n                } else if (recursive) {\r\n                    let node = child.getVertexNode(traversedVertices, vertex);\r\n                    if (node !== null) {\r\n                        return node;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    //Remove from just the children of this object, without removing from deeper in the tree\r\n    removeFromChildren(node) {\r\n        if (this.children.has(node)) {\r\n            this.children.delete(node);\r\n            return true;\r\n\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    flatten(traversedVertices) {\r\n        var flattenedArray = [];\r\n\r\n        for (let childNode of this.children) {\r\n            if (!traversedVertices.has(childNode)) {\r\n                traversedVertices.add(childNode);\r\n                flattenedArray.push(childNode.vertex);\r\n\r\n                if (childNode !== null) {\r\n                    flattenedArray.push(...childNode.flatten(traversedVertices));\r\n                }\r\n            }\r\n        }\r\n\r\n        return flattenedArray;\r\n    }\r\n\r\n    flattenVertexNodes(traversedVertices) {\r\n        var flattenedArray = [];\r\n\r\n        for (let childNode of this.children) {\r\n            if (!traversedVertices.has(childNode)) {\r\n                traversedVertices.add(childNode);\r\n                flattenedArray.push(childNode);\r\n\r\n                if (childNode !== null) {\r\n                    flattenedArray.push(...childNode.flattenVertexNodes(traversedVertices));\r\n                }\r\n            }\r\n        }\r\n\r\n        return flattenedArray;\r\n    }\r\n\r\n    has(traversedVertices, node) {\r\n        //Search for object in children\r\n        if (this.children.has(node)) {\r\n            return true;\r\n\r\n        } else {\r\n\r\n            //Search for object in children of children\r\n            for (let child of this.children) {\r\n                if (!traversedVertices.has(child)) {\r\n                    traversedVertices.add(child);\r\n                    if (child.has(traversedVertices, node)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    toTreeViewElement(returnOption, parsedRenderKey) { //added the model key parameter to we can specifiy what models vertexes belong to\r\n        //console.log(\"toTreeViewElement called successfully\")\r\n        //Pretty much everything that's currently on the canvas is searched and then converted into the tree appropriate struct in the below if else statements.\r\n        //Then, the vertices and arrows folder nodes can display their appropriate children.\r\n        let ArrowChildren = [];\r\n        let VertexChildren = [];\r\n    \r\n\r\n        //These are no longer needed due to rework of assigning model children - Lachlan\r\n        /*\r\n        let verticies = []; // need to store the 'verticies folder' in an array for it to be iterable in a for loop - cooper\r\n        let arrows = []; // same issue as vertices not being iterable - Lachlan\r\n        */\r\n        \r\n\r\n\r\n        //Check which folder we're sticking these things into\r\n        if (returnOption === \"Vertex Folder\"){                  // they had a different spelling for vertex folder :DDDDD - cooper\r\n            //All objects currently on the canvas (excluding things like folders which only exist as tree view elements)\r\n            for(let i = 0; i < currentObjects.flatten().length; i++){\r\n                \r\n\r\n                //We onlt want the vertices in this folder\r\n                if (currentObjects.flatten()[i].typeName === \"Vertex\" && currentObjects.flatten()[i].getRenderKey() === parsedRenderKey){\r\n                    //Set the append the name of the path to include the vertex name\r\n                    if(currentObjects.flatten()[i].title === \"\"){\r\n                        this.setVertexTreePath(\"Unnamed Vertex\");\r\n                    }\r\n\r\n                    else{\r\n                        this.setVertexTreePath(currentObjects.flatten()[i].title);\r\n                    }\r\n                \r\n                \r\n\r\n\r\n                    //Create the appropriate struct for a tree view element from the vertex data\r\n                    let tempTreeObj = {\r\n                        text: currentObjects.flatten()[i].title,\r\n                        children: [],\r\n                        data: currentObjects.flatten()[i],\r\n                        renderkey: currentObjects.flatten()[i].getRenderKey(),\r\n                        modelkey: currentObjects.flatten()[i].getModelKey(),\r\n                        state: {opened: false}\r\n                    };\r\n\r\n                    //So you don't have vertices that are completely blank in the tree, looks kinda weird\r\n                    if (tempTreeObj.text === \"\"){\r\n                        tempTreeObj.text = \"Unnamed Vertex\";\r\n                    }\r\n                    \r\n                    //Finally, push to children. Makes it look like the following:\r\n                    //\r\n                    //  Vertex --+\r\n                    //           |\r\n                    //           +-- Unnamed Vertex   \r\n                    \r\n                    VertexChildren.push(tempTreeObj);\r\n\r\n                \r\n            }\r\n        }\r\n\r\n            return{\r\n                text: \"Vertices &#128193\",\r\n                children: VertexChildren,\r\n                data: null,\r\n                state: { opened: true },\r\n                type: \"Vertex Folder\"\r\n            }\r\n        }\r\n\r\n        //No longer necessary due to the rework of assigning model children - Lachlan\r\n            /*\r\n            let verticiesObject = { // push the vertex folder into an array of vertex folders - cooper\r\n                text: \"Vertices\",\r\n                children: VertexChildren,\r\n                data: null,\r\n                state: { opened: true },\r\n                type: \"Vertex Folder\"\r\n            }\r\n            verticies.push(verticiesObject)\r\n            //vertices folder\r\n            return verticies\r\n                \r\n            \r\n        }\r\n        */\r\n\r\n        //same typo as above if statement but for arrows\r\n        else if (returnOption === \"Arrow Folder\"){ //same thing but arrows folder - Lachlan\r\n            for(let i = 0; i < currentObjects.flatten().length; i++){\r\n\r\n                if (currentObjects.flatten()[i].typeName !== \"Vertex\" && currentObjects.flatten()[i].getRenderKey() === parsedRenderKey){\r\n                    //console.log(\"arrow key\")\r\n                    //console.log(currentObjects.flatten()[i].getModelKey())\r\n\r\n                        // Find the source and destination vertex as Keith defined in spec\r\n                        let ourSourceEnd = currentObjects.flatten()[i].pathData[1][1]\r\n                        let ourDestEnd = currentObjects.flatten()[i].pathData[0][1]\r\n\r\n                        let textSource = \"N/A\"\r\n                        let textDest = \"N/A\"\r\n                        let finalString = \"N/A\"\r\n\r\n                        // Looking through all of the current objects and matching the uuids\r\n                        for (let j = 0; j <currentObjects.flatten().length; j++){\r\n                        \r\n                            let someObject = currentObjects.flatten()[j]\r\n                            \r\n                            if (someObject.typeName === \"Vertex\"){\r\n                            \r\n                                if (ourSourceEnd === someObject.semanticIdentity.UUID){\r\n                                    \r\n                                    textDest = someObject.title\r\n                                }\r\n\r\n                                else if (ourDestEnd === someObject.semanticIdentity.UUID){\r\n                                    \r\n                                    textSource = someObject.title\r\n                                }\r\n                            }\r\n                            \r\n                        }\r\n\r\n                        //this array stores whether source/destination is Navigable/Aggregation so we can display the required icons in the tree\r\n                        //array is ordered source nav, dest nav, source agg, dest agg \r\n                        //if adding more properties, such ass a dotted arrow, just increase array size and adjust the if statements for constructing icon\r\n                        let treeAppearanceSwitches = [false,false,false,false]\r\n                        treeAppearanceSwitches[0] = currentObjects.flatten()[i].getNavigable(0)\r\n                        treeAppearanceSwitches[1] = currentObjects.flatten()[i].getNavigable(1)\r\n                        treeAppearanceSwitches[2] = currentObjects.flatten()[i].getAggregation(0)\r\n                        treeAppearanceSwitches[3] = currentObjects.flatten()[i].getAggregation(1)\r\n                        \r\n                        //unicode icon of the arrow properties/relations we want to display\r\n                        let arrowIcon = \"\";\r\n\r\n                        if(treeAppearanceSwitches[2] === true){\r\n                            arrowIcon = \"&#9670\"\r\n                            }\r\n                        else if(treeAppearanceSwitches[0] === true){\r\n                            arrowIcon = \"&#10229\"\r\n                        }\r\n\r\n                        arrowIcon += \"&#8213\"\r\n\r\n                        if(treeAppearanceSwitches[3] === true){\r\n                            arrowIcon += \"&#9670\"\r\n                            }\r\n                        else if(treeAppearanceSwitches[1] === true){\r\n                            arrowIcon += \"&#10230\"\r\n                        }\r\n\r\n                        finalString = textSource + \" \" + arrowIcon + \" \" + textDest\r\n\r\n                        let tempTreeObj = {\r\n                            text: currentObjects.flatten()[i].typeName + \" - \" + finalString,\r\n                            children: [],\r\n                            data: currentObjects.flatten()[i],\r\n                            renderkey: currentObjects.flatten()[i].getRenderKey(),\r\n                            modelkey: currentObjects.flatten()[i].getModelKey(),\r\n                            state: {opened: false}\r\n                        };\r\n\r\n                        ArrowChildren.push(tempTreeObj);\r\n                    \r\n                    \r\n                }\r\n\r\n            }\r\n\r\n            //console.log(ArrowChildren.length)\r\n\r\n            if(ArrowChildren.length === 0){\r\n                return;\r\n            }\r\n            else{\r\n            return {\r\n                text: \"Relations \",\r\n                children: ArrowChildren,\r\n                data: null,\r\n                state: { opened: true },\r\n                type: \"Arrow Folder\"\r\n            }\r\n        }\r\n            \r\n        }\r\n    \r\n\r\n        //No longer necessary due to the rework of assigning model children - Lachlan\r\n            /*\r\n            let arrowsObject = { //create the arrows folder as an object to push to the arrows array - Lachlan\r\n                text: \"Arrows\",\r\n                children: ArrowChildren,\r\n                data: null,\r\n                state: { opened: true },\r\n                type: \"Arrow Folder\"\r\n            }\r\n\r\n            arrows.push(arrowsObject)\r\n            //vertices folder\r\n            return arrows\r\n        }\r\n            */\r\n            \r\n        \r\n        //This down here is for vertex heirarchy stuff, not really needed anymore.\r\n        /*\r\n        if (!traversed) {\r\n            traversedVertices.add(this);\r\n            \r\n            for (let child of this.children) {\r\n                //children.push(child.toTreeViewElement(traversedVertices));\r\n            }\r\n            \r\n        }\r\n\r\n        let text = this.vertex.title;\r\n\r\n        if (text === null || text === \"\") {\r\n            text = \"Unnamed Vertex\";\r\n        }\r\n\r\n        return {\r\n            text: text,\r\n            children: children,\r\n            data: this.vertex,\r\n            state: { opened: true }\r\n        };\r\n        */\r\n    }\r\n    \r\n    setTreeViewElement(folderTitle){ //For when you want to make a folder type of element\r\n        let fakeChildren = [];\r\n        return{\r\n            text: folderTitle,\r\n            children: fakeChildren,\r\n            state: {opened: true}\r\n        };\r\n    }\r\n\r\n    //this function sets the path of a particular vertex node so that you can \r\n    //1. Display that item's path in the actual vertex (if you want)\r\n    //2. Show a tree view that only contains the path to a desired vertex \r\n    setVertexTreePath(treePath){\r\n        this.vertexObjectPath = this.cleanObjectPath + \"/\" + treePath;\r\n    }\r\n\r\n    //Return the vertice's object path\r\n    returnVertexTreePath(){\r\n        return this.vertexObjectPath;\r\n    }\r\n\r\n}\r\n\r\nclass ArrowEdge {\r\n    constructor(flattenedVertexNodes, arrow) {\r\n        this.arrow = arrow;\r\n        this.updateVertices(flattenedVertexNodes);\r\n    }\r\n\r\n    updateVertices(flattenedVertexNodes) {\r\n        this.sourceVertexNodeObject = null;\r\n        this.destVertexNodeObject = null;\r\n\r\n        if (this.arrow !== null) {\r\n            let isSourceFound = this.arrow.sourceVertexUUID === null;\r\n            let isDestFound = this.arrow.destVertexUUID === null;\r\n\r\n            for (let vertexNode of flattenedVertexNodes) {\r\n                if (isSourceFound && isDestFound) {\r\n                    break;\r\n                }\r\n\r\n                if (vertexNode !== null) {\r\n                    if (vertexNode.vertex.semanticIdentity.UUID === this.arrow.sourceVertexUUID) {\r\n                        this.sourceVertexNodeObject = vertexNode;\r\n                        isSourceFound = true;\r\n\r\n                    } else if (vertexNode.vertex.semanticIdentity.UUID === this.arrow.destVertexUUID) {\r\n                        this.destVertexNodeObject = vertexNode;\r\n                        isDestFound = true;\r\n                    }\r\n                }\r\n            }\r\n        \r\n        }\r\n    }\r\n\r\n    set sourceVertexNode(vertexNode) {\r\n        this.sourceVertexNodeObject = vertexNode;\r\n\r\n        if (vertexNode !== null) {\r\n            this.arrow.sourceVertexUUID = vertexNode.vertex.semanticIdentity.UUID;\r\n        } else {\r\n            this.arrow.sourceVertexUUID = null;\r\n        }\r\n    }\r\n\r\n    get sourceVertexNode() {\r\n        return this.sourceVertexNodeObject;\r\n    }\r\n\r\n    get sourceVertex() {\r\n        if (this.sourceVertexNodeObject !== null) {\r\n            return this.sourceVertexNodeObject.vertex;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    set destVertexNode(vertexNode) {\r\n        this.destVertexNodeObject = vertexNode;\r\n\r\n        if (vertexNode !== null) {\r\n            this.arrow.destVertexUUID = vertexNode.vertex.semanticIdentity.UUID;\r\n        } else {\r\n            this.arrow.destVertexUUID = null;\r\n        }\r\n    }\r\n\r\n    get destVertexNode() {\r\n        return this.destVertexNodeObject;\r\n    }\r\n\r\n    get destVertex() {\r\n        if (this.destVertexNodeObject !== null) {\r\n            return this.destVertexNodeObject.vertex;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n//Supply with an array/set of Vertex objects or Arrow objects (NOT ArrowEdge objects)\r\nexport class Graph {\r\n    constructor(vertexArrayFlattened, arrowArrayFlattened) {\r\n        this.rootVertices = new Set();\r\n        if (vertexArrayFlattened !== undefined) {\r\n            this.add(vertexArrayFlattened);\r\n        }\r\n\r\n        this.arrows = new Set();\r\n        if (arrowArrayFlattened !== undefined) {\r\n            this.add(arrowArrayFlattened);\r\n        }\r\n    }\r\n\r\n    add(objects) {\r\n        if (!Array.isArray(objects)) {\r\n            objects = [objects];\r\n        }\r\n\r\n        for (let object of objects) {\r\n            switch (object.typeName) {\r\n                case \"Vertex\":\r\n                    //console.log(\"add vert trigs\")\r\n                    this.addVertex(object);               \r\n                    break;\r\n                case \"Arrow\":\r\n                    this.addArrow(object);\r\n                    break;\r\n                case \"VertexNode\":\r\n                    this.rootVertices.add(object);\r\n                    break;\r\n                case \"ArrowEdge\":\r\n                    this.arrows.add(object);\r\n                    break;\r\n                default:\r\n                    //console.error(\"Attempted to add object to unknown type %s to Graph\", object.typeName)\r\n                    //console.log(object)\r\n                    //console.log(object.constructor)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    addVertex(vertex) {\r\n        if (this.getVertexNode(vertex) === null) { // if its the original vertex\r\n            vertex.originalUUID = vertex.semanticIdentity.UUID; \r\n            vertex = new VertexNode(vertex);\r\n            this.rootVertices.add(vertex);\r\n        } else { // else its a copy of the original\r\n            //console.log(\"a copy vertex was attempted\")\r\n            \r\n            let newTitle = \":: \" + vertex.title\r\n            vertex.title = newTitle\r\n            vertex.originalVertex = false;\r\n            /* For now im going to give the copies their own unique semantic UUID, as a lot of stuff in the program hinges off of vertex items\r\n            having their own unique sID. as a work around i've created a value in the vertex object to store the sID of the original vertex so that\r\n            any functions that require the original UUID of the original vertex can still be used. - cooper*/\r\n            vertex.originalUUID = vertex.semanticIdentity.UUID; \r\n            let sID = new SemanticIdentity(vertex.title,\"\",\"\",\"\", undefined ,[]) \r\n            vertex.semanticIdentity = sID;\r\n            vertex = new VertexNode(vertex);\r\n\r\n           \r\n            this.rootVertices.add(vertex);\r\n            console.log(vertex)\r\n        }\r\n    }\r\n\r\n    //NOTE: Graph direction is inverted, flowing from the dest to source of arrows\r\n    //This is intentional behaviour of the modelling spec\r\n    addArrow(arrow) {\r\n        if (this.getArrowEdge(arrow) === null) {\r\n            arrow = new ArrowEdge(this.flattenVertexNodes(), arrow);\r\n            this.arrows.add(arrow);\r\n\r\n            if (arrow.destVertexNode !== null && arrow.sourceVertexNode !== null) {\r\n                arrow.destVertexNode.add(arrow.sourceVertexNode);\r\n\r\n                //If the destination of the arrow is currently a root vertex,\r\n                //search for if the destination has any other possible roots,\r\n                //and remove from the root ONLY IF another root is found\r\n                //This retains an entry point for the graph even if there is a cycle back to root\r\n                if (this.rootVertices.has(arrow.sourceVertexNode)) {\r\n                    let isAnotherRoot = false;\r\n\r\n                    for (let vertexNode of this.rootVertices) {\r\n                        if (vertexNode.vertex.semanticIdentity.UUID === arrow.sourceVertex.semanticIdentity.UUID) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (vertexNode.has(new Set(), arrow.sourceVertexNode)) {\r\n                            isAnotherRoot = true;\r\n                        }\r\n                    }\r\n\r\n                    if (isAnotherRoot) {\r\n                        this.rootVertices.delete(arrow.sourceVertexNode);\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n            console.error(\"Attempted to add duplicate arrow\");\r\n        }\r\n    }\r\n\r\n    //A way of returning the arrow UUID's associated with the deleted vertex. For some reason the source and ending\r\n    //UUID data isn't being saved properly upstream, so this is a way around that.\r\n    ArrowUUIDSource(object){\r\n        object = this.getVertexNode(object);\r\n        //first index is source, second is destination\r\n        let returnArray = [];\r\n\r\n        //Match an arrow\r\n        let i = 0;\r\n        for (let arrow of this.arrows) {\r\n            if (arrow.sourceVertexNode !== null && arrow.sourceVertex.semanticIdentity.UUID === object.vertex.semanticIdentity.UUID) {\r\n                returnArray[i] = arrow;\r\n                i += 1;\r\n            }\r\n        }\r\n\r\n        return returnArray;\r\n    }\r\n\r\n    ArrowUUIDDest(object){\r\n        object = this.getVertexNode(object);\r\n        //first index is source, second is destination\r\n        let returnArray = [];\r\n\r\n        //Match an arrow\r\n        let i = 0;\r\n        for (let arrow of this.arrows) {\r\n            if (arrow.destVertexNode !== null && arrow.destVertex.semanticIdentity.UUID === object.vertex.semanticIdentity.UUID) {\r\n                returnArray[i] = arrow;\r\n                i += 1;\r\n            }\r\n        }\r\n\r\n        return returnArray;\r\n    }\r\n\r\n    //Removes and object while shifting it's children's position in the tree\r\n    remove(object) {\r\n        console.log(\"remove 2 is called\")\r\n        //By this point rootVertices doesnt actually contain the vertex we want to delete which makes the isRemoved Logic hard to follow as has returns true when the item is present- Lachlan\r\n        console.log(this.rootVertices)\r\n        if (object.typeName === \"Vertex\") {\r\n            let newobject = this.getVertexNode(object);\r\n            let isRemoved = this.rootVertices.has(newobject);\r\n            console.log(isRemoved)\r\n\r\n\r\n            //Remove from the root\r\n            this.rootVertices.delete(newobject);\r\n            for (let child of newobject.children) {\r\n                this.rootVertices.add(child);\r\n            }\r\n            //console.log(\"It removes from the root fine\")\r\n\r\n            \r\n            //Remove from anywhere deeper in the tree\r\n            let traversedVertices = new Set();\r\n            for (let vertexNode of this.rootVertices) {\r\n                if (!traversedVertices.has(vertexNode)) {\r\n                    traversedVertices.add(vertexNode);\r\n                    vertexNode.remove(traversedVertices, newobject);\r\n                    console.log(isRemoved)\r\n                }\r\n            }\r\n            \r\n            if (isRemoved) {\r\n                //Remove the vertex from being the source or dest of any arrow\r\n                for (let arrow of this.arrows) {\r\n                    if (arrow.sourceVertexNode !== null && arrow.sourceVertex.semanticIdentity.UUID === newobject.vertex.semanticIdentity.UUID) {\r\n                        arrow.sourceVertexNode = null;\r\n                    }\r\n                    \r\n                    if (arrow.destVertexNode !== null && arrow.destVertex.semanticIdentity.UUID === newobject.vertex.semanticIdentity.UUID) {\r\n                        arrow.destVertexNode = null;\r\n                    }\r\n                }\r\n            }\r\n            \r\n\r\n            return isRemoved;\r\n\r\n        } else if (object.typeName === \"Arrow\") {\r\n            let newobject = this.getArrowEdge(object);\r\n\r\n            if (newobject !== null) {\r\n                this.arrows.delete(newobject);\r\n                //IF arrow has a sourceVertex AND destVertex\r\n                if (newobject.sourceVertexNode !== null && newobject.destVertexNode !== null) {\r\n                    //IF there is no other arrow from sourceVertex to destVertex, remove the sourceVertex from the children of destVertex\r\n                    //AND move the sourceVertex to root, if there is no other arrow with the same sourceVertex\r\n                    let isEquivalentArrow = false;\r\n                    let isArrowWithSameSource = false;\r\n                    \r\n                    for (let arrow of this.arrows) {\r\n                        let isEquivalentSource = arrow.sourceVertexNode !== null && arrow.sourceVertex.semanticIdentity.UUID === newobject.sourceVertex.semanticIdentity.UUID;\r\n                        let isEquivalentDest = arrow.destVertexNode !== null && arrow.destVertex.semanticIdentity.UUID === newobject.destVertex.semanticIdentity.UUID;\r\n                        \r\n                        if (isEquivalentSource && isEquivalentDest) {\r\n                            isEquivalentArrow = true;\r\n                        }\r\n                        if (isEquivalentSource && arrow.destVertexNode !== null) {\r\n                            isArrowWithSameSource = true;\r\n                        }\r\n                    }\r\n                    \r\n                    if (!isEquivalentArrow) {\r\n                        newobject.destVertexNode.removeFromChildren(newobject.sourceVertexNode);\r\n                    }\r\n                    if (!isArrowWithSameSource) {\r\n                        this.add(newobject.sourceVertexNode);\r\n                    }\r\n\r\n                    //Remove vertex from the root if removing this arrow has resolved a cycle\r\n                    if (newobject.sourceVertexNode.has(new Set(), newobject.destVertexNode)) {\r\n                        this.rootVertices.delete(newobject.destVertexNode);\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n        } else {\r\n            if (object !== null) {\r\n                console.error(\"Attempted to remove object of invalid type %s to Graph\", object.typeName);\r\n            } else {\r\n                console.error(\"Attempted to remove null from Graph\");\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    has(object) {\r\n        //Search for object in root vertices\r\n        if (this.rootVertices.has(object)) {\r\n            return true;\r\n\r\n        } else {\r\n            let traversedVertices = new Set();\r\n\r\n            //Search for object in children of root vertices\r\n            for (let vertex of this.rootVertices) {\r\n                if (!traversedVertices.has(vertex)) {\r\n                    traversedVertices.add(vertex);\r\n                    if (vertex.has(traversedVertices, object)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    getVertexNode(vertex) {\r\n        let traversedVertices = new Set();\r\n\r\n        for (let rootNode of this.rootVertices) {\r\n            if (!traversedVertices.has(rootNode)) {\r\n                traversedVertices.add(rootNode);\r\n                if (rootNode.vertex.semanticIdentity.UUID === vertex.semanticIdentity.UUID) {\r\n                    return rootNode;\r\n                } else {\r\n                    let node = rootNode.getVertexNode(traversedVertices, vertex);\r\n                    if (node !== null) {\r\n                        return node;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    getArrowEdge(arrow) {\r\n        for (let arrowEdge of this.arrows) {\r\n            if (arrowEdge.arrow.semanticIdentity.UUID === arrow.semanticIdentity.UUID) {\r\n                return arrowEdge;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    flatten(doFlattenVertices = true, doFlattenArrows = true) {\r\n        let verticesSet = new Set();\r\n        let arrowsSet = new Set();\r\n\r\n        let traversedVertices = new Set();\r\n\r\n        if (doFlattenVertices) {\r\n            for (let vertexNode of this.rootVertices) {\r\n                if (!traversedVertices.has(vertexNode)) {\r\n                    traversedVertices.add(vertexNode);\r\n                    verticesSet.add(vertexNode.vertex);\r\n    \r\n                    if (vertexNode !== null) {\r\n                        for (let child of vertexNode.flatten(traversedVertices)) {\r\n                            verticesSet.add(child);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (doFlattenArrows) {\r\n            for (let arrowEdge of this.arrows) {\r\n                arrowsSet.add(arrowEdge.arrow);\r\n            }\r\n        }\r\n\r\n        let flattenedArray = Array.from(verticesSet);\r\n        return flattenedArray.concat(Array.from(arrowsSet));\r\n    }\r\n\r\n    flattenVertexNodes() {\r\n        var verticesSet = new Set();\r\n        let traversedVertices = new Set();\r\n\r\n        for (let vertexNode of this.rootVertices) {\r\n            if (!traversedVertices.has(vertexNode)) {\r\n                traversedVertices.add(vertexNode);\r\n                verticesSet.add(vertexNode);\r\n\r\n                if (vertexNode !== null) {\r\n                    for (let child of vertexNode.flattenVertexNodes(traversedVertices)) {\r\n                        verticesSet.add(child);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Array.from(verticesSet);\r\n    }\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\n// React imports\r\nimport React, { useRef, useCallback, useState } from 'react';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport OutlinedInput from '@material-ui/core/OutlinedInput';\r\nimport Select from '@material-ui/core/Select';\r\nimport MenuItem from '@material-ui/core/MenuItem';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport GridMUI from '@material-ui/core/Grid';\r\nimport Checkbox from '@material-ui/core/Checkbox';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport { EditingState } from '@devexpress/dx-react-grid';\r\n\r\nimport saveAs from 'file-saver';\r\n\r\nimport InputGroup from 'react-bootstrap/InputGroup'\r\nimport FormControl from 'react-bootstrap/FormControl'\r\nimport Button from 'react-bootstrap/Button'\r\n\r\nimport { GridExporter } from '@devexpress/dx-react-grid-export';\r\n\r\nimport {\r\n    Grid,\r\n    Table,\r\n    TableHeaderRow,\r\n    TableInlineCellEditing,\r\n    Toolbar,\r\n    ExportPanel,\r\n} from '@devexpress/dx-react-grid-material-ui';\r\n\r\nimport {\r\n    Plugin,\r\n    Template,\r\n    TemplatePlaceholder,\r\n} from '@devexpress/dx-react-core';\r\n\r\n// In program imports\r\nimport {currentObjects} from \"./CanvasDraw\";\r\nimport {getVertexData, vertexData} from \"./ContainmentTree\"\r\n\r\n// Globals\r\nlet rows;\r\nlet setRows = null;\r\nlet setColumns = null;\r\nlet textInput = React.createRef();\r\nexport var translationColumns = [];\r\n\r\nconst onSave = (workbook) => {\r\n    workbook.xlsx.writeBuffer().then((buffer) => {\r\n        saveAs(new Blob([buffer], { type: 'application/octet-stream' }), 'DataGrid.xlsx');\r\n    });\r\n};\r\n\r\nconst getRowId = row => row.id;\r\n\r\nconst styles = () => ({\r\n    input: {\r\n        fontSize: '14px',\r\n        width: '90px',\r\n    },\r\n    label: {\r\n        fontSize: '14px',\r\n    },\r\n    container: {\r\n        maxWidth: '18em',\r\n    },\r\n    selector: {\r\n        height: '32px',\r\n    },\r\n});\r\n\r\n// #FOLD_BLOCK\r\nconst StartEditActionSelectorBase = (props) => {\r\n    const { defaultAction, changeAction, classes } = props;\r\n    return (\r\n        <GridMUI\r\n            container\r\n            alignItems=\"center\"\r\n            className={classes.container}\r\n        >\r\n            <Typography\r\n                className={classes.label}\r\n            >\r\n                Start Edit Action:\r\n                &nbsp;\r\n            </Typography>\r\n            <Select\r\n                onChange={e => changeAction(e.target.value)}\r\n                value={defaultAction}\r\n                className={classes.selector}\r\n                input={(\r\n                    <OutlinedInput\r\n                        classes={{ input: classes.input }}\r\n                        labelWidth={0}\r\n                        margin=\"dense\"\r\n                    />\r\n                )}\r\n            >\r\n                <MenuItem value=\"click\">Click</MenuItem>\r\n                <MenuItem value=\"doubleClick\">Double Click</MenuItem>\r\n            </Select>\r\n        </GridMUI>\r\n    );\r\n};\r\nconst StartEditActionSelector = withStyles(styles, { name: 'StartEditActionSelector' })(StartEditActionSelectorBase);\r\n\r\n// #FOLD_BLOCK\r\nconst SelectTextCheckerBase = (props) => {\r\n    const { isSelectText, changeSelectText, classes } = props;\r\n    return (\r\n        <FormControlLabel\r\n            control={(\r\n                <Checkbox\r\n                    checked={isSelectText}\r\n                    onChange={e => changeSelectText(e.target.checked)}\r\n                    color=\"primary\"\r\n                />\r\n            )}\r\n            classes={{ label: classes.label }}\r\n            label=\"Select Text On Focus\"\r\n        />\r\n    );\r\n};\r\nconst SelectTextChecker = withStyles(styles, { name: 'SelectTextChecker' })(SelectTextCheckerBase);\r\n\r\nconst EditPropsPanel = props => (\r\n    <Plugin name=\"EditPropsPanel\">\r\n        <Template name=\"toolbarContent\">\r\n            <SelectTextChecker {...props} />\r\n            <TemplatePlaceholder />\r\n            <StartEditActionSelector {...props} />\r\n        </Template>\r\n    </Plugin>\r\n);\r\n\r\nconst FocusableCell = ({ onClick, ...restProps }) => (\r\n    <Table.Cell {...restProps} tabIndex={0} onFocus={onClick} />\r\n);\r\n\r\nexport default () => {\r\n    // Create columns\r\n    let [columns, setColumnsRet] = useState(createColumns());\r\n    setColumns = setColumnsRet;\r\n\r\n    // Disable editing state\r\n    const [editingStateColumnExtensions] = useState([\r\n        { columnName: 'UUID', editingEnabled: false },\r\n        { columnName: 'type', editingEnabled: false },\r\n    ]);\r\n\r\n    // Rows\r\n    const [generatedRows, setRowsRet] = useState([]);\r\n    rows = generatedRows;\r\n    setRows = setRowsRet;\r\n\r\n    // Enable/Disable word Wrap\r\n    const [tableColumnExtensions] = useState([\r\n        { columnName: 'UUID', wordWrapEnabled: true },\r\n        { columnName: 'type', wordWrapEnabled: true },\r\n        { columnName: 'name', wordWrapEnabled: true },\r\n        { columnName: 'description', wordWrapEnabled: true },\r\n        { columnName: 'abbreviation', wordWrapEnabled: true },\r\n        { columnName: 'shortAbbreviation', wordWrapEnabled: true },\r\n    ]);\r\n\r\n    // Editable\r\n    const [startEditAction, setStartEditAction] = useState('click');\r\n    const [selectTextOnEditStart, setSelectTextOnEditStart] = useState(true);\r\n\r\n    const commitChanges = ({ added, changed, deleted}) => {\r\n        let changedRows;\r\n        if (added) {\r\n            const startingAddedId = rows.length > 0 ? rows[rows.length - 1].id + 1 : 0;\r\n            changedRows = [\r\n                ...rows,\r\n                ...added.map((row, index) => ({\r\n                    id: startingAddedId + index,\r\n                    ...row,\r\n                })),\r\n            ];\r\n        }\r\n        if (changed) {\r\n            changedRows = rows.map(row => (changed[row.id] ? { ...row, ...changed[row.id] } : row));\r\n            updateChangedObjects(changedRows);\r\n        }\r\n        if (deleted) {\r\n            const deletedSet = new Set(deleted);\r\n            changedRows = rows.filter(row => !deletedSet.has(row.id));\r\n        }\r\n\r\n        setRows(changedRows);\r\n    };\r\n\r\n    // Export functionality\r\n    const exporterRef = useRef(null);\r\n\r\n    const startExport = useCallback(() => {\r\n        exporterRef.current.exportGrid();\r\n    }, [exporterRef]);\r\n\r\n    // Return\r\n    return (\r\n        <Paper>\r\n            <InputGroup>\r\n                <FormControl\r\n                    ref={textInput}\r\n                    placeholder=\"Column name\"\r\n                    aria-label=\"Column name\"\r\n                    aria-describedby=\"basic-addon2\"\r\n                />\r\n                <InputGroup.Append>\r\n                    <Button variant=\"outline-secondary\" onClick={() => addColumn()}>Add</Button>\r\n                    <Button variant=\"outline-secondary\" onClick={() => removeColumn()}>Remove</Button>\r\n                </InputGroup.Append>\r\n            </InputGroup>\r\n            <Grid\r\n                rows={rows}\r\n                columns={columns}\r\n                getRowId={getRowId}\r\n            >\r\n                <EditingState\r\n                    onCommitChanges={commitChanges}\r\n                    columnExtensions={editingStateColumnExtensions}\r\n                />\r\n                <Table cellComponent={FocusableCell} columnExtensions={tableColumnExtensions} />\r\n                <TableHeaderRow />\r\n                <Toolbar />\r\n                <EditPropsPanel\r\n                    defaultAction={startEditAction}\r\n                    changeAction={setStartEditAction}\r\n                    isSelectText={selectTextOnEditStart}\r\n                    changeSelectText={setSelectTextOnEditStart}\r\n                />\r\n                <ExportPanel startExport={startExport} />\r\n                <TableInlineCellEditing\r\n                    startEditAction={startEditAction}\r\n                    selectTextOnEditStart={selectTextOnEditStart}\r\n                />\r\n            </Grid>\r\n            <GridExporter\r\n                ref={exporterRef}\r\n                rows={rows}\r\n                columns={columns}\r\n                onSave={onSave}\r\n            />\r\n        </Paper>\r\n    );\r\n};\r\n\r\nfunction addColumn() {\r\n    // Get\r\n    const value = textInput.current.value\r\n\r\n    // Clear column name\r\n    textInput.current.value = \"\";\r\n\r\n    // Check if value is empty\r\n    if (value === \"\" || value === null || value === undefined) {\r\n        return;\r\n    }\r\n\r\n    // Add column\r\n    translationColumns.push(value);\r\n    updateColumns();\r\n}\r\n\r\nfunction removeColumn() {\r\n    // Get\r\n    const value = textInput.current.value\r\n\r\n    // Clear column name\r\n    textInput.current.value = \"\";\r\n\r\n    // Delete from currentObjects\r\n    for (let object of currentObjects.flatten()) {\r\n        object.semanticIdentity.translations.delete(value);\r\n    }\r\n\r\n    // Delete column\r\n    translationColumns.splice(translationColumns.indexOf(value), 1);\r\n    updateColumns();\r\n}\r\n\r\nfunction updateColumns() {\r\n    setColumns(createColumns());\r\n}\r\n\r\nfunction getRowForObject(object) {\r\n    const row = {};\r\n\r\n    // Constants\r\n    row['id'] = object.semanticIdentity.UUID; // Just going to be based on UUID since it's easy and unique\r\n    row['UUID'] = object.semanticIdentity.UUID;\r\n    row['type'] = object.typeName;\r\n    row['name'] = object.semanticIdentity.name;\r\n    row['description'] = object.semanticIdentity.description;\r\n    row['abbreviation'] = object.semanticIdentity.abbreviation;\r\n    row['shortAbbreviation'] = object.semanticIdentity.shortAbbreviation;\r\n\r\n    // Translations\r\n    for (let o = 0; o < object.semanticIdentity.translations.length; o++) {\r\n        let translation = object.semanticIdentity.translations[o];\r\n\r\n        row[translation[0]] = translation[1];\r\n    }\r\n\r\n    return row;\r\n}\r\n\r\nexport function resetRows() {\r\n    let newRows = [];\r\n    let currentObjectsFlattened = currentObjects.flatten();\r\n\r\n    for (let i = 0; i < vertexData.length; i++) {\r\n        newRows.push(getRowForObject(vertexData[i]));\r\n    }\r\n    for(let i = 0; i < currentObjectsFlattened.length; i++){\r\n        // Add Arrow Ends\r\n        if (currentObjectsFlattened[i].typeName === \"Arrow\") {\r\n            newRows.push(getRowForObject(currentObjectsFlattened[i].sourceEdgeEnd));\r\n            newRows.push(getRowForObject(currentObjectsFlattened[i].destEdgeEnd));\r\n        }\r\n    }\r\n\r\n    if (setRows === null) {\r\n        console.error(\"Cannot set rows\");\r\n        return;\r\n    }\r\n\r\n    setRows(newRows);\r\n}\r\n\r\nfunction createColumns() {\r\n    // Create default columns\r\n    let columnNames = [\r\n        {name: 'UUID', title: 'UUID'},\r\n        {name: 'type', title: 'Type'},\r\n        {name: 'name', title: 'Name'},\r\n        {name: 'description', title: 'Description'},\r\n        {name: 'abbreviation', title: 'Abbreviation'},\r\n        {name: 'shortAbbreviation', title: 'Short Abbreviation'},\r\n    ];\r\n\r\n    // Add translation columns\r\n    for (let translation of translationColumns) {\r\n        columnNames.push({name: translation, title: translation});\r\n    }\r\n\r\n    return columnNames;\r\n}\r\n\r\nfunction updateChangedObject(object, row) {\r\n    // If should update\r\n    if (object.semanticIdentity.UUID === row['UUID']) {\r\n        // Constants\r\n        object.semanticIdentity.abbreviation = row['abbreviation'];\r\n        object.semanticIdentity.shortAbbreviation = row['shortAbbreviation'];\r\n        object.semanticIdentity.name = row['name'];\r\n        object.semanticIdentity.description = row['description'];\r\n\r\n        // Translations\r\n        for (let translation of translationColumns) {\r\n            // Find translation in list\r\n            let set = false;\r\n            for (let i = 0; i < object.semanticIdentity.translations.length; i++) {\r\n                if (object.semanticIdentity.translations[i][0] === translation) {\r\n                    object.semanticIdentity.translations[i][1] = row[translation];\r\n                    set = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!set) {\r\n                object.semanticIdentity.translations.push([translation, row[translation]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return row;\r\n}\r\n\r\nfunction updateChangedObjects(rows) {\r\n    let currentObjectsFlattened = currentObjects.flatten();\r\n    let treeVert = getVertexData()\r\n\r\n    // Iterate through all rows\r\n    for (let i = 0; i < rows.length; i++) {\r\n\r\n        //itterate through tree verts\r\n        for (let j = 0; j < treeVert.length; j++) {\r\n            rows[i] = updateChangedObject(treeVert[j],rows[i])\r\n            console.log(treeVert[j])\r\n        }\r\n\r\n        // Iterate through all objects\r\n        for (let o = 0; o < currentObjectsFlattened.length; o++) {\r\n            // Update main objects\r\n            rows[i] = updateChangedObject(currentObjectsFlattened[o], rows[i]);\r\n\r\n            // Update edge ends\r\n            if (currentObjectsFlattened[o].typeName === \"Arrow\") {\r\n                rows[i] = updateChangedObject(currentObjectsFlattened[o].sourceEdgeEnd, rows[i]);\r\n                rows[i] = updateChangedObject(currentObjectsFlattened[o].destEdgeEnd, rows[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function setTranslationColumns(newColumns) {\r\n    translationColumns = newColumns;\r\n    updateColumns();\r\n}","import React from 'react';\r\nimport * as canvasDraw from \"./CanvasDraw\";\r\nimport { getFolderNameFromKey, getVertexData } from './ContainmentTree';\r\nimport { Tool } from './LeftMenu';\r\n\r\nlet movingAllowed = false;\r\nlet selectMultiple = false;\r\nlet selectDown = false;\r\nlet savedObjects = [];\r\n\r\nexport class Canvas extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.canvasRef = React.createRef();\r\n\r\n        this.state = {}\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps, nextContext) {\r\n        this.zoom = nextProps.mainState.zoomLevel;\r\n        this.tool = nextProps.mainState.drawMode;\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.zoom = this.props.mainState.zoomLevel;\r\n        this.tool = this.props.mainState.drawMode;\r\n\r\n        document.getElementById(\"Canvas\").addEventListener('dragenter', this.dragEnter);\r\n        document.getElementById(\"Canvas\").addEventListener('dragover', this.dragOver);\r\n        document.getElementById(\"Canvas\").addEventListener('dragleave', this.dragLeave);\r\n        document.getElementById(\"Canvas\").addEventListener('drop', this.drop);\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.getElementById(\"Canvas\").removeEventListener('dragenter', this.dragEnter);\r\n        document.getElementById(\"Canvas\").removeEventListener('dragover', this.dragOver);\r\n        document.getElementById(\"Canvas\").removeEventListener('dragleave', this.dragLeave);\r\n        document.getElementById(\"Canvas\").removeEventListener('drop', this.drop);\r\n    }\r\n\r\n    dragEnter(e) {\r\n        e.preventDefault();\r\n    }\r\n    \r\n    dragOver(e) {\r\n        e.preventDefault();\r\n    }\r\n    \r\n    dragLeave(e) {\r\n        return 0\r\n    }\r\n    \r\n    drop(e) {\r\n        console.log('dropped')\r\n        //Find the vertex object that was dragged\r\n        let droppedSemanticID = e.dataTransfer.getData('text/plain');\r\n        let droppedVertex = 0;\r\n        for(let vert of getVertexData()){\r\n            if (vert.semanticIdentity.UUID === droppedSemanticID)\r\n            droppedVertex = vert;\r\n        }\r\n        //console.log(droppedVertex)\r\n        //get canvas relative coordinates for where the object was dropped\r\n        let mouseCoords = canvasDraw.getGraphXYFromMouseEvent(e)\r\n\r\n        let newName = droppedVertex.text.replace(\" \",\"\");\r\n        newName = newName.replace(\" \",\"\")\r\n        let newColour;\r\n        let visibilityCheck = false;\r\n\r\n        //check if selected model is located in the same package or not\r\n        if(droppedVertex.parentRenderKey !== canvasDraw.getCurrentRenderKey()){\r\n            newColour = \"#FFFFFF\";\r\n            visibilityCheck = true; //used to determine if the vertex has an origin package added\r\n        }\r\n        else{\r\n            \r\n            newColour = droppedVertex.colour;\r\n        }\r\n\r\n\r\n        //create the vertex object(size 30x15) and place it\r\n        let canvasVert = canvasDraw.createVertex(mouseCoords[0],mouseCoords[1],droppedVertex.width,droppedVertex.height,newName,\r\n            droppedVertex.content,newColour,droppedVertex.icons,droppedVertex.imageElements,droppedVertex.fontSize,droppedVertex.semanticIdentity)\r\n        if(visibilityCheck === true){\r\n            //add origin package\r\n            let originText = getFolderNameFromKey(droppedVertex.parentRenderKey)\r\n            originText = originText.replace(\" \",\"\")\r\n            originText = originText.replace(\" \",\"\")\r\n            canvasVert.setOrigin(originText + \" :: \")\r\n        }\r\n        canvasDraw.addObject(canvasVert)\r\n        canvasDraw.drawAll()\r\n\r\n\r\n\r\n        //canvas\r\n        //mouseStartX\r\n        //mouseStartY\r\n        //x mose+10\r\n        //x mouse +10\r\n\r\n    }\r\n\r\n\r\n\r\n    // prevent context (right-click) menu from appearing\r\n    ocm = (e) => {\r\n        e.preventDefault();\r\n    };\r\n    // What happens if u click anywhere on the canvas\r\n    mouseDown = (e, canvas) => {\r\n        let position = canvasDraw.getGraphXYFromMouseEvent(e);\r\n        let x = position[0]; let y = position[1];\r\n        this.setState({\r\n            startX: x,\r\n            startY: y\r\n        });\r\n\r\n        //toggle shift key to move all connected\r\n        if (e.shiftKey && !selectDown) {\r\n            selectDown = true;\r\n        }\r\n        // If it was a left click\r\n        if (e.button === 0 && !selectMultiple) {\r\n            let intersection = canvasDraw.findIntersected(x, y);\r\n            // check if there's an object\r\n            if (intersection !== null) {\r\n                //if object is a box, move the object\r\n                if (canvas.tool === Tool.Select && intersection.typeName === \"Vertex\") {\r\n                    e.preventDefault();\r\n                    // brings up the menu\r\n                    this.props.setLeftMenu(canvasDraw.findIntersected(x, y));\r\n                    canvasDraw.onMiddleClick(canvas, x, y,null,selectDown);\r\n                    //console.log(selectDown);\r\n\r\n                } else {\r\n                    this.props.setLeftMenu(canvasDraw.findIntersected(x, y));\r\n                    canvasDraw.saveBlockStates(canvas, x, y, 1);\r\n                    canvasDraw.onLeftMousePress(canvas, x, y);\r\n                }\r\n\r\n              } else { //clicked nothing\r\n            this.props.setLeftMenu(canvasDraw.findIntersected(x, y));\r\n            canvasDraw.saveBlockStates(canvas, x, y, 1);\r\n            canvasDraw.onLeftMousePress(canvas, x, y);\r\n            }\r\n        }\r\n        \r\n        //toggles ctrl key to be active for selecting multiple.\r\n        //detoggles in mouseup\r\n        if (e.ctrlKey && !selectMultiple) {\r\n            selectMultiple = true;\r\n        }\r\n\r\n        //mouse down\r\n        if (e.button === 0 && selectMultiple) {\r\n            \r\n            let intersection = canvasDraw.findIntersected(x, y);\r\n            // check if there's an object\r\n            if (intersection === null) {\r\n                this.props.setLeftMenu(intersection, false, savedObjects);\r\n                savedObjects = [];\r\n                selectMultiple = false;\r\n\r\n            }\r\n            if (intersection !== null) {\r\n                //console.log(selectMultiple);\r\n                // Remove dupes\r\n                let foundEnd = 0;\r\n                //start at 0\r\n                while (foundEnd < savedObjects.length-1){\r\n                    //stop @ second last one\r\n                    //check RHS for duplicates\r\n                    //found+1 because wanna look at box after the one we looking at\r\n                    for (let ob = foundEnd+1; ob < savedObjects.length; ob++){\r\n                        if(savedObjects[foundEnd].x === savedObjects[ob].x && savedObjects[foundEnd].y === savedObjects[ob].y ){\r\n                            savedObjects.splice(ob); // if it's the same, delete it and slide array back one\r\n                        }\r\n                    }\r\n                    foundEnd++;\r\n                }\r\n                //ideally want to push in the first object that has already been selected\r\n                console.log(savedObjects);\r\n                savedObjects.push(canvasDraw.findIntersected(x, y));\r\n                canvasDraw.onMiddleClick(canvas, x, y, savedObjects)\r\n                \r\n                for(let i = 0; i <savedObjects.length; i++) {\r\n                    this.props.setLeftMenu(savedObjects[i], selectMultiple);\r\n                }\r\n                \r\n\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        // If it was a middle click\r\n        if (e.button === 1) {\r\n            e.preventDefault();\r\n            canvasDraw.onMiddleClick(canvas, x, y)\r\n        }\r\n\r\n\r\n    };\r\n\r\n    mouseUp = (e, canvas) =>{\r\n\r\n        canvasDraw.solidifyObject();\r\n\r\n        let position = canvasDraw.getGraphXYFromMouseEvent(e);\r\n        let x = position[0]; let y = position[1];\r\n\r\n        // If it was a left click\r\n        if (e.button === 0) {\r\n            if (canvas.tool === Tool.Select) {\r\n                canvasDraw.drawAll()\r\n            }\r\n\t\t\telse {\r\n                canvasDraw.onLeftMouseRelease(canvas, x, y);\r\n            }\r\n\r\n        }\r\n\r\n        // if it was a right click\r\n        if (e.button === 2) {\r\n\r\n           // deleted the old rightclick functionality and will leave this if statement here for when we implement right click menu - cooper\r\n           \r\n\t\t\t\r\n        }\r\n\t\tif (e.shiftKey && selectDown) {\r\n            selectDown = false;\r\n        }\r\n\r\n        if (e.button === 1) {\r\n            window.setTimeout(() => {canvasDraw.solidifyObject()},200)\r\n\r\n        }\r\n\t\tif (canvasDraw.blockBeenSelected === true){\r\n\t\t\tcanvasDraw.checkCollision(canvas, x, y);\r\n\t\t}\r\n\t\t\r\n    };\r\n\r\n    mouseLeave() {\r\n        canvasDraw.onMouseLeave()\r\n    }\r\n\r\n    render() {\r\n        return <canvas ref={this.canvasRef} id=\"drawCanvas\" onContextMenu={(e) => this.ocm(e)} onMouseDown={(e) => this.mouseDown(e, this)} onMouseUp={(e) => this.mouseUp(e, this)} onMouseLeave={(e) => this.mouseLeave(e,this)}>\r\n                <p> HTML5 Canvas elements are not supported by your browser</p>\r\n            </canvas>\r\n    }\r\n\r\n}\r\n\r\nwindow.addEventListener(\"resize\",canvasDraw.resetMouseOrigin);\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. \r\n */\r\n\r\nimport React from 'react';\r\nimport TreeView from 'react-simple-jstree';\r\n\r\n\r\n\r\n\r\nimport { currentObjects, getModelName, getCurrentRenderKey, setNewRenderKey, \r\n    getTotalRenderKeys, incrementTotalRenderKeys, \r\n    getCurrentModel, setNewModel, getTotalModels, incrementTotalModels, decreaseTotalModels, decreaseTotalRenderKeys, deleteElement, getCurrentObjects} from \"./CanvasDraw\";\r\n\r\nimport { drawAll } from \"./CanvasDraw\";\r\nimport {VertexNode} from \"../DataStructures/Graph.js\"\r\nimport { ContactsOutlined } from '@material-ui/icons';\r\nimport { LeftMenu, LeftMenuType } from './LeftMenu';\r\nimport { MainProgramClass } from './MainView';\r\nimport { SemanticIdentity } from \"../DataStructures/SemanticIdentity.js\";\r\n//import { remove,toTreeViewElement } from \"../DataStructures/Graph\";\r\n//import { ContactsOutlined, Remove } from '@material-ui/icons';\r\n\r\n\r\n//import {currentRenderKey} from './CanvasDraw';\r\n\r\n// I need to export this so I can access it in the left menu and then set it to the correct vertex;\r\nexport var someVertexPath = \"\";\r\n\r\nlet focussed = false; //leftover from a depricated feature, should always be false until removed fully- Lachlan\r\nlet currentlySelectedObject = null; //The currently selected object\r\n//let lastSelectedObject = null; // The last selected object\r\n\r\nlet showingVertPath = false;\r\n\r\n// You could probably get away with not including this here, but it just makes it easier to access the tree\r\n// data from any function you like. It still needs to be emptied in the constructor though\r\nlet treeData = [];\r\n\r\n// I need this to store the folders. Initially, it has one folder simply titled 'Unnamed Folder'.\r\nexport let folderData = [];\r\n\r\n// used to store Vertex objects in tree data (Used to create the vertex objects in CanvasDraw/currentObjects)\r\nexport let vertexData = [];\r\nlet decoyVertexData = [] //here because of how old team did folder indexing\r\n\r\n//used as a container to seperate \"root\" folders and subfolders so that only the root folders are pushed to root.children in the constructor - Lachlan\r\nlet folderDataRoot = [];\r\n\r\n//This variable will be used to store the \"selected folder\" for creating new folders or models\r\n// As renderKey is tied too many methods related to syncing data between canvas and tree/ creating data in tree control of the current renderkey \r\n//has been taken away from the user and will always be set to the parent folder of the selected model (this happens in elementSelect on a model click) - Lachlan\r\nlet selectedFolderKey = 0;\r\n\r\n// This is to do with getting the data indexing to be\r\nlet decoyFolderData = [];\r\n\r\n// An array for holding model names\r\nexport let modelObjects = [];\r\n\r\nlet decoyModelObjects = []; // doing the same data referencing as folder data because currently the data being referenced in the models is the model beforehand which\r\n                            // i dont tink is intended. - cooper\r\n\r\nlet folderAltered = false;\r\nlet modelAltered = false;\r\nlet vertexAltered = false //not sure if I need this? but leaving here for now incase I do need it referenced somewhere since folder andm odels have it -Lachlan\r\n\r\n// created a boolean which whill tell the leftmenu that the containment tree needs to update\r\nexport var treeNeedsUpdate = 0;\r\n\r\n\r\n\r\nexport function setSelectedFolderKey(newKey){\r\n    selectedFolderKey = newKey;\r\n}\r\n\r\nexport function getSelectedFolderKey(){\r\n    return selectedFolderKey;\r\n}\r\n\r\nexport function getTreeData(){\r\n    return treeData;\r\n}\r\n\r\nexport function setTreeData(newTreeData){\r\n    treeData = newTreeData;\r\n}\r\n\r\nexport function getFolderData(){\r\n    return folderData;\r\n}\r\n\r\nexport function setFolderData(newFolderData){\r\n    folderData = newFolderData;\r\n}\r\n\r\nexport function getDecoyFolderData(){\r\n    return decoyFolderData\r\n}\r\n\r\nexport function setDecoyFolderData(newData){\r\n    decoyFolderData = newData;\r\n}\r\n\r\nexport function getVertexData(){\r\n    return vertexData;\r\n}\r\n\r\nexport function setVertexData(newData){\r\n    vertexData = newData;\r\n}\r\n\r\nexport function getDecoyVertexData(){\r\n    return decoyVertexData\r\n}\r\n\r\nexport function setDecoyVertexData(newData){\r\n    decoyVertexData = newData;\r\n}\r\n\r\n//returns a concated array of the folders and vertex(containers)\r\nexport function getContainerData(){\r\n    return folderData.concat(vertexData);\r\n}\r\n\r\nexport function getModelData(){\r\n    return modelObjects;\r\n}\r\n\r\nexport function setModelData(newData){\r\n    modelObjects = newData;\r\n}\r\nexport function getDecoyModelData(){\r\n    return decoyModelObjects;\r\n}\r\nexport function setDecoyModelData(newData){\r\n    decoyModelObjects = newData;\r\n}\r\n\r\n//This function is used to load the first available model and canvas from the modelObjects array\r\n//Used to fix thye tree/canvas desync bug when deleting - Lachlan\r\nfunction loadFirstModel(){\r\n    //set selected model/render key to the 1st available as so a canvas isnt loaded for a nonexistant model\r\n    setNewRenderKey(modelObjects[0].data.renderKey)\r\n    setNewModel(modelObjects[0].data.modelKey)\r\n    setSelectedFolderKey(modelObjects[0].data.renderKey)\r\n\r\n    //taken from handleElementSelect for loading the new models canvas\r\n    for (let item of currentObjects.flatten()){\r\n        if (item.typeName === \"Vertex\" && item.getModelKey() === getCurrentModel()){\r\n            item.setPresent();\r\n        }\r\n        else if (item.getModelKey() !== getCurrentModel() && item.typeName === \"Vertex\"){\r\n            item.setAway();\r\n        }\r\n    }\r\n    drawAll()\r\n    document.getElementById(\"SelectedFolder\").value = getContainerData().find(folder => { return folder.renderKey === getSelectedFolderKey()}).text\r\n    document.getElementById(\"SelectedContainer\").value = getContainerData().find(folder => { return folder.renderKey === getCurrentRenderKey()}).text\r\n    document.getElementById(\"SelectedModel\").value = modelObjects.find(model => { return model.modelKey === getCurrentModel()}).text\r\n}\r\n\r\n\r\n//parent key is for dictating subfolders where 0 is root, else pKey is a folder renderKey - Lachlan\r\nexport function handleAddFolder(folderName, parentKey = 0){\r\n    //Create a new folder using the known node type\r\n\r\n    incrementTotalRenderKeys();\r\n\r\n    let tempFolderThing = {\r\n        text: folderName + \" \", //If icon is changed, youll have to change the folder icon in context menu too\r\n        children: treeData[getTotalRenderKeys()],\r\n        data: NaN,\r\n        state: {opened: true},\r\n        type: \"Folder\",\r\n        renderKey: getTotalRenderKeys(),\r\n        parentRenderKey: parentKey\r\n    }\r\n\r\n    decoyFolderData.push(tempFolderThing)\r\n\r\n    let folderThing2 = {\r\n        text: folderName + \" \", //If icon is changed, youll have to change the folder icon in context menu too\r\n        children: treeData[getTotalRenderKeys()],\r\n        data: decoyFolderData[folderData.length],\r\n        state: {opened: true},\r\n        type: \"Folder\",\r\n        renderKey: getTotalRenderKeys(),\r\n        parentRenderKey: parentKey\r\n    }\r\n    \r\n    //console.log(\"theActualData: \" + folderData.length)\r\n    folderData.push(folderThing2);\r\n    //console.log(\"Folder data apparent: \" + folderData[folderData.length-1].data)\r\n    //console.log(folderData)\r\n    //console.log(folderThing2.renderKey)\r\n\r\n    folderAltered = true;\r\n    \r\n}\r\n\r\n// Function to remove a folder in the tree\r\nexport function handleDeleteFolder(selectedRenderKey){ // changing the deleting functions to delete based on renderkey & modelkeys - cooper\r\n    console.log(\"below is the selected render key\")\r\n    console.log(selectedRenderKey)\r\n    if(folderData.length > 1){ //cannot delete folder if it is the only one excluding root - Lachlan\r\n        for (let i = 0; i < folderData.length; i++){\r\n            if (folderData[i].renderKey === selectedRenderKey){\r\n                console.log(\"below is folderdata\")\r\n                console.log(folderData)\r\n                deleteFolderChildren(folderData[i]);\r\n                decoyFolderData.splice(i,1); // have to delete from this array as well because this is where folders obtain the data of themselves \r\n                folderData.splice(i,1); \r\n            }\r\n        }\r\n    \r\n    folderAltered = true;\r\n    }\r\n    else{console.log(\"Cannot delete only folder\")}\r\n    \r\n    loadFirstModel()\r\n}\r\n\r\nfunction deleteFolderChildren(selectedFolder){ // function for deleting all the children of a folder.\r\n    let folderChildren = selectedFolder.children;\r\n    for (let i = 0; i < folderChildren.length; i++){\r\n        if (folderChildren.type === \"Folder\"){\r\n            let selectedRenderKey = folderChildren[i].renderKey;\r\n            handleDeleteFolder(selectedRenderKey);\r\n\r\n        }\r\n        else if (folderChildren.type === \"Model\"){\r\n            let selectedModelKey = folderChildren[i].modelKey;\r\n            handleDeleteModel(selectedModelKey);\r\n        }\r\n    }\r\n}\r\n\r\nfunction deleteModelChildren(selectedModel){ // function for deleting all the children of the model.\r\n    if(selectedModel.children.length > 0){\r\n        let verticesFolder = selectedModel.children;\r\n        for (let i = 0; i < verticesFolder.length; i++){ // had to make a nested for loop due to the encompassing 'vertices' folder\r\n            let vertices = verticesFolder[i].children;\r\n            for (let v = 0; v < vertices.length; v++){\r\n                if (vertices[v].modelkey === selectedModel.modelKey){\r\n                    let chosenObject = vertices[v].data\r\n                    deleteElement(chosenObject);\r\n                }\r\n            }    \r\n        }\r\n    }   \r\n}\r\n\r\n\r\nexport function handleRenameFolder(newName,rKey){\r\n    if(newName !== \"\"){\r\n        for (let i = 0; i < folderData.length; i++){\r\n            if (folderData[i].renderKey === rKey){\r\n                folderData[i].text = newName + \" \";\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        console.log(\"Cannot have empty name\")\r\n    }\r\n}\r\n\r\nexport function handleAddVertex(vertexName, parentKey = 0){\r\n    //Create a new folder using the known node type\r\n\r\n    incrementTotalRenderKeys();\r\n    let sID = new SemanticIdentity(vertexName,\"\",\"\",\"\", undefined ,[])\r\n\r\n    let tempVertexThing = {\r\n        text: vertexName + \" \", //If icon is changed, youll have to change the folder icon in context menu too\r\n        children: treeData[getTotalRenderKeys()],\r\n        data: NaN,\r\n        state: {opened: true},\r\n        type: \"treeVertex\",\r\n        typeName: \"VertexNode\",\r\n        originalVertex: true,\r\n        renderKey: getTotalRenderKeys(),\r\n        parentRenderKey: parentKey,\r\n        content: \"content\",\r\n        colour: \"#FFD5A9\",\r\n        height: 50,\r\n        width: 70,\r\n        icons: [[],[],[]],\r\n        imageElements: {},\r\n        fontSize: 12,\r\n        semanticIdentity: sID\r\n    }\r\n\r\n    decoyVertexData.push(tempVertexThing)\r\n\r\n    let vertexThing2 = {\r\n        text: vertexName + \" \", //If icon is changed, youll have to change the folder icon in context menu too\r\n        children: treeData[getTotalRenderKeys()],\r\n        data: decoyVertexData[vertexData.length],\r\n        state: {opened: true},\r\n        type: \"treeVertex\",\r\n        typeName: \"VertexNode\",\r\n        originalVertex: true,\r\n        renderKey: getTotalRenderKeys(),\r\n        parentRenderKey: parentKey,\r\n        content: \"\",\r\n        colour: \"#FFD5A9\",\r\n        height: 50,\r\n        width: 70,\r\n        icons: [[],[],[]],\r\n        imageElements: {},\r\n        fontSize: 12,\r\n        semanticIdentity: sID\r\n    }\r\n    \r\n\r\n    vertexData.push(vertexThing2);\r\n    console.log(vertexData)\r\n\r\n    vertexAltered = true;\r\n    \r\n}\r\n\r\n\r\n\r\n// Added optional parameter render key, atm used to handle create a model with no folder selected - Lachlan\r\n//initial \"children\" are to prevent erros caused by children initialy not being iterable - Lachlan\r\nexport function handleAddModel(modelName, rKey=getSelectedFolderKey(), semanticID=undefined){\r\n    incrementTotalModels();\r\n    let sID = undefined;\r\n    let icon = \" \"; //If icon is changed, youll have to change toe folder icon in context menu too\r\n    \r\n    if (semanticID !== undefined){\r\n        sID = semanticID;\r\n        icon = \" \"; //If icon is changed, youll have to change toe folder icon in context menu too\r\n    } else {\r\n        sID = new SemanticIdentity(modelName,\"\",\"\",\"\", undefined ,[]);\r\n    }\r\n    \r\n    let decoyModelThing = {\r\n        text: modelName + icon,\r\n        children: [],\r\n        data: NaN,\r\n        state: {opened: true},\r\n        type: \"Model\",\r\n        renderKey: rKey,\r\n        modelKey: getTotalModels(),\r\n        semanticIdentity: sID\r\n    }\r\n    decoyModelObjects.push(decoyModelThing);\r\n\r\n\r\n    let tempModelThing = {\r\n        text: modelName + icon,\r\n        children: [],\r\n        data: decoyModelObjects[modelObjects.length],\r\n        state: {opened: true},\r\n        type: \"Model\",\r\n        renderKey: rKey,\r\n        modelKey: getTotalModels(),\r\n        semanticIdentity: sID\r\n    };\r\n \r\n    modelObjects.push(tempModelThing);\r\n    console.log(modelObjects)\r\n\r\n    modelAltered = true;\r\n\r\n\r\n}\r\n\r\nexport function handleDeleteVertex(selectedUUID){\r\n    for(let vertex of currentObjects.flatten()){\r\n        if(vertex.originalUUID === selectedUUID){\r\n            currentObjects.remove(vertex)\r\n        }\r\n    }\r\n    for(let i = 0; i < vertexData.length; i++){\r\n        if(vertexData[i].semanticIdentity.UUID === selectedUUID){\r\n            vertexData.splice(i, 1)\r\n            decoyVertexData.splice(i, 1)\r\n        }\r\n    }\r\n    drawAll();\r\n}\r\n\r\nexport function handleDeleteModel(selectedModelKey){\r\n\r\n\r\n    for (let i = 0; i < modelObjects.length; i++){\r\n        if (modelObjects[i].modelKey === selectedModelKey){\r\n            console.log(\"model deleted below\")\r\n            console.log(modelObjects[i])\r\n            deleteModelChildren(modelObjects[i]);\r\n            modelObjects.splice(i, 1);\r\n            decoyModelObjects.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    loadFirstModel()\r\n}\r\n\r\nexport function handleRenameModel(newName,mKey){\r\n    for (let i = 0; i < modelObjects.length; i++){\r\n        if (modelObjects[i].modelKey === mKey){\r\n            modelObjects[i].text = newName + \" \";\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function getModelRenderKey(selectedModelKey){ // this function is to fetch the renderkey of the selected model to ensure verticies get created with the correct renderkey -- cooper\r\n    for(let i = 0; i < modelObjects.length; i++){\r\n        if (modelObjects[i].modelKey === selectedModelKey){\r\n            return modelObjects[i].renderKey\r\n        }\r\n    }\r\n}\r\n\r\n//Function for changing the parent folder of a model - Lachlan\r\nexport function handleModelRebase(mKey,newRkey){\r\n    console.log(\"Rebase test\")\r\n    console.log(modelObjects)\r\n    for(let model of modelObjects){\r\n        if(model.modelKey === mKey){\r\n           for(let objectFolders of model.children){  \r\n                let objects = objectFolders.children\r\n                for(let object of objects){\r\n                    object.renderkey = newRkey;\r\n                    if(object.data.typeName === \"Vertex\"){\r\n                    object.data.vertexRenderKey = newRkey;\r\n                    }\r\n                    else{\r\n                    object.data.arrowRenderKey = newRkey;\r\n                    }\r\n                }\r\n            } \r\n            console.log(model)\r\n            model.renderKey = newRkey;\r\n            console.log(model)\r\n        }\r\n    }\r\n    console.log(modelObjects)\r\n    treeNeedsUpdate = 1;\r\n}\r\n\r\n\r\n\r\n// This is a function to display the path of a given vertex\r\n// It's called in the left menu of a vertex\r\nexport function showVertexPath(theObject){\r\n\r\n    if (currentObjects.flatten().length > 0){\r\n        currentlySelectedObject = theObject;\r\n        if (showingVertPath === false){\r\n            showingVertPath = true;\r\n\r\n        }\r\n    \r\n        else if (showingVertPath === true){\r\n            showingVertPath = false;\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// This function is used to determine which object should be owned by which folder object.\r\n// Works by taking a look at the children of the treeData array and seeing if their render \r\n// key matches the one parsed to the function\r\nfunction determineOwnership(parsedRenderKey){\r\n    let returnArray = []\r\n    let i = 0\r\n    for (let vertexOrArrow of treeData){\r\n        if(vertexOrArrow !== undefined){\r\n            //console.log(\"treeData object name: \" + vertexOrArrow.text)\r\n\r\n            if (vertexOrArrow.type === \"Model\"){\r\n                if (vertexOrArrow.renderKey === parsedRenderKey){\r\n                    returnArray.push(treeData[i])\r\n                }\r\n                \r\n            }\r\n/*\r\n            for (let child of vertexOrArrow.children){\r\n                // Check if the render key of the child matches \r\n                if (child.renderKey === parsedRenderKey){\r\n                    //console.log(\"Matched tree data: \" + treeData[i])\r\n                    returnArray.push(treeData[i])\r\n                    break\r\n                }\r\n            }\r\n            */\r\n        }\r\n        i += 1\r\n    }\r\n\r\n    return returnArray\r\n}\r\n\r\n//function used for determineing which folders are owned by a higher folder - Lachlan\r\nfunction determineSubFolders(parsedRenderKey){\r\n    let returnArray = []\r\n    for (let folder of getContainerData()){\r\n        if(folder.parentRenderKey === parsedRenderKey)\r\n        returnArray.push(folder)\r\n    }\r\n    //console.log(\"subfolder return\")\r\n    //console.log(returnArray)\r\n    return returnArray\r\n}\r\n\r\nexport function getModelNameFromKey(key){\r\n    let model = modelObjects.find(model => model.modelKey === key)\r\n    return model.text\r\n}\r\n\r\nexport function getFolderNameFromKey(key){\r\n    let folder = getContainerData().find(folder => folder.renderKey === key)\r\n    return folder.text\r\n}\r\n\r\n\r\n\r\nlet initialFolderAdded = false;\r\nexport class ContainmentTree extends React.Component {\r\n\r\n    componentDidMount() {\r\n        document.getElementById(\"LowerPanel\").addEventListener('dragstart', this.dragStart);\r\n    }\r\n    componentDidUpdate(){\r\n    }\r\n    \r\n    componentWillUnmount() {\r\n        document.getElementById(\"LowerPanel\").removeEventListener('dragstart', this.dragStart);\r\n    }\r\n\r\n    dragStart(e) {\r\n        //console.log(e)\r\n        //When we have a better method of getting data without the click, Use the new method to assign the data value - Lachlan\r\n        e.target.click();\r\n        let vertData = 0;\r\n        for(let folder of getContainerData()){\r\n            if(getSelectedFolderKey() === folder.renderKey)\r\n            vertData = folder;\r\n        }\r\n\r\n        let data = vertData;\r\n        console.log('drag starts...');\r\n        //Prevents errors when a folder or model is dragged etc. \r\n        if(vertData.type === \"treeVertex\"){\r\n        e.dataTransfer.setData('text/plain',data.semanticIdentity.UUID)\r\n        //console.log(data.semanticIdentity.UUID)\r\n        }\r\n        else{\r\n            console.log(\"This object has no drag/drop feature\")\r\n        }\r\n     }\r\n    \r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        treeData = []; \r\n        //let i = 0;\r\n        //console.log(\"props\")\r\n        //console.log(props)\r\n        \r\n\r\n        \r\n        if (initialFolderAdded === false){\r\n            setNewRenderKey(1);\r\n            setNewModel(1);\r\n            setSelectedFolderKey(1);\r\n            handleAddFolder(\"Folder\");\r\n            //The initial folder has render key 1, the initial model needs this to be specified as nothing is selected\r\n            handleAddModel(\"Model\",1) \r\n            initialFolderAdded = true;\r\n            handleAddFolder(\"Subfolder\",getCurrentRenderKey())\r\n            handleAddVertex(\"new Vertex\",getCurrentRenderKey())\r\n        }\r\n        \r\n\r\n            // Push the model objects in. --- I moved the position of these for loops outside of the vertex for loop as it was creating a few problems - cooper\r\n        for (let model of modelObjects){\r\n            treeData.push(model);           \r\n            \r\n        }\r\n        for (let folder of getContainerData()){ // this for loop is to define the ownership of the models - cooper\r\n                //folder.children = determineOwnership(folder.renderKey)  \r\n                //folder.children = determineSubFolders(folder.renderKey)\r\n                let canvasItems = determineOwnership(folder.renderKey) \r\n                let subFolderItems = determineSubFolders(folder.renderKey)\r\n                let combinedItems = canvasItems.concat(subFolderItems)\r\n                //console.log(\"test\")\r\n                //console.log(\"treedata\");\r\n                //console.log(treeData);\r\n                //console.log(combinedItems)\r\n                folder.children = combinedItems;\r\n                \r\n\r\n            }\r\n            //console.log(getContainerData())\r\n               // treeData.push(vertex.toTreeViewElement(new Set())); --- not too sure what the point of this .push was - cooper   \r\n            \r\n        for (let folder of getContainerData()){ // this for loop is to define the ownership of the vertices & arrows - cooper\r\n            let vertex = new VertexNode() \r\n            \r\n            //Disableing canvas vertex's appearing in treeview - Lachlan\r\n            /*\r\n            if (vertex.toTreeViewElement(\"Vertex Folder\", folder.renderKey) !== undefined){ // modelkey is redundant now for storing things in treeview \r\n                //console.log(\"a vertexorarrow: \",vertex)                                                                           // as things need to be stored under the folder - cooper\r\n                folder.children.push(vertex.toTreeViewElement(\"Vertex Folder\", folder.renderKey))\r\n            }\r\n            */\r\n\r\n            if (vertex.toTreeViewElement(\"Arrow Folder\", folder.renderKey) !== undefined){\r\n                 //console.log(\"a vertexorarrow: \",vertex)\r\n                folder.children.push(vertex.toTreeViewElement(\"Arrow Folder\", folder.renderKey))\r\n            }  \r\n            \r\n        }\r\n\r\n        for(let vert of getVertexData()){\r\n            console.log(vert.children)\r\n            if(vert.children.length === 0){\r\n                vert.text = vert.text.replace(\" \",\"\");\r\n                vert.text = vert.text.replace(\" \",\"\");\r\n                vert.text = vert.text + \" \"\r\n            }\r\n            else{\r\n                vert.text = vert.text.replace(\" \",\"\");\r\n                vert.text = vert.text.replace(\" \",\"\");\r\n                vert.text = vert.text + \" \"\r\n            }\r\n        }\r\n\r\n        folderDataRoot = [];\r\n        for (let folder of getContainerData()){\r\n            if(folder.parentRenderKey ===0){\r\n                folderDataRoot.push(folder)\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n            \r\n            \r\n            //console.log(currentObjects);\r\n            //console.log(treeData);\r\n            //console.log(currentObjects.flatten())\r\n        \r\n\r\n        \r\n        \r\n        this.state = {\r\n            data: {\r\n                core: {\r\n                    data: [\r\n                        { text: getModelName(), \r\n                        children: folderDataRoot, state: { opened: true }, \r\n                        root: true},\r\n                    ]\r\n                }\r\n            },\r\n            selectedVertex: null\r\n        }\r\n\r\n\r\n\r\n        if(showingVertPath === true){\r\n            /*\r\n            let highestLevel = getModelName();\r\n            let nextLevel = \"\";\r\n            let vertexOrEdge = \"\";\r\n            let actualObject = \"\";\r\n        \r\n            let b = 0;\r\n            //First, we need to actually determine where the vertex is\r\n            //Take a look at our container\r\n            for (let cont of folderData){\r\n                //Take a look at the children of the containers (arrows and such)\r\n                for (let treeDat of cont.children){\r\n                    //Why is the vertex folder coming up as undefined?????\r\n                    if(b === 0){\r\n                        //console.log(\"SECOND LAYER: \" + treeDat.children);\r\n                        for (let treeElement of treeDat.children){\r\n                            if ((treeElement.text === currentlySelectedObject.title || currentlySelectedObject.title === \"Unnamed Vertex\")){\r\n        \r\n                                nextLevel = cont.text;\r\n        \r\n                                vertexOrEdge = \"Vertices\";\r\n        \r\n                                actualObject = currentlySelectedObject.title;\r\n                            }\r\n                        }\r\n                        b = 1;\r\n                    }\r\n                    \r\n                }\r\n                someVertexPath = highestLevel +\"::\"+ nextLevel +\"::\"+ vertexOrEdge +\"::\"+ actualObject;\r\n            }\r\n            */\r\n\r\n            let highestLevel = getModelName();\r\n            let nextLevel = \"\";\r\n            let vertexOrEdge = \"\";\r\n            let actualObject = \"\";\r\n\r\n            let b = 0;\r\n            //First, we need to actually determine where the vertex is\r\n            //Take a look at our container\r\n            for (let cont of getContainerData()){\r\n                //console.log(\"below is folderData\")\r\n                //console.log(getContainerData())\r\n                //console.log(\"This is active test \". cont)\r\n                //console.log(\"folder text: \" + cont.text)\r\n                //Take a look at the children of the containers (arrows and such)\r\n                for (let treeDat of cont.children){\r\n                    //console.log(\"below is treeDat\")\r\n                    //console.log(treeDat)\r\n                    //console.log(\"treeDat text: \" + treeDat.text) \r\n                    //console.log(\"num of rkeys is:\", getTotalRenderKeys())\r\n                    //console.log(folderData)\r\n                    //Why is the vertex folder coming up as undefined?????\r\n                    //console.log(cont.children)\r\n                    if(b === 0){\r\n                        //console.log(\"SECOND LAYER: \" + treeDat.children);\r\n                        for (let treeElement of treeDat.children){\r\n                            //console.log(\"Vertices text: \" + treeElement)\r\n                                if ((treeElement.text === currentlySelectedObject.title)){\r\n                                    \r\n                                    nextLevel = cont.text;\r\n                                    \r\n                                    vertexOrEdge = \"Vertices\"\r\n                                    \r\n                                    actualObject = currentlySelectedObject.title\r\n\r\n                                    someVertexPath = highestLevel +\"::\"+ nextLevel +\"::\"+ vertexOrEdge +\"::\"+ actualObject;\r\n                                    b = 1;\r\n\r\n                                \r\n                                }\r\n\r\n                        }\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n        }\r\n\r\n        if (folderAltered === true){\r\n\r\n           // this.forceUpdate()\r\n\r\n            folderAltered = false\r\n        }\r\n\r\n    }\r\n\r\n\r\n    //Function called when an object in treeview is clicked\r\n    handleElementSelect(e, data) {\r\n\r\n\r\n\r\n        //console.log(\"Selected Length: \" + data.selected.length)\r\n\r\n        // Try catch used to catch error whe selecting a treeview item with no data type eg. root\r\n        \r\n        try{\r\n\r\n            console.log(data.node.data)\r\n            //console.log(\"Selected Data 1: \" + data.node.data)\r\n            //console.log(\"Selected type 1: \" + data.node.original.type)\r\n            //console.log(\"Selected text 1: \" + data.node.text)\r\n            //console.log(data.node)\r\n            //console.log(\"Selected Type 2: \" + data.node.data.type)\r\n            //console.log(\"Selected Name 2: \" + data.node.data.text)\r\n            //console.log(folderData);\r\n            //console.log(data.node.data)\r\n\r\n            \r\n\r\n            if(data.node.type === \"Vertex Folder\"){\r\n                //console.log(\"You clicked a vertex folder\")\r\n            }\r\n\r\n            else if(data.node.data.type === \"Folder\" || data.node.data.type === \"treeVertex\" ){\r\n                //console.log(\"Clicked Folder: \" + data.node.data.text)\r\n                //setNewRenderKey(data.node.data.renderKey)\r\n                setSelectedFolderKey(data.node.data.renderKey)\r\n                \r\n\r\n                //console.log(\"The render key is now \" + data.node.data.renderKey);\r\n\r\n\r\n            }\r\n\r\n            else if (data.node.data.type === \"Model\"){\r\n                //console.log(\"The selected model is: \" + data.node.data.text)\r\n                //console.log(\"The current folder is: \" + data.node.data.renderKey)\r\n                setNewModel(data.node.data.modelKey);\r\n                //console.log(\"The model key is now \" + getCurrentModel()); // there were issues here with camelCasing causing no modelKey to be selected- cooper\r\n                //setNewRenderKey(data.node.data.renderKey)\r\n                setNewRenderKey(data.node.data.renderKey); // automatically sets the renderkey to be the same as the models as this was causing issues - cooper\r\n                setSelectedFolderKey(data.node.data.renderKey)\r\n                //console.log(\"The render key is now \" + data.node.data.renderKey);\r\n                // Move everything away\r\n                for (let item of currentObjects.flatten()){\r\n                    if (item.typeName === \"Vertex\" && item.getModelKey() === getCurrentModel()){\r\n                        //console.log(\"Item is set as present\")\r\n                        item.setPresent();\r\n                    }\r\n\r\n                    else if (item.getModelKey() !== getCurrentModel() && item.typeName === \"Vertex\"){\r\n                        //console.log(\"Item is sent away\")\r\n                        item.setAway();\r\n                        //console.log(\"The item to not be rendered is\" + item.typeName);\r\n                    }\r\n                }\r\n            }\r\n            \r\n        //console.log(\"The data is: \" + data.node.data);\r\n\r\n            else if (data.selected.length === 1 && data.node.data !== null && data.node.data.type === undefined) {\r\n                let UUID = data.node.data.semanticIdentity.UUID;\r\n                //console.log(\"UUID: \" + UUID)\r\n                for (let vertex of currentObjects.flatten()) {\r\n                    if (vertex.semanticIdentity.UUID === UUID) {\r\n                        //setNewRenderKey(vertex.getRenderKey())\r\n                        //setNewModel(vertex.getModelKey())\r\n                        this.setState({\r\n                            \r\n                            selectedVertex: vertex\r\n                        });\r\n\r\n                        //The following is required to change canvas to the selected vertex's model preventing desync issues of tree and canvas - Lachlan\r\n                    \r\n                        setNewRenderKey(vertex.vertexRenderKey);\r\n                        setNewModel(vertex.vertexModelKey); \r\n                        setSelectedFolderKey(vertex.vertexRenderKey)\r\n                        \r\n                        for (let item of currentObjects.flatten()){\r\n                            if (item.typeName === \"Vertex\" && item.getModelKey() === getCurrentModel()){\r\n                                item.setPresent();\r\n                            }\r\n                            else if (item.getModelKey() !== getCurrentModel() && item.typeName === \"Vertex\"){\r\n                                item.setAway();\r\n                            }\r\n                        }\r\n                    \r\n\r\n                        this.props.setLeftMenu(this.state.selectedVertex);\r\n\r\n                        // Set the current render key to whatever object the person has clicked from\r\n                        // the tree view\r\n                        \r\n                        //console.log(\"The old render key is: \" + currentRenderKey);\r\n                        //this.currentRenderKey = this.state.selectedVertex.getRenderKey();\r\n                        //console.log(\"The new render key is: \" + currentRenderKey);\r\n                        \r\n\r\n                        //currentRenderKey = 1; \r\n                        //console.log(\"Render old key is \" + getCurrentRenderKey());\r\n                        //setNewRenderKey(this.state.selectedVertex.getRenderKey());\r\n                        //console.log(\"The new render key is : \" + getCurrentRenderKey());\r\n                        //currentRenderKey = 1;\r\n                        \r\n                        //console.log(\"The selected object is: \" + this.state.selectedVertex.getRenderKey())\r\n                    }\r\n                }\r\n                \r\n\r\n            } else {\r\n                this.setState({\r\n                    selectedVertex: null\r\n                });\r\n            }\r\n            \r\n\r\n            drawAll();\r\n        }\r\n        catch(e){\r\n            //console.log(e instanceof TypeError)\r\n            //console.log(\"If True,a null type error has been caught, If the selected object should be selectable, this is an issue\")\r\n        }\r\n\r\n        //If the user clicks the root folder       -Lachlan\r\n        try{\r\n            if(data.node.original.root === true){\r\n                //console.log(\"This is root\")\r\n                setSelectedFolderKey(0) //renderkey 0 will be used for root\r\n            }\r\n        }\r\n        catch(e){\r\n            //console.log(\"This is not root\")\r\n        }\r\n\r\n        //used to update the currently selected model/folders fields - Lachlan\r\n        if(getSelectedFolderKey() === 0){\r\n            document.getElementById(\"SelectedFolder\").value = \"Root\"\r\n        }\r\n        else{\r\n            \r\n        document.getElementById(\"SelectedFolder\").value = getContainerData().find(folder => { return folder.renderKey === getSelectedFolderKey()}).text\r\n        }\r\n        try{\r\n        document.getElementById(\"SelectedContainer\").value = getContainerData().find(folder => { return folder.renderKey === getCurrentRenderKey()}).text\r\n        document.getElementById(\"SelectedModel\").value = modelObjects.find(model => { return model.modelKey === getCurrentModel()}).text\r\n        //console.log(modelObjects)\r\n        }\r\n        catch(e){\r\n            console.log(e)\r\n        }\r\n    \r\n\r\n    }\r\n\r\n    handleContextMenu(){\r\n        console.log(\"CM triggered for tree\")\r\n    }\r\n\r\n\r\n\r\n    render() {\r\n        const data = this.state.data;\r\n        //console.log(treeData)\r\n        //console.log(data)\r\n        /*\r\n        if (this.state.selectedObject !== null){\r\n            console.log(\"The old render key is: \" + currentRenderKey);\r\n            currentRenderKey = this.state.selectedObject.getRenderKey();\r\n            console.log(\"The new render key is: \" + currentRenderKey);\r\n        }\r\n        */\r\n        \r\n\r\n        return (\r\n            <div>\r\n                <TreeView treeData={data} onChange={(e, data) => this.handleElementSelect(e, data)} className=\"treeview\" id=\"treeview\" draggable=\"true\" />\r\n\r\n            </div>\r\n        )\r\n    }\r\n}","import {currentObjects, drawAll, getCurrentObjects, getTotalModels, getTotalRenderKeys, setCurrentObjects, setNewModel, setNewRenderKey, setTotalModelKeys, setTotalRenderKey, updateArrows} from \"../UIElements/CanvasDraw\"\r\nimport {version} from \"../UIElements/MainView\"\r\nimport {setTranslationColumns, translationColumns} from \"../UIElements/SemanticDomainEditor\"\r\nimport {getModelName} from \"../UIElements/CanvasDraw\";\r\n\r\nimport {Vertex} from \"../DataStructures/Vertex\";\r\nimport {Arrow} from \"../DataStructures/Arrow\";\r\nimport {Cardinality} from \"../DataStructures/Cardinality\";\r\nimport {EdgeEnd} from \"../DataStructures/EdgeEnd\";\r\nimport {Graph} from \"../DataStructures/Graph\";\r\nimport { SemanticIdentity } from \"../DataStructures/SemanticIdentity\";\r\nimport { getDecoyFolderData, getDecoyModelData, getDecoyVertexData, getFolderData, getModelData, getTreeData, getVertexData, setDecoyFolderData, setDecoyModelData, setDecoyVertexData, setFolderData, setModelData, setSelectedFolderKey, setTreeData, setVertexData } from \"../UIElements/ContainmentTree\";\r\n\r\n//Get all the data that needs to be saved, to restore a session\r\nexport function getSaveData() {\r\n    let vertexObjects = currentObjects.flatten(true, false);\r\n    let arrowObjects = currentObjects.flatten(false, true);\r\n    let treeData = getTreeData();\r\n    let folderData = getFolderData();\r\n    let decoyFolderData = getDecoyFolderData();\r\n\r\n    let vertexData = getVertexData();\r\n    let decoyVertexData = getDecoyVertexData();\r\n\r\n    let modelObjects = getModelData();\r\n    let decoyModelObjects = getDecoyModelData();\r\n\r\n    let totalRenderKeys = getTotalRenderKeys();\r\n    let totalModels = getTotalModels();\r\n\r\n\r\n    let saveData = {\r\n\r\n        translationColumns: translationColumns,\r\n\r\n        vertices: vertexObjects,\r\n        arrows: arrowObjects,\r\n        tree: treeData,\r\n        packages: folderData,\r\n        dPackages: decoyFolderData,\r\n        treeVertex: vertexData,\r\n        dTreeVertex: decoyVertexData,\r\n        graph: modelObjects,\r\n        dGrraph: decoyModelObjects,\r\n        renderKeys: totalRenderKeys,\r\n        modelKeys: totalModels,\r\n\r\n\r\n        \"modelName\":getModelName()\r\n    };\r\n\r\n    return saveData;\r\n\r\n}\r\n\r\n//Create the JSON file with the save data\r\nexport function save(){\r\n    let JSONdata = getSaveData();\r\n    let dataTransformed = JSON.stringify(JSONdata);\r\n    let dataFile = new Blob([dataTransformed], {type: 'text/json'});\r\n    //default file name\r\n    let title = \"s23m model\";\r\n\r\n    //Download the file\r\n    let DLelement = document.createElement(\"a\");\r\n    DLelement.href = URL.createObjectURL(dataFile);\r\n    DLelement.download = title + \".json\";\r\n    document.body.appendChild(DLelement);\r\n    DLelement.click();\r\n    document.body.removeChild(DLelement);\r\n\r\n}\r\n\r\n//currently doesnt load arrows or semantic editor properties\r\nexport function load(jsonString){\r\n    if (jsonString == null) return;\r\n    let saveData = JSON.parse(jsonString);\r\n\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n    //TreeVertices need to convert semanticIdentity back to a sI object\r\n    for(let vert of saveData.treeVertex){\r\n        vert.semanticIdentity = new SemanticIdentity(vert.semanticIdentity.name,vert.semanticIdentity.description,vert.semanticIdentity.abbreviation,\r\n            vert.semanticIdentity.shortAbbreviation,vert.semanticIdentity.UUID,vert.semanticIdentity.translations)\r\n    }\r\n\r\n    //Models and arrows need to be converted back to their explicit types\r\n\r\n    var newVertices = [];\r\n    var newArrows = [];\r\n\r\n    for(let vert of saveData.vertices){\r\n        console.log(vert)\r\n        vert.semanticIdentity = new SemanticIdentity(vert.semanticIdentity.name,vert.semanticIdentity.description,vert.semanticIdentity.abbreviation,\r\n            vert.semanticIdentity.shortAbbreviation,vert.semanticIdentity.UUID,vert.semanticIdentity.translations)\r\n        //atm its a bit messy as vert constructor doesnt use destructuring so we can specifiy options, when it does this can be changed\r\n        vert = new Vertex (0,0,0,0,0,0,0,0,1,vert)\r\n        newVertices.push(vert)\r\n    }\r\n \r\n\r\n\r\n    setFolderData(saveData.packages);\r\n    setDecoyFolderData(saveData.dPackages);\r\n    setVertexData(saveData.treeVertex);\r\n    setDecoyVertexData(saveData.dTreeVertex);\r\n    setModelData(saveData.graph)\r\n    setDecoyModelData(saveData.dGrraph)\r\n    setTreeData(saveData.tree)\r\n    setTotalRenderKey(saveData.renderKeys)\r\n    setTotalModelKeys(saveData.modelKeys)\r\n    setSelectedFolderKey(1)\r\n    setNewRenderKey(1)\r\n    setNewModel(1)\r\n\r\n\r\n    \r\n    setCurrentObjects(new Graph(newVertices, newArrows));\r\n    updateArrows()\r\n    drawAll()\r\n\r\n\r\n\r\nconsole.log(\"load finished\")\r\n\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport React from 'react';\r\nimport '../App.css';\r\nimport * as canvasDraw from \"./CanvasDraw\";\r\nimport * as fileManager from '../Serialisation/FileManager';\r\nimport {DropdownButton,Dropdown} from \"react-bootstrap\";\r\n\r\nimport {Canvas} from './Canvas';\r\nimport {LeftMenu, LeftMenuType, StringToLeftMenuType, Tool} from './LeftMenu';\r\n\r\n// Semantic domain editor\r\nimport SemanticDomainEditor from \"./SemanticDomainEditor\";\r\nimport {resetRows} from \"./SemanticDomainEditor\";\r\n\r\n//Adding folders to the tree view\r\nimport {handleAddFolder, handleDeleteModel, handleAddModel,handleRenameFolder, getSelectedFolderKey, handleRenameModel, handleAddVertex} from './ContainmentTree';\r\nimport { handleDeleteFolder } from './ContainmentTree';\r\n\r\nimport { showVertexPath } from './ContainmentTree';\r\nimport { someVertexPath } from './ContainmentTree';\r\nimport { ContextMenu } from './ContextMenu'\r\nimport {save, load} from '../Serialisation/NewFileManager'\r\n\r\nimport iconNewFolder from \"../Resources/create_folder.svg\"\r\nimport iconDeleteFolder from \"../Resources/delete_folder.svg\"\r\nimport iconEditFolder from  \"../Resources/changeFolderName.svg\"\r\nimport iconNewModel from \"../Resources/NewModel.svg\"\r\nimport iconDeleteModel from \"../Resources/DeleteModel.svg\"\r\nimport iconEditModel from \"../Resources/editModel.svg\"\r\nimport iconaddVertex from \"../Resources/createVertex.svg\"\r\n\r\n\r\nexport const version = 1;\r\n\r\nlet folderName = \"Unnamed Folder\";\r\n\r\nexport class MainProgramClass extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            zoomLevel: 200,\r\n            drawMode: Tool.Vertex,\r\n            menu: LeftMenuType.TreeView,\r\n            selectedObject: null,\r\n        };\r\n\r\n        this.setMode = this.setMode.bind(this);\r\n        this.setLeftMenu = this.setLeftMenu.bind(this);\r\n        this.setLeftMenuToTree = this.setLeftMenuToTree.bind(this);\r\n        this.semanticTableEnabled = false;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.setMode(Tool.Select);\r\n        console.log(\"Mounted\");\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n        let div = document.getElementById(prevState.SelectedTool);\r\n\r\n        if (div !== null) {\r\n            div.style.backgroundColor = \"#FFFFFF\";\r\n        }\r\n\r\n        div = document.getElementById(this.state.SelectedTool);\r\n\r\n        div.style.backgroundColor = \"#CFFFFF\";\r\n\r\n        //console.log(\"Mode set to: \" + this.state.SelectedTool);\r\n\r\n        // This bit of code here updates the path for whatever vertex is being updated\r\n        if (this.state.selectedObject !== null){\r\n            if (this.state.selectedObject.typeName === \"Vertex\"){\r\n                showVertexPath(this.state.selectedObject)\r\n                this.state.selectedObject.setPath(someVertexPath)\r\n            }\r\n        }\r\n\r\n        \r\n        \r\n    }\r\n\r\n\r\n\r\n    updateFolderName = () => {\r\n        folderName = document.getElementById(\"FolderName\").value\r\n    }\r\n\r\n    //The following add/delete functions Now reload the treeview on add/deleteing folders and models - Lachlan\r\n    //The async function is due to javascript executing SetLeftMenuToTree without waiting for handleadd/delete to manipulate data for the new tree - LAchlan\r\n    addFolder = () => {\r\n        //handleAddFolder({modelName:document.getElementById(\"FolderName\").value});\r\n        //ContainmentTree.state = ContainmentTree.state;\r\n        //LeftMenu.state = LeftMenu.state;\r\n        (async() => {\r\n        await handleAddFolder(folderName,getSelectedFolderKey());\r\n        this.setLeftMenuToTree();\r\n        })();\r\n        \r\n    }\r\n\r\n    deleteFolder = () => {\r\n        (async() => {\r\n            await handleDeleteFolder(getSelectedFolderKey());\r\n            this.setLeftMenuToTree();\r\n            })();\r\n    }\r\n\r\n    editFolderName = () => {\r\n        (async() => {\r\n            await handleRenameFolder(folderName,getSelectedFolderKey());\r\n            this.setLeftMenuToTree();\r\n        })();\r\n    }\r\n\r\n    addVertex = () =>{\r\n        (async() => {\r\n            await handleAddVertex(folderName,getSelectedFolderKey());\r\n            this.setLeftMenuToTree();\r\n        })();\r\n    }\r\n\r\n    addModel = () => {\r\n        (async() => {\r\n            await handleAddModel(folderName);\r\n            this.setLeftMenuToTree();\r\n            })();\r\n    }\r\n\r\n    deleteModel = () => {\r\n        \r\n        (async() => {\r\n            await handleDeleteModel(canvasDraw.getCurrentModel());\r\n            this.setLeftMenuToTree();\r\n            })();\r\n    }\r\n\r\n    editModelName = () => {\r\n        (async() => {\r\n            await handleRenameModel(folderName,canvasDraw.getCurrentModel());\r\n            this.setLeftMenuToTree();\r\n        })();\r\n    }\r\n\r\n    zoom = (type) => {\r\n        let cZoom = this.state.zoomLevel;\r\n        if (type === \"+\") {\r\n            if (this.state.zoomLevel < 500) {\r\n                this.setState({zoomLevel:cZoom += 25});\r\n                canvasDraw.setZoom(cZoom);\r\n            }\r\n        } else if (type === \"-\") {\r\n            if (this.state.zoomLevel > 100) {\r\n                this.setState({zoomLevel:cZoom -= 25});\r\n                canvasDraw.setZoom(cZoom);\r\n            }\r\n\r\n        } else {\r\n            console.log(\"Invalid Zoom Type\")\r\n        }\r\n    };\r\n\r\n    setMode(mode) {\r\n\r\n        if(mode === Tool.Visibility || mode === Tool.Edge || mode === Tool.Specialisation){\r\n            this.setState({drawMode: \"Arrow\"})\r\n        }else if (mode === Tool.Vertex){\r\n            this.setState({drawMode: \"Vertex\"})\r\n        }else if (mode === Tool.Select){\r\n            this.setState({drawMode: \"Select\"})\r\n        } else if (mode === Tool.Artifact) {\r\n            this.setState({ drawMode: \"Artifact\" })\r\n        } else if (mode === Tool.Container) {\r\n            this.setState({ drawMode: \"Container\" })\r\n        }\r\n\r\n        //console.log(Tool[mode]);\r\n\r\n        this.setState({SelectedTool: Tool[mode]});\r\n\r\n        canvasDraw.setArrowType(mode)\r\n\r\n    };\r\n\r\n    // chooses which left hand menu to display, based on the selected item\r\n    setLeftMenu(nearestObject, ctrl = false, OP = []) {\r\n        \r\n        if (OP !== null){\r\n            for(let i = 0;i<OP.length;i++){\r\n                OP[i].setSelected(false); //visually deselects elements\r\n            }\r\n        }\r\n        // checks if that specific object was clicked\r\n        // if it wasn't then deselect it\r\n        // i.e. determines if objects are selected or not\r\n        if (this.state.selectedObject !== null && ctrl === false) {\r\n            this.state.selectedObject.setSelected(false);\r\n            \r\n        }\r\n\r\n        // check if the nearest object was too far away or didnt exist\r\n        if (nearestObject === null) {\r\n            this.setState({\r\n                menu: LeftMenuType.TreeView,\r\n                selectedObject: null,\r\n            });\r\n\r\n        }\r\n\r\n        // if the selected object has a left menu,\r\n        else if (StringToLeftMenuType[nearestObject.typeName] !== null) {\r\n            this.setState({\r\n                menu: nearestObject.typeName,\r\n                selectedObject: nearestObject\r\n            });\r\n            //console.log(\"below should be selectedObject\");\r\n            //console.log(this.state.selectedObject)\r\n            nearestObject.setSelected(true);\r\n        } else {\r\n            if (this.state.selectedObject !== null) {\r\n                canvasDraw.drawAll();\r\n            }\r\n\r\n            this.setState({\r\n                menu: LeftMenuType.TreeView,\r\n                selectedObject: null\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    //Function for setting left menu to tree\r\n    //This function serves as a direct way to \"statechange\" the treeview menu - Lachlan\r\n    setLeftMenuToTree(){\r\n        \r\n        if (this.state.selectedObject !== null) {\r\n            \r\n            canvasDraw.drawAll();\r\n        }\r\n        this.setState({\r\n            \r\n            menu: LeftMenuType.None,\r\n        });\r\n        this.setState({\r\n            menu: LeftMenuType.TreeView,\r\n            selectedObject: null\r\n            \r\n        });\r\n        console.log(\"set left menu To Tree enacted\")\r\n        \r\n    }\r\n\r\n    setModelName = () => {\r\n        this.setState({modelName:document.getElementById(\"ModelName\").value})\r\n    };\r\n\r\n    // Code for file uploading\r\n    // If you know how to move it elsewhere to clean up this file\r\n    // Please move it to src/DataStructures/FileManager.js or similar\r\n    showFile = () => {\r\n        let refreshTree = this.setLeftMenuToTree //This is used so we can point to setLeftMenuToTree within the reader object\r\n        if (window.File && window.FileReader && window.FileList && window.Blob) {\r\n            try {\r\n                let file = document.querySelector('input[type=file]').files[0];\r\n                let reader = new FileReader();\r\n                reader.readAsText(file);\r\n                console.log(reader.result)\r\n                reader.onload = function () {\r\n                    let text = reader.result\r\n                    load(text)\r\n                    refreshTree();\r\n                }\r\n            }catch(e){\r\n                alert(e +\" did you select a file?\")\r\n            }\r\n        } else {\r\n            alert(\"Your browser is too old to support HTML5 File API\");\r\n        }\r\n        return 0;\r\n    };\r\n\r\n\r\n\r\n    // Used to enable/disable the semantic domain editor\r\n    toggleSemanticDomainState = () => {\r\n        if (this.semanticTableEnabled) {\r\n            this.semanticTableEnabled = false;\r\n            canvasDraw.drawAll();\r\n            this.setState(this.state);\r\n            console.log(\"Semantic Domain disabled\");\r\n        } else {\r\n            this.semanticTableEnabled = true;\r\n            resetRows();\r\n            this.setState(this.state);\r\n            console.log(\"Semantic Domain enabled\");\r\n        }\r\n    };\r\n\r\n\r\n\r\n    render() {\r\n        let GUI =\r\n        <><ContextMenu setLeftMenuToTree={this.setLeftMenuToTree} /><div className=\"Program\">\r\n                <div className={this.semanticTableEnabled ? \"SemanticDomain\" : \"hidden\"}>\r\n                    <SemanticDomainEditor />\r\n                </div>\r\n\r\n                <div className=\"TopMenus\">\r\n\r\n                    <DropdownButton variant=\"Primary\" id=\"File-Menu\" title=\"File\" size=\"lg\">\r\n\r\n                        <Dropdown.Item>\r\n                            <div className=\"TopBar\">\r\n                                <button id=\"file\" onClick={() => canvasDraw.newFile()}>New File</button>\r\n                            </div>\r\n                        </Dropdown.Item>\r\n\r\n                        <Dropdown.Item>\r\n                            <div className=\"TopBar\">\r\n                                <button id=\"downloader\" onClick={() => canvasDraw.getDownload()} download=\"image.png\">Export as .png</button>\r\n                            </div>\r\n                        </Dropdown.Item>\r\n\r\n\r\n                        <div className=\"TopBar\">\r\n                            <label>Load</label>\r\n                            <input type=\"file\" id=\"File-Select\" onChange={this.showFile} />\r\n                        </div>\r\n\r\n\r\n                        <Dropdown.Item>\r\n                            <div className=\"TopBar\">\r\n                                <button id=\"json-downloader\" onClick={() => save()}>Save (as Json)</button>\r\n                            </div>\r\n                        </Dropdown.Item>\r\n\r\n                    </DropdownButton>\r\n\r\n                    <div className=\"TopBar\" onClick={() => this.toggleSemanticDomainState()}>\r\n                        Semantic Editor\r\n                    </div>\r\n\r\n                    <input className=\"TopBarSearch\" id=\"ModelName\" type=\"text\" name=\"modelName\" placeholder=\"Graph Name\" onChange={(e) => this.setModelName(e)} />\r\n                    <input className=\"TopBarSearch\" id=\"FolderName\" type=\"text\" name=\"folderName\" placeholder=\"New Container/Model\" onChange={(e) => this.updateFolderName(e)} />\r\n                    {/*<div className=\"TopBarIcon\">&nbsp;</div>*/}\r\n                    {/*The + and - are backwards on purpose here*/}\r\n                    <div className=\"TopBarIcon\" onClick={() => this.zoom('-')}> - </div>\r\n\r\n                    {/*<div className=\"TopBarLabel\"> {this.state.zoomLevel}% </div>*/}\r\n\r\n                    <div className=\"TopBarIcon\" onClick={() => this.zoom('+')}> + </div>\r\n\r\n\r\n                    {/*<div className=\"TopBarIdentifier\">Rows:&nbsp;</div>*/}\r\n                    {/*<input className=\"TopBarSelector\" style={{\"border-left\": \"0px\"}} type=\"number\" id = \"canvasRows\" defaultValue=\"70\" min=\"0\" max=\"105\" onChange={() => canvasDraw.updateRows()}/>*/}\r\n                    <div className=\"TopBarSpace\">&nbsp;</div>\r\n                    <div className=\"TopBarSpace\">&nbsp;</div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.addFolder()}><img src={iconNewFolder} alt=\"Add Container\" /></div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.deleteFolder()}><img src={iconDeleteFolder} alt=\"Delete Container\" /></div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.editFolderName()}><img src={iconEditFolder} alt=\"Edit Container\" /></div>\r\n                    <div className=\"TopBarSpace\">&nbsp;</div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.addVertex()}><img src={iconaddVertex} alt=\"Add Vertex\" /></div>\r\n                    <div className=\"TopBarSpace\">&nbsp;</div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.addModel()}><img src={iconNewModel} alt=\"Add Model\" /></div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.deleteModel()}><img src={iconDeleteModel} alt=\"Delete Model\" /></div>\r\n                    <div className=\"TopBarIcon\" onClick={() => this.editModelName()}><img src={iconEditModel} alt=\"Edit Model\" /></div>\r\n\r\n\r\n\r\n                </div>\r\n\r\n                <div className=\"LowerPanel\" id= \"LowerPanel\">\r\n                    <LeftMenu setMode={this.setMode} setLeftMenu={this.setLeftMenu} mainState={this.state} className=\"LeftMenus\" />\r\n                    {/*following 3 classes are temporary for displaying currently selected model and container(renderKey) and folder(selectedFolderKey) */}\r\n                    <input className=\"SelectedFolder\" id=\"SelectedFolder\" type=\"text\" name=\"selectedFolder\" readonly='readonly' />\r\n                    <input className=\"SelectedContainer\" id=\"SelectedContainer\" type=\"text\" name=\"selectedContainer\" readonly='readonly' />\r\n                    <input className=\"SelectedModel\" id=\"SelectedModel\" type=\"text\" name=\"selectedModel\" readonly='readonly' />\r\n\r\n                    <div className=\"Canvas\" id = \"Canvas\">\r\n                        <Canvas setLeftMenu={this.setLeftMenu} setMode={this.setMode} mainState={this.state} />\r\n                    </div>\r\n                </div>\r\n            </div></>;\r\n        return GUI\r\n    }\r\n}","import { ClickAwayListener } from '@material-ui/core';\r\nimport React from 'react';\r\nimport {getFolderData,setFolderData,getModelData,getSelectedFolderKey,setSelectedFolderKey,handleModelRebase,handleRenameFolder, handleAddModel, getModelNameFromKey, folderData, modelObjects} from \"./ContainmentTree\"\r\nimport {getCurrentRenderKey, setNewRenderKey, getCurrentModel, setNewModel, findIntersected, getGraphXYFromMouseEvent, getObjectFromUUID, getCurrentObjects,setCurrentObjects,\r\n    linkContainer,updateLinkedContainers, currentObjects, drawAll} from \"./CanvasDraw\";\r\nimport {setLeftMenuToTree} from \"./LeftMenu\"\r\nimport { ContactsOutlined, LocalConvenienceStoreOutlined } from '@material-ui/icons';\r\nimport {getSemanticIdentity} from \"../DataStructures/Vertex\"\r\nimport {handleAddVertex, handleDeleteVertex, getVertexData} from \"./ContainmentTree\";\r\nlet rightClickedItem = \"Default\"; //Name of the right clicked item where \"Default\" is a non-object such as empty canvas space\r\nlet rightClickedItemType = \"None\"\r\nlet rightClickedItemKey = 0; // Identifying key of selected item needed to use relating methods eg. selectedFolderKey, ModelKey,VertexKey.\r\nlet menuType = \"Default\"; //Which menu type to return based on the selected item and what operations are available to it\r\nlet rightClickedObject; // the canvas object which was right clicked\r\n\r\n\r\n\r\n//Right click menu component used to access certain function of program\r\nexport class ContextMenu extends React.Component {\r\n    constructor(props){ // added the constructer to drag props in from MainView class (setLeftMenuToTree function)\r\n        super(props);\r\n        \r\n    }\r\n    \r\n    \r\n    state = {\r\n        xPos: \"0px\",\r\n        yPos: \"0px\",\r\n        showMenu: false\r\n    }\r\n\r\n\r\n    componentDidMount() {\r\n        document.addEventListener(\"click\", this.handleClick);\r\n        document.addEventListener(\"contextmenu\", this.handleContextMenu);\r\n        document.addEventListener(\"keypress\", this.handleKey);\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener(\"click\", this.handleClick);\r\n        document.removeEventListener(\"contextmenu\", this.handleContextMenu);\r\n        document.removeEventListener(\"keypress\", this.handleKey);\r\n    }\r\n\r\n    //The handle click method will check which option has been clicked and call the relevant method\r\n    handleClick = (e) => {\r\n        //ignore clicks if context menu closed\r\n        if (this.state.showMenu) {\r\n            //console.log(e.target.id)\r\n            \r\n            //If Move model was selected, create a new context menu with available folders\r\n            if(e.target.id === \"MoveModel\"){\r\n                menuType = \"MoveModel\";\r\n                this.setState({showMenu: true})\r\n            }\r\n            else if(menuType === 'MoveModel' && e.target.id.includes(\"Folder\")){\r\n                let newFolderKey = e.target.id.replace(\"Folder\",'')\r\n                //console.log(newFolderKey) \r\n                handleModelRebase(rightClickedItemKey,parseInt(newFolderKey));\r\n                console.log(\"model \", rightClickedItemKey, \" moved to folder id \",newFolderKey)\r\n                this.setState({showMenu: false})\r\n                this.props.setLeftMenuToTree();\r\n            }\r\n            else if(e.target.id === \"Rename\"){\r\n                menuType = \"Rename\";\r\n                this.setState({showMenu: true})\r\n            }\r\n            else if(e.target.id === \"AddVertex\"){\r\n                menuType = \"AddVertex\";\r\n                this.setState({showMenu: true})\r\n            }\r\n            else if(e.target.id === \"DeleteVertex\"){\r\n                for(let vertex of getVertexData()){\r\n                    if(vertex.renderKey === rightClickedItemKey){\r\n                        handleDeleteVertex(vertex.semanticIdentity.UUID)\r\n                    }\r\n                }\r\n                this.setState({showMenu: false})\r\n                this.props.setLeftMenuToTree();\r\n            }\r\n            else if(e.target.id === \"RenameBox\" || e.target.id === \"CMSelected\"){ //This prevents the context menu closing when certain targets are clicked\r\n            }\r\n            else if(e.target.id === \"VertexNameBox\" || e.target.id === \"CMSelected\"){ //This prevents the context menu closing when certain targets are clicked\r\n            }\r\n            else if(e.target.id === \"Create-Graph\"){\r\n                menuType = \"AddContainerModel\";\r\n                this.setState({showMenu: true})\r\n            }\r\n            else if(menuType === 'AddContainerModel' && e.target.id.includes(\"Folder\")){\r\n                console.log(rightClickedObject)  \r\n                let newFolderKey = e.target.id.replace(\"Folder\",'')\r\n                handleAddModel(rightClickedObject.title,parseInt(newFolderKey),rightClickedObject.semanticIdentity)\r\n                this.props.setLeftMenuToTree();\r\n                this.setState({showMenu: false})\r\n            }\r\n            else if(e.target.id === \"LinkContainer\"){\r\n                menuType = \"LinkContainer\";\r\n                this.setState({showMenu: true})\r\n                console.log(getCurrentObjects().rootVertices)\r\n            }\r\n            else if(menuType === 'LinkContainer' && e.target.id.includes(\"Vertex\")){\r\n                console.log(\"linking semantic\")  \r\n                let baseUUID = e.target.id.replace(\"Vertex\",'');\r\n                let mirrorUUID = rightClickedObject.semanticIdentity.UUID;\r\n                linkContainer(baseUUID,mirrorUUID)\r\n                this.props.setLeftMenuToTree();\r\n\r\n                this.setState({showMenu: false})\r\n            }\r\n            else if(e.target.id === \"Bi-Nav\"){\r\n                menuType = \"Bi-Nav\";\r\n                this.setState({showMenu: true})\r\n\r\n            }\r\n            else if(menuType === 'Bi-Nav' && e.target.id.includes(\"Nav\")){\r\n                console.log(\"navigating\")  \r\n                let keys = e.target.id.replace(\"Nav\",'');\r\n                console.log(keys)\r\n\r\n\r\n                setNewModel(parseInt(keys[0]));\r\n                setNewRenderKey(keys[1]); // automatically sets the renderkey to be the same as the models as this was causing issues - cooper\r\n                setSelectedFolderKey(keys[1]);\r\n                for (let item of currentObjects.flatten()){\r\n                    if (item.typeName === \"Vertex\" && item.getModelKey() === getCurrentModel()){\r\n                        item.setPresent();\r\n                    }\r\n                    else if (item.getModelKey() !== getCurrentModel() && item.typeName === \"Vertex\"){\r\n                        item.setAway();\r\n                    }\r\n                }\r\n                drawAll();\r\n                console.log(getCurrentModel(),getCurrentRenderKey())\r\n                this.props.setLeftMenuToTree();\r\n\r\n\r\n                this.setState({showMenu: false})\r\n            }\r\n\r\n            \r\n            else{this.setState({ showMenu: false });}\r\n            \r\n        }\r\n    }\r\n\r\n    handleKey = (e) => {\r\n        if(e.key === 'Enter'){\r\n            if(menuType === \"Rename\"){\r\n                let newName = document.getElementById(\"RenameBox\").value\r\n                handleRenameFolder(newName,rightClickedItemKey)\r\n                console.log(\"menu change\")\r\n                try{\r\n                this.props.setLeftMenuToTree();\r\n                }\r\n                catch(e){ //Not sure why theres an error here as it performs the method, then says the method doesnt exists, doesnt trigger on other uses of method either.-Lachlan\r\n                    console.log(e)\r\n                }\r\n                console.log(\"menu change fin\")\r\n                this.setState({ showMenu: false })\r\n            }\r\n            else if(menuType === \"AddVertex\"){\r\n                \r\n                let vertexName = document.getElementById(\"VertexNameBox\").value;\r\n                handleAddVertex(vertexName, getSelectedFolderKey());\r\n                try{\r\n                this.props.setLeftMenuToTree();\r\n                }\r\n                catch(e){\r\n                    console.log(e);\r\n                }\r\n                this.setState({showMenu: false});\r\n            }\r\n        }\r\n        /*if(e.key === 'Enter'){\r\n            console.log(\"enter pressed\")\r\n        }\r\n        */\r\n    }\r\n\r\n    \r\n    handleContextMenu = (e) => {\r\n        e.preventDefault();//prevent default stops the regular contextmenu from appearing\r\n\r\n        /*as alot of the \"data\" is in the back end and not in the html element displayed,\r\n         we need to simulate a left click to actually select what were right clicking on in the background \r\n         */\r\n        e.target.click();\r\n\r\n        menuType = \"Default\"; //reset the menu type\r\n        rightClickedItem = \"Default\" //reset the selected item\r\n        rightClickedItemKey = 0 //reset the index\r\n        rightClickedObject = null; // reset the object\r\n        \r\n\r\n        //console.log(e.target.className)\r\n\r\n        //If target is tree node\r\n        if(e.target.className === \"jstree-anchor jstree-hovered jstree-clicked\"){\r\n            //console.log(\"clicked a tree object\")\r\n            //if target is existing folder, load the folder menu\r\n            if(e.target.text.includes(\"\")){\r\n                for(let folder of getFolderData()){\r\n                    if(e.target.text === folder.text){\r\n                        //console.log(\"matching folder found\")\r\n                        menuType = \"Folder\"\r\n                        rightClickedItem = e.target.text;\r\n                        rightClickedItemKey = getSelectedFolderKey();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //if target is existing model, load model menu\r\n            if(e.target.text.includes(\"\")){\r\n                for(let model of getModelData()){\r\n                    if(e.target.text === model.text){\r\n                        //console.log(\"matching model found\")\r\n                        menuType = \"Model\"\r\n                        rightClickedItem = e.target.text;\r\n                        rightClickedItemKey = getCurrentModel();\r\n                    }\r\n                }\r\n            }\r\n            //if target is existing vertex load vertex menu\r\n            if(e.target.text.includes(\"\" || \"\")){\r\n                for(let vertex of getVertexData()){\r\n                    if(e.target.text === vertex.text){\r\n                        menuType = \"Vertex\"\r\n                        rightClickedObject = vertex;\r\n                        rightClickedItem = e.target.text;\r\n                        rightClickedItemKey = getSelectedFolderKey();\r\n\r\n                    }\r\n                }\r\n            }\r\n            \r\n        }\r\n\r\n        \r\n        // if target exists within the canvas\r\n        if(e.target.id ===\"drawCanvas\"){\r\n            let position = getGraphXYFromMouseEvent(e);\r\n            let x = position[0]; let y = position[1];\r\n            rightClickedObject = findIntersected(x, y);\r\n            if(rightClickedObject !== null){\r\n                if(rightClickedObject.typeName === \"Vertex\"){\r\n                    rightClickedItem = rightClickedObject.title\r\n                    if(rightClickedObject.isContainer === true){\r\n                        menuType = \"Container\"\r\n                    }\r\n                    else{\r\n                        menuType = \"CanvasVertex\"\r\n                    }\r\n                    \r\n                }\r\n                else if(rightClickedObject.typeName === \"Arrow\"){\r\n                    let source = getObjectFromUUID(rightClickedObject.sourceVertexUUID);\r\n                    let dest = getObjectFromUUID(rightClickedObject.destVertexUUID);\r\n                    let sourceName = source.title;\r\n                    let destName = dest.title;\r\n                    rightClickedItem = \"Arrow from \" + sourceName + \" to \" + destName\r\n                    menuType = \"Arrow\"\r\n                }\r\n            }\r\n            \r\n        }\r\n        this.setState({\r\n            xPos: `${e.pageX}px`,\r\n            yPos: `${e.pageY}px`,\r\n            showMenu: true,\r\n          });\r\n        \r\n    };\r\n    \r\n\r\n    render() {\r\n        const { showMenu, yPos, xPos } = this.state;\r\n        if (showMenu){\r\n            if(menuType === \"Default\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\">Default</div>   \r\n\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"Folder\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"><b>{rightClickedItem}</b></div>   \r\n                    <div className=\"CMitem\" id=\"Rename\"> Rename</div>\r\n                    <div className=\"CMitem\" id=\"AddVertex\"> Add Vertex</div>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"Model\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>   \r\n                    <div className=\"CMitem\" id=\"Navigate\"> Navigate (not implemented) </div>\r\n                    <div className=\"CMitem\" id=\"MoveModel\"> Move To </div>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"MoveModel\"){\r\n\r\n                let renderedOutput = getFolderData().map(item => <div className=\"CMitem\" id={'Folder'+ item.renderKey} key={item.text}> {item.text} </div>);\r\n\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> Move \"<b>{rightClickedItem}</b>\" To:</div>   \r\n                    <div>{renderedOutput}</div>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"Rename\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>   \r\n                    <input className=\"CMText\" id=\"RenameBox\" type=\"text\" name=\"renameItem\" placeholder='New Name'/>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"AddVertex\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>   \r\n                    <input className=\"CMText\" id=\"VertexNameBox\" type=\"text\" name=\"nameVertex\" placeholder='Vertex Name'/>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"Vertex\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>\r\n                    <div className=\"CMitem\" id=\"Bi-Nav\"> Naviagte </div>   \r\n                    <div className=\"CMitem\" id=\"DeleteVertex\"> Delete Vertex </div>\r\n                    </div>\r\n                )\r\n            }\r\n\r\n            else if(menuType === \"Arrow\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>   \r\n                    <div className=\"CMitem\" id=\"Auto-Layout\"> Auto-Layout option (not implemented) </div>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"CanvasVertex\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>   \r\n                    <div className=\"CMitem\" id=\"Auto-Layout\"> Auto-Layout option (not implemented) </div>\r\n                    <div className=\"CMitem\" id=\"Bi-Nav\"> Naviagte </div>\r\n                    </div>\r\n                )\r\n            }\r\n           \r\n            else if(menuType === \"Container\"){\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> </div>\r\n                    <div className=\"CMitem\" id=\"Create-Graph\"> Create Graph </div>   \r\n                    <div className=\"CMitem\" id=\"LinkContainer\"> Link Container From </div> \r\n                    <div className=\"CMitem\" id=\"Bi-Nav\"> Goto other occurences </div> \r\n                    <div className=\"CMitem\" id=\"Auto-Layout\"> Auto-Layout option (not implemented) </div>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"LinkContainer\"){\r\n                console.log(getCurrentObjects().rootVertices)\r\n                let vertices = Array.from(getCurrentObjects().rootVertices)\r\n                console.log(vertices)\r\n                for(let i in vertices){\r\n                    if (vertices[i].vertex.isContainer === false){\r\n                        vertices.splice(i,1)\r\n                    }\r\n                }\r\n                console.log(vertices)\r\n                \r\n                let renderedOutput = vertices.map(item => <div className=\"CMitem\" id={'Vertex'+ item.vertex.semanticIdentity.UUID} key={'Vertex'+ item.vertex.semanticIdentity.UUID + \" \" + item.vertex.awayx}> {getModelNameFromKey(item.vertex.vertexModelKey)} / {item.vertex.title} </div>);\r\n                \r\n                console.log(renderedOutput)\r\n\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> Link <b>{rightClickedItem}</b> from: </div>\r\n                    <div>{renderedOutput}</div>\r\n                    </div>\r\n                    \r\n                )\r\n            }\r\n            else if(menuType === \"AddContainerModel\"){\r\n                \r\n                let renderedOutput = getFolderData().map(item => <div className=\"CMitem\" id={'Folder'+ item.renderKey} key={item.text}> {item.text} </div>);\r\n\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> Create Model of <b>{rightClickedItem}</b> in:</div>   \r\n                    <div>{renderedOutput}</div>\r\n                    </div>\r\n                )\r\n            }\r\n            else if(menuType === \"Bi-Nav\"){\r\n\r\n                console.log(getCurrentObjects().rootVertices);\r\n                let matchingContainers = [];\r\n                let matchingModels = [];\r\n                let matchingUUID = 0;\r\n\r\n                matchingUUID = rightClickedObject.originalUUID;\r\n                //If undefined, then a treeview vertex is selected\r\n                if(matchingUUID === undefined){\r\n                    matchingUUID = rightClickedObject.semanticIdentity.UUID\r\n                }\r\n                console.log(\"UUID stuff\")\r\n                console.log(matchingUUID)\r\n                console.log(rightClickedObject.semanticIdentity.UUID)\r\n\r\n\r\n                for(let vert of getCurrentObjects().rootVertices){\r\n                    if(vert.vertex.originalUUID === matchingUUID){\r\n                        matchingContainers.push(vert)\r\n                    }\r\n                }\r\n                for(let model of getModelData()){\r\n                    if(model.semanticIdentity.UUID === matchingUUID){\r\n                        matchingModels.push(model)\r\n                    }\r\n                }\r\n\r\n                console.log(matchingContainers)\r\n                let renderedContainers = matchingContainers.map(item => <div className=\"CMitem\" id={'Nav'+ item.vertex.vertexModelKey + \" \" + item.vertex.vertexRenderKey} key={'Nav'+ item.vertex.semanticIdentity.UUID + \" \" + item.vertex.awayx}> {getModelNameFromKey(item.vertex.vertexModelKey)} / {item.vertex.title} </div>)\r\n                let renderedModels = matchingModels.map(item => <div className=\"CMitem\" id={'Nav'+ item.modelKey + \" \" + item.renderKey} key={'Nav'+ item.semanticIdentity.UUID}> {item.text}</div>)\r\n                \r\n\r\n                return (\r\n\r\n                //options are given classnames to identify what has been selected\r\n                    <div className=\"ContextMenu\" style={{top: yPos,left: xPos,}}>\r\n                    <div className=\"CMSelected\" id=\"CMSelected\"> <b>{rightClickedItem}</b> also appears at:</div>   \r\n                    <div>{renderedContainers}</div>\r\n                    <div>{renderedModels}</div>\r\n                    </div>\r\n                )\r\n            }\r\n        }\r\n    else return null;\r\n  }\r\n}\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport React from 'react';\r\n\r\nimport './App.css';\r\nimport  {ContextMenu} from \"./UIElements/ContextMenu\";\r\n\r\nfunction App() {\r\n\r\n  return (\r\n \r\n        <div className=\"App\">\r\n            <div id='program'>\r\n            </div>\r\n        </div>\r\n\r\n  );\r\n\r\n\r\n}\r\n\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// Resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as ServiceWorker from './ServiceWorker';\r\nimport {MainProgramClass} from './UIElements/MainView';\r\nimport {assignElement} from \"./UIElements/CanvasDraw\";\r\nimport {getSaveData} from \"./Serialisation/FileManager\";\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\nReactDOM.render(<MainProgramClass />,document.getElementById(\"program\"));\r\nassignElement(\"drawCanvas\");\r\n\r\n// save to server every interval\r\n\r\n\r\n//setInterval(() => {\r\n//    let data = JSON.stringify(getSaveData());\r\n//\r\n//    fetch('http://localhost:8080/serialisation/save',{\r\n//        method:'POST',\r\n//        headers: {\r\n//            'Accept': '*/*',\r\n//            'Content-Type': 'application/json',\r\n//            'Content-Length':data.length\r\n//        },\r\n//        body: data\r\n//    });\r\n//},60000);\r\n\r\n\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nServiceWorker.unregister();\r\n\r\n"],"sourceRoot":""}